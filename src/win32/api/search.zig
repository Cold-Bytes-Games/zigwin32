//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Types (308)
//--------------------------------------------------------------------------------
const IID_IWordSink_Value = @import("../zig.zig").Guid.initString("CC907054-C058-101A-B554-08002B33B0E6");
pub const IID_IWordSink = &IID_IWordSink_Value;
pub const IWordSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PutWord: fn(
            self: *const IWordSink,
            cwc: u32,
            pwcInBuf: [*:0]const u16,
            cwcSrcLen: u32,
            cwcSrcPos: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PutAltWord: fn(
            self: *const IWordSink,
            cwc: u32,
            pwcInBuf: [*:0]const u16,
            cwcSrcLen: u32,
            cwcSrcPos: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartAltPhrase: fn(
            self: *const IWordSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndAltPhrase: fn(
            self: *const IWordSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PutBreak: fn(
            self: *const IWordSink,
            breakType: WORDREP_BREAK_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWordSink_PutWord(self: *const T, cwc: u32, pwcInBuf: [*:0]const u16, cwcSrcLen: u32, cwcSrcPos: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWordSink.VTable, self.vtable).PutWord(@ptrCast(*const IWordSink, self), cwc, pwcInBuf, cwcSrcLen, cwcSrcPos);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWordSink_PutAltWord(self: *const T, cwc: u32, pwcInBuf: [*:0]const u16, cwcSrcLen: u32, cwcSrcPos: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWordSink.VTable, self.vtable).PutAltWord(@ptrCast(*const IWordSink, self), cwc, pwcInBuf, cwcSrcLen, cwcSrcPos);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWordSink_StartAltPhrase(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWordSink.VTable, self.vtable).StartAltPhrase(@ptrCast(*const IWordSink, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWordSink_EndAltPhrase(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWordSink.VTable, self.vtable).EndAltPhrase(@ptrCast(*const IWordSink, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWordSink_PutBreak(self: *const T, breakType: WORDREP_BREAK_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWordSink.VTable, self.vtable).PutBreak(@ptrCast(*const IWordSink, self), breakType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PFNFILLTEXTBUFFER = fn(
    pTextSource: *TEXT_SOURCE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const TEXT_SOURCE = extern struct {
    pfnFillTextBuffer: PFNFILLTEXTBUFFER,
    awcBuffer: [*:0]const u16,
    iEnd: u32,
    iCur: u32,
};

const IID_IWordBreaker_Value = @import("../zig.zig").Guid.initString("D53552C8-77E3-101A-B552-08002B33B0E6");
pub const IID_IWordBreaker = &IID_IWordBreaker_Value;
pub const IWordBreaker = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: fn(
            self: *const IWordBreaker,
            fQuery: BOOL,
            ulMaxTokenSize: u32,
            pfLicense: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BreakText: fn(
            self: *const IWordBreaker,
            pTextSource: *TEXT_SOURCE,
            pWordSink: *IWordSink,
            pPhraseSink: *IPhraseSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ComposePhrase: fn(
            self: *const IWordBreaker,
            pwcNoun: [*:0]const u16,
            cwcNoun: u32,
            pwcModifier: [*:0]const u16,
            cwcModifier: u32,
            ulAttachmentType: u32,
            pwcPhrase: PWSTR,
            pcwcPhrase: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLicenseToUse: fn(
            self: *const IWordBreaker,
            ppwcsLicense: *const *const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWordBreaker_Init(self: *const T, fQuery: BOOL, ulMaxTokenSize: u32, pfLicense: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWordBreaker.VTable, self.vtable).Init(@ptrCast(*const IWordBreaker, self), fQuery, ulMaxTokenSize, pfLicense);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWordBreaker_BreakText(self: *const T, pTextSource: *TEXT_SOURCE, pWordSink: *IWordSink, pPhraseSink: *IPhraseSink) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWordBreaker.VTable, self.vtable).BreakText(@ptrCast(*const IWordBreaker, self), pTextSource, pWordSink, pPhraseSink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWordBreaker_ComposePhrase(self: *const T, pwcNoun: [*:0]const u16, cwcNoun: u32, pwcModifier: [*:0]const u16, cwcModifier: u32, ulAttachmentType: u32, pwcPhrase: PWSTR, pcwcPhrase: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWordBreaker.VTable, self.vtable).ComposePhrase(@ptrCast(*const IWordBreaker, self), pwcNoun, cwcNoun, pwcModifier, cwcModifier, ulAttachmentType, pwcPhrase, pcwcPhrase);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWordBreaker_GetLicenseToUse(self: *const T, ppwcsLicense: *const *const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWordBreaker.VTable, self.vtable).GetLicenseToUse(@ptrCast(*const IWordBreaker, self), ppwcsLicense);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWordFormSink_Value = @import("../zig.zig").Guid.initString("FE77C330-7F42-11CE-BE57-00AA0051FE20");
pub const IID_IWordFormSink = &IID_IWordFormSink_Value;
pub const IWordFormSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PutAltWord: fn(
            self: *const IWordFormSink,
            pwcInBuf: [*:0]const u16,
            cwc: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PutWord: fn(
            self: *const IWordFormSink,
            pwcInBuf: [*:0]const u16,
            cwc: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWordFormSink_PutAltWord(self: *const T, pwcInBuf: [*:0]const u16, cwc: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWordFormSink.VTable, self.vtable).PutAltWord(@ptrCast(*const IWordFormSink, self), pwcInBuf, cwc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWordFormSink_PutWord(self: *const T, pwcInBuf: [*:0]const u16, cwc: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWordFormSink.VTable, self.vtable).PutWord(@ptrCast(*const IWordFormSink, self), pwcInBuf, cwc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IStemmer_Value = @import("../zig.zig").Guid.initString("EFBAF140-7F42-11CE-BE57-00AA0051FE20");
pub const IID_IStemmer = &IID_IStemmer_Value;
pub const IStemmer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: fn(
            self: *const IStemmer,
            ulMaxTokenSize: u32,
            pfLicense: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GenerateWordForms: fn(
            self: *const IStemmer,
            pwcInBuf: [*:0]const u16,
            cwc: u32,
            pStemSink: *IWordFormSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLicenseToUse: fn(
            self: *const IStemmer,
            ppwcsLicense: *const *const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStemmer_Init(self: *const T, ulMaxTokenSize: u32, pfLicense: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStemmer.VTable, self.vtable).Init(@ptrCast(*const IStemmer, self), ulMaxTokenSize, pfLicense);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStemmer_GenerateWordForms(self: *const T, pwcInBuf: [*:0]const u16, cwc: u32, pStemSink: *IWordFormSink) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStemmer.VTable, self.vtable).GenerateWordForms(@ptrCast(*const IStemmer, self), pwcInBuf, cwc, pStemSink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStemmer_GetLicenseToUse(self: *const T, ppwcsLicense: *const *const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStemmer.VTable, self.vtable).GetLicenseToUse(@ptrCast(*const IStemmer, self), ppwcsLicense);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISimpleCommandCreator_Value = @import("../zig.zig").Guid.initString("5E341AB7-02D0-11D1-900C-00A0C9063796");
pub const IID_ISimpleCommandCreator = &IID_ISimpleCommandCreator_Value;
pub const ISimpleCommandCreator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateICommand: fn(
            self: *const ISimpleCommandCreator,
            ppIUnknown: **IUnknown,
            pOuterUnk: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        VerifyCatalog: fn(
            self: *const ISimpleCommandCreator,
            pwszMachine: [*:0]const u16,
            pwszCatalogName: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultCatalog: fn(
            self: *const ISimpleCommandCreator,
            pwszCatalogName: PWSTR,
            cwcIn: u32,
            pcwcOut: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISimpleCommandCreator_CreateICommand(self: *const T, ppIUnknown: **IUnknown, pOuterUnk: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISimpleCommandCreator.VTable, self.vtable).CreateICommand(@ptrCast(*const ISimpleCommandCreator, self), ppIUnknown, pOuterUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISimpleCommandCreator_VerifyCatalog(self: *const T, pwszMachine: [*:0]const u16, pwszCatalogName: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISimpleCommandCreator.VTable, self.vtable).VerifyCatalog(@ptrCast(*const ISimpleCommandCreator, self), pwszMachine, pwszCatalogName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISimpleCommandCreator_GetDefaultCatalog(self: *const T, pwszCatalogName: PWSTR, cwcIn: u32, pcwcOut: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISimpleCommandCreator.VTable, self.vtable).GetDefaultCatalog(@ptrCast(*const ISimpleCommandCreator, self), pwszCatalogName, cwcIn, pcwcOut);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IColumnMapper_Value = @import("../zig.zig").Guid.initString("0B63E37A-9CCC-11D0-BCDB-00805FCCCE04");
pub const IID_IColumnMapper = &IID_IColumnMapper_Value;
pub const IColumnMapper = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPropInfoFromName: fn(
            self: *const IColumnMapper,
            wcsPropName: [*:0]const u16,
            ppPropId: **DBID,
            pPropType: *u16,
            puiWidth: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropInfoFromId: fn(
            self: *const IColumnMapper,
            pPropId: *const DBID,
            pwcsName: **u16,
            pPropType: *u16,
            puiWidth: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumPropInfo: fn(
            self: *const IColumnMapper,
            iEntry: u32,
            pwcsName: *const *const u16,
            ppPropId: **DBID,
            pPropType: *u16,
            puiWidth: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsMapUpToDate: fn(
            self: *const IColumnMapper,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IColumnMapper_GetPropInfoFromName(self: *const T, wcsPropName: [*:0]const u16, ppPropId: **DBID, pPropType: *u16, puiWidth: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IColumnMapper.VTable, self.vtable).GetPropInfoFromName(@ptrCast(*const IColumnMapper, self), wcsPropName, ppPropId, pPropType, puiWidth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IColumnMapper_GetPropInfoFromId(self: *const T, pPropId: *const DBID, pwcsName: **u16, pPropType: *u16, puiWidth: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IColumnMapper.VTable, self.vtable).GetPropInfoFromId(@ptrCast(*const IColumnMapper, self), pPropId, pwcsName, pPropType, puiWidth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IColumnMapper_EnumPropInfo(self: *const T, iEntry: u32, pwcsName: *const *const u16, ppPropId: **DBID, pPropType: *u16, puiWidth: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IColumnMapper.VTable, self.vtable).EnumPropInfo(@ptrCast(*const IColumnMapper, self), iEntry, pwcsName, ppPropId, pPropType, puiWidth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IColumnMapper_IsMapUpToDate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IColumnMapper.VTable, self.vtable).IsMapUpToDate(@ptrCast(*const IColumnMapper, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IColumnMapperCreator_Value = @import("../zig.zig").Guid.initString("0B63E37B-9CCC-11D0-BCDB-00805FCCCE04");
pub const IID_IColumnMapperCreator = &IID_IColumnMapperCreator_Value;
pub const IColumnMapperCreator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetColumnMapper: fn(
            self: *const IColumnMapperCreator,
            wcsMachineName: [*:0]const u16,
            wcsCatalogName: [*:0]const u16,
            ppColumnMapper: **IColumnMapper,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IColumnMapperCreator_GetColumnMapper(self: *const T, wcsMachineName: [*:0]const u16, wcsCatalogName: [*:0]const u16, ppColumnMapper: **IColumnMapper) callconv(.Inline) HRESULT {
            return @ptrCast(*const IColumnMapperCreator.VTable, self.vtable).GetColumnMapper(@ptrCast(*const IColumnMapperCreator, self), wcsMachineName, wcsCatalogName, ppColumnMapper);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_CSearchManager_Value = @import("../zig.zig").Guid.initString("7D096C5F-AC08-4F1F-BEB7-5C22C517CE39");
pub const CLSID_CSearchManager = &CLSID_CSearchManager_Value;

const CLSID_CSearchRoot_Value = @import("../zig.zig").Guid.initString("30766BD2-EA1C-4F28-BF27-0B44E2F68DB7");
pub const CLSID_CSearchRoot = &CLSID_CSearchRoot_Value;

const CLSID_CSearchScopeRule_Value = @import("../zig.zig").Guid.initString("E63DE750-3BD7-4BE5-9C84-6B4281988C44");
pub const CLSID_CSearchScopeRule = &CLSID_CSearchScopeRule_Value;

const CLSID_FilterRegistration_Value = @import("../zig.zig").Guid.initString("9E175B8D-F52A-11D8-B9A5-505054503030");
pub const CLSID_FilterRegistration = &CLSID_FilterRegistration_Value;

pub const FILTERED_DATA_SOURCES = extern struct {
    pwcsExtension: [*:0]const u16,
    pwcsMime: [*:0]const u16,
    pClsid: *const Guid,
    pwcsOverride: [*:0]const u16,
};

const IID_ILoadFilter_Value = @import("../zig.zig").Guid.initString("C7310722-AC80-11D1-8DF3-00C04FB6EF4F");
pub const IID_ILoadFilter = &IID_ILoadFilter_Value;
pub const ILoadFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LoadIFilter: fn(
            self: *const ILoadFilter,
            pwcsPath: [*:0]const u16,
            pFilteredSources: *FILTERED_DATA_SOURCES,
            pUnkOuter: *IUnknown,
            fUseDefault: BOOL,
            pFilterClsid: *Guid,
            SearchDecSize: *i32,
            pwcsSearchDesc: **u16,
            ppIFilt: **IFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadIFilterFromStorage: fn(
            self: *const ILoadFilter,
            pStg: *IStorage,
            pUnkOuter: *IUnknown,
            pwcsOverride: [*:0]const u16,
            fUseDefault: BOOL,
            pFilterClsid: *Guid,
            SearchDecSize: *i32,
            pwcsSearchDesc: **u16,
            ppIFilt: **IFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadIFilterFromStream: fn(
            self: *const ILoadFilter,
            pStm: *IStream,
            pFilteredSources: *FILTERED_DATA_SOURCES,
            pUnkOuter: *IUnknown,
            fUseDefault: BOOL,
            pFilterClsid: *Guid,
            SearchDecSize: *i32,
            pwcsSearchDesc: **u16,
            ppIFilt: **IFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILoadFilter_LoadIFilter(self: *const T, pwcsPath: [*:0]const u16, pFilteredSources: *FILTERED_DATA_SOURCES, pUnkOuter: *IUnknown, fUseDefault: BOOL, pFilterClsid: *Guid, SearchDecSize: *i32, pwcsSearchDesc: **u16, ppIFilt: **IFilter) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILoadFilter.VTable, self.vtable).LoadIFilter(@ptrCast(*const ILoadFilter, self), pwcsPath, pFilteredSources, pUnkOuter, fUseDefault, pFilterClsid, SearchDecSize, pwcsSearchDesc, ppIFilt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILoadFilter_LoadIFilterFromStorage(self: *const T, pStg: *IStorage, pUnkOuter: *IUnknown, pwcsOverride: [*:0]const u16, fUseDefault: BOOL, pFilterClsid: *Guid, SearchDecSize: *i32, pwcsSearchDesc: **u16, ppIFilt: **IFilter) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILoadFilter.VTable, self.vtable).LoadIFilterFromStorage(@ptrCast(*const ILoadFilter, self), pStg, pUnkOuter, pwcsOverride, fUseDefault, pFilterClsid, SearchDecSize, pwcsSearchDesc, ppIFilt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILoadFilter_LoadIFilterFromStream(self: *const T, pStm: *IStream, pFilteredSources: *FILTERED_DATA_SOURCES, pUnkOuter: *IUnknown, fUseDefault: BOOL, pFilterClsid: *Guid, SearchDecSize: *i32, pwcsSearchDesc: **u16, ppIFilt: **IFilter) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILoadFilter.VTable, self.vtable).LoadIFilterFromStream(@ptrCast(*const ILoadFilter, self), pStm, pFilteredSources, pUnkOuter, fUseDefault, pFilterClsid, SearchDecSize, pwcsSearchDesc, ppIFilt);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ILoadFilterWithPrivateComActivation_Value = @import("../zig.zig").Guid.initString("40BDBD34-780B-48D3-9BB6-12EBD4AD2E75");
pub const IID_ILoadFilterWithPrivateComActivation = &IID_ILoadFilterWithPrivateComActivation_Value;
pub const ILoadFilterWithPrivateComActivation = extern struct {
    pub const VTable = extern struct {
        base: ILoadFilter.VTable,
        LoadIFilterWithPrivateComActivation: fn(
            self: *const ILoadFilterWithPrivateComActivation,
            filteredSources: *FILTERED_DATA_SOURCES,
            useDefault: BOOL,
            filterClsid: *Guid,
            isFilterPrivateComActivated: *BOOL,
            filterObj: **IFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ILoadFilter.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILoadFilterWithPrivateComActivation_LoadIFilterWithPrivateComActivation(self: *const T, filteredSources: *FILTERED_DATA_SOURCES, useDefault: BOOL, filterClsid: *Guid, isFilterPrivateComActivated: *BOOL, filterObj: **IFilter) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILoadFilterWithPrivateComActivation.VTable, self.vtable).LoadIFilterWithPrivateComActivation(@ptrCast(*const ILoadFilterWithPrivateComActivation, self), filteredSources, useDefault, filterClsid, isFilterPrivateComActivated, filterObj);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CONDITION_TYPE = extern enum(i32) {
    CT_AND_CONDITION = 0,
    CT_OR_CONDITION = 1,
    CT_NOT_CONDITION = 2,
    CT_LEAF_CONDITION = 3,
};
pub const CT_AND_CONDITION = CONDITION_TYPE.CT_AND_CONDITION;
pub const CT_OR_CONDITION = CONDITION_TYPE.CT_OR_CONDITION;
pub const CT_NOT_CONDITION = CONDITION_TYPE.CT_NOT_CONDITION;
pub const CT_LEAF_CONDITION = CONDITION_TYPE.CT_LEAF_CONDITION;

pub const CONDITION_OPERATION = extern enum(i32) {
    COP_IMPLICIT = 0,
    COP_EQUAL = 1,
    COP_NOTEQUAL = 2,
    COP_LESSTHAN = 3,
    COP_GREATERTHAN = 4,
    COP_LESSTHANOREQUAL = 5,
    COP_GREATERTHANOREQUAL = 6,
    COP_VALUE_STARTSWITH = 7,
    COP_VALUE_ENDSWITH = 8,
    COP_VALUE_CONTAINS = 9,
    COP_VALUE_NOTCONTAINS = 10,
    COP_DOSWILDCARDS = 11,
    COP_WORD_EQUAL = 12,
    COP_WORD_STARTSWITH = 13,
    COP_APPLICATION_SPECIFIC = 14,
};
pub const COP_IMPLICIT = CONDITION_OPERATION.COP_IMPLICIT;
pub const COP_EQUAL = CONDITION_OPERATION.COP_EQUAL;
pub const COP_NOTEQUAL = CONDITION_OPERATION.COP_NOTEQUAL;
pub const COP_LESSTHAN = CONDITION_OPERATION.COP_LESSTHAN;
pub const COP_GREATERTHAN = CONDITION_OPERATION.COP_GREATERTHAN;
pub const COP_LESSTHANOREQUAL = CONDITION_OPERATION.COP_LESSTHANOREQUAL;
pub const COP_GREATERTHANOREQUAL = CONDITION_OPERATION.COP_GREATERTHANOREQUAL;
pub const COP_VALUE_STARTSWITH = CONDITION_OPERATION.COP_VALUE_STARTSWITH;
pub const COP_VALUE_ENDSWITH = CONDITION_OPERATION.COP_VALUE_ENDSWITH;
pub const COP_VALUE_CONTAINS = CONDITION_OPERATION.COP_VALUE_CONTAINS;
pub const COP_VALUE_NOTCONTAINS = CONDITION_OPERATION.COP_VALUE_NOTCONTAINS;
pub const COP_DOSWILDCARDS = CONDITION_OPERATION.COP_DOSWILDCARDS;
pub const COP_WORD_EQUAL = CONDITION_OPERATION.COP_WORD_EQUAL;
pub const COP_WORD_STARTSWITH = CONDITION_OPERATION.COP_WORD_STARTSWITH;
pub const COP_APPLICATION_SPECIFIC = CONDITION_OPERATION.COP_APPLICATION_SPECIFIC;

const IID_IRichChunk_Value = @import("../zig.zig").Guid.initString("4FDEF69C-DBC9-454E-9910-B34F3C64B510");
pub const IID_IRichChunk = &IID_IRichChunk_Value;
pub const IRichChunk = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetData: fn(
            self: *const IRichChunk,
            pFirstPos: ?*u32,
            pLength: ?*u32,
            ppsz: ?*?PWSTR,
            pValue: ?*PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichChunk_GetData(self: *const T, pFirstPos: ?*u32, pLength: ?*u32, ppsz: ?*?PWSTR, pValue: ?*PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichChunk.VTable, self.vtable).GetData(@ptrCast(*const IRichChunk, self), pFirstPos, pLength, ppsz, pValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICondition_Value = @import("../zig.zig").Guid.initString("0FC988D4-C935-4B97-A973-46282EA175C8");
pub const IID_ICondition = &IID_ICondition_Value;
pub const ICondition = extern struct {
    pub const VTable = extern struct {
        base: IPersistStream.VTable,
        GetConditionType: fn(
            self: *const ICondition,
            pNodeType: *CONDITION_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubConditions: fn(
            self: *const ICondition,
            riid: *const Guid,
            ppv: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetComparisonInfo: fn(
            self: *const ICondition,
            ppszPropertyName: ?*?PWSTR,
            pcop: ?*CONDITION_OPERATION,
            ppropvar: ?*PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetValueType: fn(
            self: *const ICondition,
            ppszValueTypeName: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetValueNormalization: fn(
            self: *const ICondition,
            ppszNormalization: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInputTerms: fn(
            self: *const ICondition,
            ppPropertyTerm: ?*?*IRichChunk,
            ppOperationTerm: ?*?*IRichChunk,
            ppValueTerm: ?*?*IRichChunk,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const ICondition,
            ppc: **ICondition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPersistStream.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICondition_GetConditionType(self: *const T, pNodeType: *CONDITION_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICondition.VTable, self.vtable).GetConditionType(@ptrCast(*const ICondition, self), pNodeType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICondition_GetSubConditions(self: *const T, riid: *const Guid, ppv: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICondition.VTable, self.vtable).GetSubConditions(@ptrCast(*const ICondition, self), riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICondition_GetComparisonInfo(self: *const T, ppszPropertyName: ?*?PWSTR, pcop: ?*CONDITION_OPERATION, ppropvar: ?*PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICondition.VTable, self.vtable).GetComparisonInfo(@ptrCast(*const ICondition, self), ppszPropertyName, pcop, ppropvar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICondition_GetValueType(self: *const T, ppszValueTypeName: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICondition.VTable, self.vtable).GetValueType(@ptrCast(*const ICondition, self), ppszValueTypeName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICondition_GetValueNormalization(self: *const T, ppszNormalization: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICondition.VTable, self.vtable).GetValueNormalization(@ptrCast(*const ICondition, self), ppszNormalization);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICondition_GetInputTerms(self: *const T, ppPropertyTerm: ?*?*IRichChunk, ppOperationTerm: ?*?*IRichChunk, ppValueTerm: ?*?*IRichChunk) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICondition.VTable, self.vtable).GetInputTerms(@ptrCast(*const ICondition, self), ppPropertyTerm, ppOperationTerm, ppValueTerm);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICondition_Clone(self: *const T, ppc: **ICondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICondition.VTable, self.vtable).Clone(@ptrCast(*const ICondition, self), ppc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICondition2_Value = @import("../zig.zig").Guid.initString("0DB8851D-2E5B-47EB-9208-D28C325A01D7");
pub const IID_ICondition2 = &IID_ICondition2_Value;
pub const ICondition2 = extern struct {
    pub const VTable = extern struct {
        base: ICondition.VTable,
        GetLocale: fn(
            self: *const ICondition2,
            ppszLocaleName: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLeafConditionInfo: fn(
            self: *const ICondition2,
            ppropkey: ?*PROPERTYKEY,
            pcop: ?*CONDITION_OPERATION,
            ppropvar: ?*PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICondition.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICondition2_GetLocale(self: *const T, ppszLocaleName: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICondition2.VTable, self.vtable).GetLocale(@ptrCast(*const ICondition2, self), ppszLocaleName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICondition2_GetLeafConditionInfo(self: *const T, ppropkey: ?*PROPERTYKEY, pcop: ?*CONDITION_OPERATION, ppropvar: ?*PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICondition2.VTable, self.vtable).GetLeafConditionInfo(@ptrCast(*const ICondition2, self), ppropkey, pcop, ppropvar);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IRowsetExactScroll = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const DB_NUMERIC = extern struct {
    precision: u8,
    scale: u8,
    sign: u8,
    val: [16]u8,
};

pub const DBVECTOR = extern struct {
    size: u32,
    ptr: *c_void,
};

pub const DBDATE = extern struct {
    year: i16,
    month: u16,
    day: u16,
};

pub const DBTIME = extern struct {
    hour: u16,
    minute: u16,
    second: u16,
};

pub const DBTIMESTAMP = extern struct {
    year: i16,
    month: u16,
    day: u16,
    hour: u16,
    minute: u16,
    second: u16,
    fraction: u32,
};

pub const DB_VARNUMERIC = extern struct {
    precision: u8,
    scale: i8,
    sign: u8,
    val: [1]u8,
};

pub const SEC_OBJECT_ELEMENT = extern struct {
    guidObjectType: Guid,
    ObjectID: DBID,
};

pub const SEC_OBJECT = extern struct {
    cObjects: u32,
    prgObjects: *SEC_OBJECT_ELEMENT,
};

pub const DBIMPLICITSESSION = extern struct {
    pUnkOuter: *IUnknown,
    piid: *Guid,
    pSession: *IUnknown,
};

pub const DBTYPEENUM = extern enum(i32) {
    DBTYPE_EMPTY = 0,
    DBTYPE_NULL = 1,
    DBTYPE_I2 = 2,
    DBTYPE_I4 = 3,
    DBTYPE_R4 = 4,
    DBTYPE_R8 = 5,
    DBTYPE_CY = 6,
    DBTYPE_DATE = 7,
    DBTYPE_BSTR = 8,
    DBTYPE_IDISPATCH = 9,
    DBTYPE_ERROR = 10,
    DBTYPE_BOOL = 11,
    DBTYPE_VARIANT = 12,
    DBTYPE_IUNKNOWN = 13,
    DBTYPE_DECIMAL = 14,
    DBTYPE_UI1 = 17,
    DBTYPE_ARRAY = 8192,
    DBTYPE_BYREF = 16384,
    DBTYPE_I1 = 16,
    DBTYPE_UI2 = 18,
    DBTYPE_UI4 = 19,
    DBTYPE_I8 = 20,
    DBTYPE_UI8 = 21,
    DBTYPE_GUID = 72,
    DBTYPE_VECTOR = 4096,
    DBTYPE_RESERVED = 32768,
    DBTYPE_BYTES = 128,
    DBTYPE_STR = 129,
    DBTYPE_WSTR = 130,
    DBTYPE_NUMERIC = 131,
    DBTYPE_UDT = 132,
    DBTYPE_DBDATE = 133,
    DBTYPE_DBTIME = 134,
    DBTYPE_DBTIMESTAMP = 135,
};
pub const DBTYPE_EMPTY = DBTYPEENUM.DBTYPE_EMPTY;
pub const DBTYPE_NULL = DBTYPEENUM.DBTYPE_NULL;
pub const DBTYPE_I2 = DBTYPEENUM.DBTYPE_I2;
pub const DBTYPE_I4 = DBTYPEENUM.DBTYPE_I4;
pub const DBTYPE_R4 = DBTYPEENUM.DBTYPE_R4;
pub const DBTYPE_R8 = DBTYPEENUM.DBTYPE_R8;
pub const DBTYPE_CY = DBTYPEENUM.DBTYPE_CY;
pub const DBTYPE_DATE = DBTYPEENUM.DBTYPE_DATE;
pub const DBTYPE_BSTR = DBTYPEENUM.DBTYPE_BSTR;
pub const DBTYPE_IDISPATCH = DBTYPEENUM.DBTYPE_IDISPATCH;
pub const DBTYPE_ERROR = DBTYPEENUM.DBTYPE_ERROR;
pub const DBTYPE_BOOL = DBTYPEENUM.DBTYPE_BOOL;
pub const DBTYPE_VARIANT = DBTYPEENUM.DBTYPE_VARIANT;
pub const DBTYPE_IUNKNOWN = DBTYPEENUM.DBTYPE_IUNKNOWN;
pub const DBTYPE_DECIMAL = DBTYPEENUM.DBTYPE_DECIMAL;
pub const DBTYPE_UI1 = DBTYPEENUM.DBTYPE_UI1;
pub const DBTYPE_ARRAY = DBTYPEENUM.DBTYPE_ARRAY;
pub const DBTYPE_BYREF = DBTYPEENUM.DBTYPE_BYREF;
pub const DBTYPE_I1 = DBTYPEENUM.DBTYPE_I1;
pub const DBTYPE_UI2 = DBTYPEENUM.DBTYPE_UI2;
pub const DBTYPE_UI4 = DBTYPEENUM.DBTYPE_UI4;
pub const DBTYPE_I8 = DBTYPEENUM.DBTYPE_I8;
pub const DBTYPE_UI8 = DBTYPEENUM.DBTYPE_UI8;
pub const DBTYPE_GUID = DBTYPEENUM.DBTYPE_GUID;
pub const DBTYPE_VECTOR = DBTYPEENUM.DBTYPE_VECTOR;
pub const DBTYPE_RESERVED = DBTYPEENUM.DBTYPE_RESERVED;
pub const DBTYPE_BYTES = DBTYPEENUM.DBTYPE_BYTES;
pub const DBTYPE_STR = DBTYPEENUM.DBTYPE_STR;
pub const DBTYPE_WSTR = DBTYPEENUM.DBTYPE_WSTR;
pub const DBTYPE_NUMERIC = DBTYPEENUM.DBTYPE_NUMERIC;
pub const DBTYPE_UDT = DBTYPEENUM.DBTYPE_UDT;
pub const DBTYPE_DBDATE = DBTYPEENUM.DBTYPE_DBDATE;
pub const DBTYPE_DBTIME = DBTYPEENUM.DBTYPE_DBTIME;
pub const DBTYPE_DBTIMESTAMP = DBTYPEENUM.DBTYPE_DBTIMESTAMP;

pub const DBTYPEENUM15 = extern enum(i32) {
    DBTYPE_HCHAPTER = 136,
};
pub const DBTYPE_HCHAPTER = DBTYPEENUM15.DBTYPE_HCHAPTER;

pub const DBTYPEENUM20 = extern enum(i32) {
    DBTYPE_FILETIME = 64,
    DBTYPE_PROPVARIANT = 138,
    DBTYPE_VARNUMERIC = 139,
};
pub const DBTYPE_FILETIME = DBTYPEENUM20.DBTYPE_FILETIME;
pub const DBTYPE_PROPVARIANT = DBTYPEENUM20.DBTYPE_PROPVARIANT;
pub const DBTYPE_VARNUMERIC = DBTYPEENUM20.DBTYPE_VARNUMERIC;

pub const DBPARTENUM = extern enum(i32) {
    DBPART_INVALID = 0,
    DBPART_VALUE = 1,
    DBPART_LENGTH = 2,
    DBPART_STATUS = 4,
};
pub const DBPART_INVALID = DBPARTENUM.DBPART_INVALID;
pub const DBPART_VALUE = DBPARTENUM.DBPART_VALUE;
pub const DBPART_LENGTH = DBPARTENUM.DBPART_LENGTH;
pub const DBPART_STATUS = DBPARTENUM.DBPART_STATUS;

pub const DBPARAMIOENUM = extern enum(i32) {
    DBPARAMIO_NOTPARAM = 0,
    DBPARAMIO_INPUT = 1,
    DBPARAMIO_OUTPUT = 2,
};
pub const DBPARAMIO_NOTPARAM = DBPARAMIOENUM.DBPARAMIO_NOTPARAM;
pub const DBPARAMIO_INPUT = DBPARAMIOENUM.DBPARAMIO_INPUT;
pub const DBPARAMIO_OUTPUT = DBPARAMIOENUM.DBPARAMIO_OUTPUT;

pub const DBBINDFLAGENUM = extern enum(i32) {
    DBBINDFLAG_HTML = 1,
};
pub const DBBINDFLAG_HTML = DBBINDFLAGENUM.DBBINDFLAG_HTML;

pub const DBMEMOWNERENUM = extern enum(i32) {
    DBMEMOWNER_CLIENTOWNED = 0,
    DBMEMOWNER_PROVIDEROWNED = 1,
};
pub const DBMEMOWNER_CLIENTOWNED = DBMEMOWNERENUM.DBMEMOWNER_CLIENTOWNED;
pub const DBMEMOWNER_PROVIDEROWNED = DBMEMOWNERENUM.DBMEMOWNER_PROVIDEROWNED;

pub const DBOBJECT = extern struct {
    dwFlags: u32,
    iid: Guid,
};

pub const DBSTATUSENUM = extern enum(i32) {
    DBSTATUS_S_OK = 0,
    DBSTATUS_E_BADACCESSOR = 1,
    DBSTATUS_E_CANTCONVERTVALUE = 2,
    DBSTATUS_S_ISNULL = 3,
    DBSTATUS_S_TRUNCATED = 4,
    DBSTATUS_E_SIGNMISMATCH = 5,
    DBSTATUS_E_DATAOVERFLOW = 6,
    DBSTATUS_E_CANTCREATE = 7,
    DBSTATUS_E_UNAVAILABLE = 8,
    DBSTATUS_E_PERMISSIONDENIED = 9,
    DBSTATUS_E_INTEGRITYVIOLATION = 10,
    DBSTATUS_E_SCHEMAVIOLATION = 11,
    DBSTATUS_E_BADSTATUS = 12,
    DBSTATUS_S_DEFAULT = 13,
};
pub const DBSTATUS_S_OK = DBSTATUSENUM.DBSTATUS_S_OK;
pub const DBSTATUS_E_BADACCESSOR = DBSTATUSENUM.DBSTATUS_E_BADACCESSOR;
pub const DBSTATUS_E_CANTCONVERTVALUE = DBSTATUSENUM.DBSTATUS_E_CANTCONVERTVALUE;
pub const DBSTATUS_S_ISNULL = DBSTATUSENUM.DBSTATUS_S_ISNULL;
pub const DBSTATUS_S_TRUNCATED = DBSTATUSENUM.DBSTATUS_S_TRUNCATED;
pub const DBSTATUS_E_SIGNMISMATCH = DBSTATUSENUM.DBSTATUS_E_SIGNMISMATCH;
pub const DBSTATUS_E_DATAOVERFLOW = DBSTATUSENUM.DBSTATUS_E_DATAOVERFLOW;
pub const DBSTATUS_E_CANTCREATE = DBSTATUSENUM.DBSTATUS_E_CANTCREATE;
pub const DBSTATUS_E_UNAVAILABLE = DBSTATUSENUM.DBSTATUS_E_UNAVAILABLE;
pub const DBSTATUS_E_PERMISSIONDENIED = DBSTATUSENUM.DBSTATUS_E_PERMISSIONDENIED;
pub const DBSTATUS_E_INTEGRITYVIOLATION = DBSTATUSENUM.DBSTATUS_E_INTEGRITYVIOLATION;
pub const DBSTATUS_E_SCHEMAVIOLATION = DBSTATUSENUM.DBSTATUS_E_SCHEMAVIOLATION;
pub const DBSTATUS_E_BADSTATUS = DBSTATUSENUM.DBSTATUS_E_BADSTATUS;
pub const DBSTATUS_S_DEFAULT = DBSTATUSENUM.DBSTATUS_S_DEFAULT;

pub const DBSTATUSENUM20 = extern enum(i32) {
    MDSTATUS_S_CELLEMPTY = 14,
    DBSTATUS_S_IGNORE = 15,
};
pub const MDSTATUS_S_CELLEMPTY = DBSTATUSENUM20.MDSTATUS_S_CELLEMPTY;
pub const DBSTATUS_S_IGNORE = DBSTATUSENUM20.DBSTATUS_S_IGNORE;

pub const DBSTATUSENUM21 = extern enum(i32) {
    DBSTATUS_E_DOESNOTEXIST = 16,
    DBSTATUS_E_INVALIDURL = 17,
    DBSTATUS_E_RESOURCELOCKED = 18,
    DBSTATUS_E_RESOURCEEXISTS = 19,
    DBSTATUS_E_CANNOTCOMPLETE = 20,
    DBSTATUS_E_VOLUMENOTFOUND = 21,
    DBSTATUS_E_OUTOFSPACE = 22,
    DBSTATUS_S_CANNOTDELETESOURCE = 23,
    DBSTATUS_E_READONLY = 24,
    DBSTATUS_E_RESOURCEOUTOFSCOPE = 25,
    DBSTATUS_S_ALREADYEXISTS = 26,
};
pub const DBSTATUS_E_DOESNOTEXIST = DBSTATUSENUM21.DBSTATUS_E_DOESNOTEXIST;
pub const DBSTATUS_E_INVALIDURL = DBSTATUSENUM21.DBSTATUS_E_INVALIDURL;
pub const DBSTATUS_E_RESOURCELOCKED = DBSTATUSENUM21.DBSTATUS_E_RESOURCELOCKED;
pub const DBSTATUS_E_RESOURCEEXISTS = DBSTATUSENUM21.DBSTATUS_E_RESOURCEEXISTS;
pub const DBSTATUS_E_CANNOTCOMPLETE = DBSTATUSENUM21.DBSTATUS_E_CANNOTCOMPLETE;
pub const DBSTATUS_E_VOLUMENOTFOUND = DBSTATUSENUM21.DBSTATUS_E_VOLUMENOTFOUND;
pub const DBSTATUS_E_OUTOFSPACE = DBSTATUSENUM21.DBSTATUS_E_OUTOFSPACE;
pub const DBSTATUS_S_CANNOTDELETESOURCE = DBSTATUSENUM21.DBSTATUS_S_CANNOTDELETESOURCE;
pub const DBSTATUS_E_READONLY = DBSTATUSENUM21.DBSTATUS_E_READONLY;
pub const DBSTATUS_E_RESOURCEOUTOFSCOPE = DBSTATUSENUM21.DBSTATUS_E_RESOURCEOUTOFSCOPE;
pub const DBSTATUS_S_ALREADYEXISTS = DBSTATUSENUM21.DBSTATUS_S_ALREADYEXISTS;

pub const DBBINDURLFLAGENUM = extern enum(i32) {
    DBBINDURLFLAG_READ = 1,
    DBBINDURLFLAG_WRITE = 2,
    DBBINDURLFLAG_READWRITE = 3,
    DBBINDURLFLAG_SHARE_DENY_READ = 4,
    DBBINDURLFLAG_SHARE_DENY_WRITE = 8,
    DBBINDURLFLAG_SHARE_EXCLUSIVE = 12,
    DBBINDURLFLAG_SHARE_DENY_NONE = 16,
    DBBINDURLFLAG_ASYNCHRONOUS = 4096,
    DBBINDURLFLAG_COLLECTION = 8192,
    DBBINDURLFLAG_DELAYFETCHSTREAM = 16384,
    DBBINDURLFLAG_DELAYFETCHCOLUMNS = 32768,
    DBBINDURLFLAG_RECURSIVE = 4194304,
    DBBINDURLFLAG_OUTPUT = 8388608,
    DBBINDURLFLAG_WAITFORINIT = 16777216,
    DBBINDURLFLAG_OPENIFEXISTS = 33554432,
    DBBINDURLFLAG_OVERWRITE = 67108864,
    DBBINDURLFLAG_ISSTRUCTUREDDOCUMENT = 134217728,
};
pub const DBBINDURLFLAG_READ = DBBINDURLFLAGENUM.DBBINDURLFLAG_READ;
pub const DBBINDURLFLAG_WRITE = DBBINDURLFLAGENUM.DBBINDURLFLAG_WRITE;
pub const DBBINDURLFLAG_READWRITE = DBBINDURLFLAGENUM.DBBINDURLFLAG_READWRITE;
pub const DBBINDURLFLAG_SHARE_DENY_READ = DBBINDURLFLAGENUM.DBBINDURLFLAG_SHARE_DENY_READ;
pub const DBBINDURLFLAG_SHARE_DENY_WRITE = DBBINDURLFLAGENUM.DBBINDURLFLAG_SHARE_DENY_WRITE;
pub const DBBINDURLFLAG_SHARE_EXCLUSIVE = DBBINDURLFLAGENUM.DBBINDURLFLAG_SHARE_EXCLUSIVE;
pub const DBBINDURLFLAG_SHARE_DENY_NONE = DBBINDURLFLAGENUM.DBBINDURLFLAG_SHARE_DENY_NONE;
pub const DBBINDURLFLAG_ASYNCHRONOUS = DBBINDURLFLAGENUM.DBBINDURLFLAG_ASYNCHRONOUS;
pub const DBBINDURLFLAG_COLLECTION = DBBINDURLFLAGENUM.DBBINDURLFLAG_COLLECTION;
pub const DBBINDURLFLAG_DELAYFETCHSTREAM = DBBINDURLFLAGENUM.DBBINDURLFLAG_DELAYFETCHSTREAM;
pub const DBBINDURLFLAG_DELAYFETCHCOLUMNS = DBBINDURLFLAGENUM.DBBINDURLFLAG_DELAYFETCHCOLUMNS;
pub const DBBINDURLFLAG_RECURSIVE = DBBINDURLFLAGENUM.DBBINDURLFLAG_RECURSIVE;
pub const DBBINDURLFLAG_OUTPUT = DBBINDURLFLAGENUM.DBBINDURLFLAG_OUTPUT;
pub const DBBINDURLFLAG_WAITFORINIT = DBBINDURLFLAGENUM.DBBINDURLFLAG_WAITFORINIT;
pub const DBBINDURLFLAG_OPENIFEXISTS = DBBINDURLFLAGENUM.DBBINDURLFLAG_OPENIFEXISTS;
pub const DBBINDURLFLAG_OVERWRITE = DBBINDURLFLAGENUM.DBBINDURLFLAG_OVERWRITE;
pub const DBBINDURLFLAG_ISSTRUCTUREDDOCUMENT = DBBINDURLFLAGENUM.DBBINDURLFLAG_ISSTRUCTUREDDOCUMENT;

pub const DBBINDURLSTATUSENUM = extern enum(i32) {
    DBBINDURLSTATUS_S_OK = 0,
    DBBINDURLSTATUS_S_DENYNOTSUPPORTED = 1,
    DBBINDURLSTATUS_S_DENYTYPENOTSUPPORTED = 4,
    DBBINDURLSTATUS_S_REDIRECTED = 8,
};
pub const DBBINDURLSTATUS_S_OK = DBBINDURLSTATUSENUM.DBBINDURLSTATUS_S_OK;
pub const DBBINDURLSTATUS_S_DENYNOTSUPPORTED = DBBINDURLSTATUSENUM.DBBINDURLSTATUS_S_DENYNOTSUPPORTED;
pub const DBBINDURLSTATUS_S_DENYTYPENOTSUPPORTED = DBBINDURLSTATUSENUM.DBBINDURLSTATUS_S_DENYTYPENOTSUPPORTED;
pub const DBBINDURLSTATUS_S_REDIRECTED = DBBINDURLSTATUSENUM.DBBINDURLSTATUS_S_REDIRECTED;

pub const DBSTATUSENUM25 = extern enum(i32) {
    DBSTATUS_E_CANCELED = 27,
    DBSTATUS_E_NOTCOLLECTION = 28,
};
pub const DBSTATUS_E_CANCELED = DBSTATUSENUM25.DBSTATUS_E_CANCELED;
pub const DBSTATUS_E_NOTCOLLECTION = DBSTATUSENUM25.DBSTATUS_E_NOTCOLLECTION;

pub const DBBINDEXT = extern struct {
    pExtension: *u8,
    ulExtension: u32,
};

pub const DBBINDING = extern struct {
    iOrdinal: u32,
    obValue: u32,
    obLength: u32,
    obStatus: u32,
    pTypeInfo: *ITypeInfo,
    pObject: *DBOBJECT,
    pBindExt: *DBBINDEXT,
    dwPart: u32,
    dwMemOwner: u32,
    eParamIO: u32,
    cbMaxLen: u32,
    dwFlags: u32,
    wType: u16,
    bPrecision: u8,
    bScale: u8,
};

pub const DBROWSTATUSENUM = extern enum(i32) {
    DBROWSTATUS_S_OK = 0,
    DBROWSTATUS_S_MULTIPLECHANGES = 2,
    DBROWSTATUS_S_PENDINGCHANGES = 3,
    DBROWSTATUS_E_CANCELED = 4,
    DBROWSTATUS_E_CANTRELEASE = 6,
    DBROWSTATUS_E_CONCURRENCYVIOLATION = 7,
    DBROWSTATUS_E_DELETED = 8,
    DBROWSTATUS_E_PENDINGINSERT = 9,
    DBROWSTATUS_E_NEWLYINSERTED = 10,
    DBROWSTATUS_E_INTEGRITYVIOLATION = 11,
    DBROWSTATUS_E_INVALID = 12,
    DBROWSTATUS_E_MAXPENDCHANGESEXCEEDED = 13,
    DBROWSTATUS_E_OBJECTOPEN = 14,
    DBROWSTATUS_E_OUTOFMEMORY = 15,
    DBROWSTATUS_E_PERMISSIONDENIED = 16,
    DBROWSTATUS_E_LIMITREACHED = 17,
    DBROWSTATUS_E_SCHEMAVIOLATION = 18,
    DBROWSTATUS_E_FAIL = 19,
};
pub const DBROWSTATUS_S_OK = DBROWSTATUSENUM.DBROWSTATUS_S_OK;
pub const DBROWSTATUS_S_MULTIPLECHANGES = DBROWSTATUSENUM.DBROWSTATUS_S_MULTIPLECHANGES;
pub const DBROWSTATUS_S_PENDINGCHANGES = DBROWSTATUSENUM.DBROWSTATUS_S_PENDINGCHANGES;
pub const DBROWSTATUS_E_CANCELED = DBROWSTATUSENUM.DBROWSTATUS_E_CANCELED;
pub const DBROWSTATUS_E_CANTRELEASE = DBROWSTATUSENUM.DBROWSTATUS_E_CANTRELEASE;
pub const DBROWSTATUS_E_CONCURRENCYVIOLATION = DBROWSTATUSENUM.DBROWSTATUS_E_CONCURRENCYVIOLATION;
pub const DBROWSTATUS_E_DELETED = DBROWSTATUSENUM.DBROWSTATUS_E_DELETED;
pub const DBROWSTATUS_E_PENDINGINSERT = DBROWSTATUSENUM.DBROWSTATUS_E_PENDINGINSERT;
pub const DBROWSTATUS_E_NEWLYINSERTED = DBROWSTATUSENUM.DBROWSTATUS_E_NEWLYINSERTED;
pub const DBROWSTATUS_E_INTEGRITYVIOLATION = DBROWSTATUSENUM.DBROWSTATUS_E_INTEGRITYVIOLATION;
pub const DBROWSTATUS_E_INVALID = DBROWSTATUSENUM.DBROWSTATUS_E_INVALID;
pub const DBROWSTATUS_E_MAXPENDCHANGESEXCEEDED = DBROWSTATUSENUM.DBROWSTATUS_E_MAXPENDCHANGESEXCEEDED;
pub const DBROWSTATUS_E_OBJECTOPEN = DBROWSTATUSENUM.DBROWSTATUS_E_OBJECTOPEN;
pub const DBROWSTATUS_E_OUTOFMEMORY = DBROWSTATUSENUM.DBROWSTATUS_E_OUTOFMEMORY;
pub const DBROWSTATUS_E_PERMISSIONDENIED = DBROWSTATUSENUM.DBROWSTATUS_E_PERMISSIONDENIED;
pub const DBROWSTATUS_E_LIMITREACHED = DBROWSTATUSENUM.DBROWSTATUS_E_LIMITREACHED;
pub const DBROWSTATUS_E_SCHEMAVIOLATION = DBROWSTATUSENUM.DBROWSTATUS_E_SCHEMAVIOLATION;
pub const DBROWSTATUS_E_FAIL = DBROWSTATUSENUM.DBROWSTATUS_E_FAIL;

pub const DBROWSTATUSENUM20 = extern enum(i32) {
    DBROWSTATUS_S_NOCHANGE = 20,
};
pub const DBROWSTATUS_S_NOCHANGE = DBROWSTATUSENUM20.DBROWSTATUS_S_NOCHANGE;

pub const DBSTATUSENUM26 = extern enum(i32) {
    DBSTATUS_S_ROWSETCOLUMN = 29,
};
pub const DBSTATUS_S_ROWSETCOLUMN = DBSTATUSENUM26.DBSTATUS_S_ROWSETCOLUMN;

pub const DBFAILUREINFO = extern struct {
    hRow: ?*c_void,
    iColumn: u32,
    failure: HRESULT,
};

pub const DBCOLUMNFLAGSENUM = extern enum(i32) {
    DBCOLUMNFLAGS_ISBOOKMARK = 1,
    DBCOLUMNFLAGS_MAYDEFER = 2,
    DBCOLUMNFLAGS_WRITE = 4,
    DBCOLUMNFLAGS_WRITEUNKNOWN = 8,
    DBCOLUMNFLAGS_ISFIXEDLENGTH = 16,
    DBCOLUMNFLAGS_ISNULLABLE = 32,
    DBCOLUMNFLAGS_MAYBENULL = 64,
    DBCOLUMNFLAGS_ISLONG = 128,
    DBCOLUMNFLAGS_ISROWID = 256,
    DBCOLUMNFLAGS_ISROWVER = 512,
    DBCOLUMNFLAGS_CACHEDEFERRED = 4096,
};
pub const DBCOLUMNFLAGS_ISBOOKMARK = DBCOLUMNFLAGSENUM.DBCOLUMNFLAGS_ISBOOKMARK;
pub const DBCOLUMNFLAGS_MAYDEFER = DBCOLUMNFLAGSENUM.DBCOLUMNFLAGS_MAYDEFER;
pub const DBCOLUMNFLAGS_WRITE = DBCOLUMNFLAGSENUM.DBCOLUMNFLAGS_WRITE;
pub const DBCOLUMNFLAGS_WRITEUNKNOWN = DBCOLUMNFLAGSENUM.DBCOLUMNFLAGS_WRITEUNKNOWN;
pub const DBCOLUMNFLAGS_ISFIXEDLENGTH = DBCOLUMNFLAGSENUM.DBCOLUMNFLAGS_ISFIXEDLENGTH;
pub const DBCOLUMNFLAGS_ISNULLABLE = DBCOLUMNFLAGSENUM.DBCOLUMNFLAGS_ISNULLABLE;
pub const DBCOLUMNFLAGS_MAYBENULL = DBCOLUMNFLAGSENUM.DBCOLUMNFLAGS_MAYBENULL;
pub const DBCOLUMNFLAGS_ISLONG = DBCOLUMNFLAGSENUM.DBCOLUMNFLAGS_ISLONG;
pub const DBCOLUMNFLAGS_ISROWID = DBCOLUMNFLAGSENUM.DBCOLUMNFLAGS_ISROWID;
pub const DBCOLUMNFLAGS_ISROWVER = DBCOLUMNFLAGSENUM.DBCOLUMNFLAGS_ISROWVER;
pub const DBCOLUMNFLAGS_CACHEDEFERRED = DBCOLUMNFLAGSENUM.DBCOLUMNFLAGS_CACHEDEFERRED;

pub const DBCOLUMNFLAGSENUM20 = extern enum(i32) {
    DBCOLUMNFLAGS_SCALEISNEGATIVE = 16384,
    DBCOLUMNFLAGS_RESERVED = 32768,
};
pub const DBCOLUMNFLAGS_SCALEISNEGATIVE = DBCOLUMNFLAGSENUM20.DBCOLUMNFLAGS_SCALEISNEGATIVE;
pub const DBCOLUMNFLAGS_RESERVED = DBCOLUMNFLAGSENUM20.DBCOLUMNFLAGS_RESERVED;

pub const DBCOLUMNFLAGS15ENUM = extern enum(i32) {
    DBCOLUMNFLAGS_ISCHAPTER = 8192,
};
pub const DBCOLUMNFLAGS_ISCHAPTER = DBCOLUMNFLAGS15ENUM.DBCOLUMNFLAGS_ISCHAPTER;

pub const DBCOLUMNFLAGSENUM21 = extern enum(i32) {
    DBCOLUMNFLAGS_ISROWURL = 65536,
    DBCOLUMNFLAGS_ISDEFAULTSTREAM = 131072,
    DBCOLUMNFLAGS_ISCOLLECTION = 262144,
};
pub const DBCOLUMNFLAGS_ISROWURL = DBCOLUMNFLAGSENUM21.DBCOLUMNFLAGS_ISROWURL;
pub const DBCOLUMNFLAGS_ISDEFAULTSTREAM = DBCOLUMNFLAGSENUM21.DBCOLUMNFLAGS_ISDEFAULTSTREAM;
pub const DBCOLUMNFLAGS_ISCOLLECTION = DBCOLUMNFLAGSENUM21.DBCOLUMNFLAGS_ISCOLLECTION;

pub const DBCOLUMNFLAGSENUM26 = extern enum(i32) {
    DBCOLUMNFLAGS_ISSTREAM = 524288,
    DBCOLUMNFLAGS_ISROWSET = 1048576,
    DBCOLUMNFLAGS_ISROW = 2097152,
    DBCOLUMNFLAGS_ROWSPECIFICCOLUMN = 4194304,
};
pub const DBCOLUMNFLAGS_ISSTREAM = DBCOLUMNFLAGSENUM26.DBCOLUMNFLAGS_ISSTREAM;
pub const DBCOLUMNFLAGS_ISROWSET = DBCOLUMNFLAGSENUM26.DBCOLUMNFLAGS_ISROWSET;
pub const DBCOLUMNFLAGS_ISROW = DBCOLUMNFLAGSENUM26.DBCOLUMNFLAGS_ISROW;
pub const DBCOLUMNFLAGS_ROWSPECIFICCOLUMN = DBCOLUMNFLAGSENUM26.DBCOLUMNFLAGS_ROWSPECIFICCOLUMN;

pub const DBTABLESTATISTICSTYPE26 = extern enum(i32) {
    DBSTAT_HISTOGRAM = 1,
    DBSTAT_COLUMN_CARDINALITY = 2,
    DBSTAT_TUPLE_CARDINALITY = 4,
};
pub const DBSTAT_HISTOGRAM = DBTABLESTATISTICSTYPE26.DBSTAT_HISTOGRAM;
pub const DBSTAT_COLUMN_CARDINALITY = DBTABLESTATISTICSTYPE26.DBSTAT_COLUMN_CARDINALITY;
pub const DBSTAT_TUPLE_CARDINALITY = DBTABLESTATISTICSTYPE26.DBSTAT_TUPLE_CARDINALITY;

pub const DBCOLUMNINFO = extern struct {
    pwszName: PWSTR,
    pTypeInfo: *ITypeInfo,
    iOrdinal: u32,
    dwFlags: u32,
    ulColumnSize: u32,
    wType: u16,
    bPrecision: u8,
    bScale: u8,
    columnid: DBID,
};

pub const DBBOOKMARK = extern enum(i32) {
    DBBMK_INVALID = 0,
    DBBMK_FIRST = 1,
    DBBMK_LAST = 2,
};
pub const DBBMK_INVALID = DBBOOKMARK.DBBMK_INVALID;
pub const DBBMK_FIRST = DBBOOKMARK.DBBMK_FIRST;
pub const DBBMK_LAST = DBBOOKMARK.DBBMK_LAST;

pub const DBPROPENUM = extern enum(i32) {
    DBPROP_ABORTPRESERVE = 2,
    DBPROP_ACTIVESESSIONS = 3,
    DBPROP_APPENDONLY = 187,
    DBPROP_ASYNCTXNABORT = 168,
    DBPROP_ASYNCTXNCOMMIT = 4,
    DBPROP_AUTH_CACHE_AUTHINFO = 5,
    DBPROP_AUTH_ENCRYPT_PASSWORD = 6,
    DBPROP_AUTH_INTEGRATED = 7,
    DBPROP_AUTH_MASK_PASSWORD = 8,
    DBPROP_AUTH_PASSWORD = 9,
    DBPROP_AUTH_PERSIST_ENCRYPTED = 10,
    DBPROP_AUTH_PERSIST_SENSITIVE_AUTHINFO = 11,
    DBPROP_AUTH_USERID = 12,
    DBPROP_BLOCKINGSTORAGEOBJECTS = 13,
    DBPROP_BOOKMARKS = 14,
    DBPROP_BOOKMARKSKIPPED = 15,
    DBPROP_BOOKMARKTYPE = 16,
    DBPROP_BYREFACCESSORS = 120,
    DBPROP_CACHEDEFERRED = 17,
    DBPROP_CANFETCHBACKWARDS = 18,
    DBPROP_CANHOLDROWS = 19,
    DBPROP_CANSCROLLBACKWARDS = 21,
    DBPROP_CATALOGLOCATION = 22,
    DBPROP_CATALOGTERM = 23,
    DBPROP_CATALOGUSAGE = 24,
    DBPROP_CHANGEINSERTEDROWS = 188,
    DBPROP_COL_AUTOINCREMENT = 26,
    DBPROP_COL_DEFAULT = 27,
    DBPROP_COL_DESCRIPTION = 28,
    DBPROP_COL_FIXEDLENGTH = 167,
    DBPROP_COL_NULLABLE = 29,
    DBPROP_COL_PRIMARYKEY = 30,
    DBPROP_COL_UNIQUE = 31,
    DBPROP_COLUMNDEFINITION = 32,
    DBPROP_COLUMNRESTRICT = 33,
    DBPROP_COMMANDTIMEOUT = 34,
    DBPROP_COMMITPRESERVE = 35,
    DBPROP_CONCATNULLBEHAVIOR = 36,
    DBPROP_CURRENTCATALOG = 37,
    DBPROP_DATASOURCENAME = 38,
    DBPROP_DATASOURCEREADONLY = 39,
    DBPROP_DBMSNAME = 40,
    DBPROP_DBMSVER = 41,
    DBPROP_DEFERRED = 42,
    DBPROP_DELAYSTORAGEOBJECTS = 43,
    DBPROP_DSOTHREADMODEL = 169,
    DBPROP_GROUPBY = 44,
    DBPROP_HETEROGENEOUSTABLES = 45,
    DBPROP_IAccessor = 121,
    DBPROP_IColumnsInfo = 122,
    DBPROP_IColumnsRowset = 123,
    DBPROP_IConnectionPointContainer = 124,
    DBPROP_IConvertType = 194,
    DBPROP_IRowset = 126,
    DBPROP_IRowsetChange = 127,
    DBPROP_IRowsetIdentity = 128,
    DBPROP_IRowsetIndex = 159,
    DBPROP_IRowsetInfo = 129,
    DBPROP_IRowsetLocate = 130,
    DBPROP_IRowsetResynch = 132,
    DBPROP_IRowsetScroll = 133,
    DBPROP_IRowsetUpdate = 134,
    DBPROP_ISupportErrorInfo = 135,
    DBPROP_ILockBytes = 136,
    DBPROP_ISequentialStream = 137,
    DBPROP_IStorage = 138,
    DBPROP_IStream = 139,
    DBPROP_IDENTIFIERCASE = 46,
    DBPROP_IMMOBILEROWS = 47,
    DBPROP_INDEX_AUTOUPDATE = 48,
    DBPROP_INDEX_CLUSTERED = 49,
    DBPROP_INDEX_FILLFACTOR = 50,
    DBPROP_INDEX_INITIALSIZE = 51,
    DBPROP_INDEX_NULLCOLLATION = 52,
    DBPROP_INDEX_NULLS = 53,
    DBPROP_INDEX_PRIMARYKEY = 54,
    DBPROP_INDEX_SORTBOOKMARKS = 55,
    DBPROP_INDEX_TEMPINDEX = 163,
    DBPROP_INDEX_TYPE = 56,
    DBPROP_INDEX_UNIQUE = 57,
    DBPROP_INIT_DATASOURCE = 59,
    DBPROP_INIT_HWND = 60,
    DBPROP_INIT_IMPERSONATION_LEVEL = 61,
    DBPROP_INIT_LCID = 186,
    DBPROP_INIT_LOCATION = 62,
    DBPROP_INIT_MODE = 63,
    DBPROP_INIT_PROMPT = 64,
    DBPROP_INIT_PROTECTION_LEVEL = 65,
    DBPROP_INIT_PROVIDERSTRING = 160,
    DBPROP_INIT_TIMEOUT = 66,
    DBPROP_LITERALBOOKMARKS = 67,
    DBPROP_LITERALIDENTITY = 68,
    DBPROP_MAXINDEXSIZE = 70,
    DBPROP_MAXOPENROWS = 71,
    DBPROP_MAXPENDINGROWS = 72,
    DBPROP_MAXROWS = 73,
    DBPROP_MAXROWSIZE = 74,
    DBPROP_MAXROWSIZEINCLUDESBLOB = 75,
    DBPROP_MAXTABLESINSELECT = 76,
    DBPROP_MAYWRITECOLUMN = 77,
    DBPROP_MEMORYUSAGE = 78,
    DBPROP_MULTIPLEPARAMSETS = 191,
    DBPROP_MULTIPLERESULTS = 196,
    DBPROP_MULTIPLESTORAGEOBJECTS = 80,
    DBPROP_MULTITABLEUPDATE = 81,
    DBPROP_NOTIFICATIONGRANULARITY = 198,
    DBPROP_NOTIFICATIONPHASES = 82,
    DBPROP_NOTIFYCOLUMNSET = 171,
    DBPROP_NOTIFYROWDELETE = 173,
    DBPROP_NOTIFYROWFIRSTCHANGE = 174,
    DBPROP_NOTIFYROWINSERT = 175,
    DBPROP_NOTIFYROWRESYNCH = 177,
    DBPROP_NOTIFYROWSETCHANGED = 211,
    DBPROP_NOTIFYROWSETRELEASE = 178,
    DBPROP_NOTIFYROWSETFETCHPOSITIONCHANGE = 179,
    DBPROP_NOTIFYROWUNDOCHANGE = 180,
    DBPROP_NOTIFYROWUNDODELETE = 181,
    DBPROP_NOTIFYROWUNDOINSERT = 182,
    DBPROP_NOTIFYROWUPDATE = 183,
    DBPROP_NULLCOLLATION = 83,
    DBPROP_OLEOBJECTS = 84,
    DBPROP_ORDERBYCOLUMNSINSELECT = 85,
    DBPROP_ORDEREDBOOKMARKS = 86,
    DBPROP_OTHERINSERT = 87,
    DBPROP_OTHERUPDATEDELETE = 88,
    DBPROP_OUTPUTPARAMETERAVAILABILITY = 184,
    DBPROP_OWNINSERT = 89,
    DBPROP_OWNUPDATEDELETE = 90,
    DBPROP_PERSISTENTIDTYPE = 185,
    DBPROP_PREPAREABORTBEHAVIOR = 91,
    DBPROP_PREPARECOMMITBEHAVIOR = 92,
    DBPROP_PROCEDURETERM = 93,
    DBPROP_PROVIDERNAME = 96,
    DBPROP_PROVIDEROLEDBVER = 97,
    DBPROP_PROVIDERVER = 98,
    DBPROP_QUICKRESTART = 99,
    DBPROP_QUOTEDIDENTIFIERCASE = 100,
    DBPROP_REENTRANTEVENTS = 101,
    DBPROP_REMOVEDELETED = 102,
    DBPROP_REPORTMULTIPLECHANGES = 103,
    DBPROP_RETURNPENDINGINSERTS = 189,
    DBPROP_ROWRESTRICT = 104,
    DBPROP_ROWSETCONVERSIONSONCOMMAND = 192,
    DBPROP_ROWTHREADMODEL = 105,
    DBPROP_SCHEMATERM = 106,
    DBPROP_SCHEMAUSAGE = 107,
    DBPROP_SERVERCURSOR = 108,
    DBPROP_SESS_AUTOCOMMITISOLEVELS = 190,
    DBPROP_SQLSUPPORT = 109,
    DBPROP_STRONGIDENTITY = 119,
    DBPROP_STRUCTUREDSTORAGE = 111,
    DBPROP_SUBQUERIES = 112,
    DBPROP_SUPPORTEDTXNDDL = 161,
    DBPROP_SUPPORTEDTXNISOLEVELS = 113,
    DBPROP_SUPPORTEDTXNISORETAIN = 114,
    DBPROP_TABLETERM = 115,
    DBPROP_TBL_TEMPTABLE = 140,
    DBPROP_TRANSACTEDOBJECT = 116,
    DBPROP_UPDATABILITY = 117,
    DBPROP_USERNAME = 118,
};
pub const DBPROP_ABORTPRESERVE = DBPROPENUM.DBPROP_ABORTPRESERVE;
pub const DBPROP_ACTIVESESSIONS = DBPROPENUM.DBPROP_ACTIVESESSIONS;
pub const DBPROP_APPENDONLY = DBPROPENUM.DBPROP_APPENDONLY;
pub const DBPROP_ASYNCTXNABORT = DBPROPENUM.DBPROP_ASYNCTXNABORT;
pub const DBPROP_ASYNCTXNCOMMIT = DBPROPENUM.DBPROP_ASYNCTXNCOMMIT;
pub const DBPROP_AUTH_CACHE_AUTHINFO = DBPROPENUM.DBPROP_AUTH_CACHE_AUTHINFO;
pub const DBPROP_AUTH_ENCRYPT_PASSWORD = DBPROPENUM.DBPROP_AUTH_ENCRYPT_PASSWORD;
pub const DBPROP_AUTH_INTEGRATED = DBPROPENUM.DBPROP_AUTH_INTEGRATED;
pub const DBPROP_AUTH_MASK_PASSWORD = DBPROPENUM.DBPROP_AUTH_MASK_PASSWORD;
pub const DBPROP_AUTH_PASSWORD = DBPROPENUM.DBPROP_AUTH_PASSWORD;
pub const DBPROP_AUTH_PERSIST_ENCRYPTED = DBPROPENUM.DBPROP_AUTH_PERSIST_ENCRYPTED;
pub const DBPROP_AUTH_PERSIST_SENSITIVE_AUTHINFO = DBPROPENUM.DBPROP_AUTH_PERSIST_SENSITIVE_AUTHINFO;
pub const DBPROP_AUTH_USERID = DBPROPENUM.DBPROP_AUTH_USERID;
pub const DBPROP_BLOCKINGSTORAGEOBJECTS = DBPROPENUM.DBPROP_BLOCKINGSTORAGEOBJECTS;
pub const DBPROP_BOOKMARKS = DBPROPENUM.DBPROP_BOOKMARKS;
pub const DBPROP_BOOKMARKSKIPPED = DBPROPENUM.DBPROP_BOOKMARKSKIPPED;
pub const DBPROP_BOOKMARKTYPE = DBPROPENUM.DBPROP_BOOKMARKTYPE;
pub const DBPROP_BYREFACCESSORS = DBPROPENUM.DBPROP_BYREFACCESSORS;
pub const DBPROP_CACHEDEFERRED = DBPROPENUM.DBPROP_CACHEDEFERRED;
pub const DBPROP_CANFETCHBACKWARDS = DBPROPENUM.DBPROP_CANFETCHBACKWARDS;
pub const DBPROP_CANHOLDROWS = DBPROPENUM.DBPROP_CANHOLDROWS;
pub const DBPROP_CANSCROLLBACKWARDS = DBPROPENUM.DBPROP_CANSCROLLBACKWARDS;
pub const DBPROP_CATALOGLOCATION = DBPROPENUM.DBPROP_CATALOGLOCATION;
pub const DBPROP_CATALOGTERM = DBPROPENUM.DBPROP_CATALOGTERM;
pub const DBPROP_CATALOGUSAGE = DBPROPENUM.DBPROP_CATALOGUSAGE;
pub const DBPROP_CHANGEINSERTEDROWS = DBPROPENUM.DBPROP_CHANGEINSERTEDROWS;
pub const DBPROP_COL_AUTOINCREMENT = DBPROPENUM.DBPROP_COL_AUTOINCREMENT;
pub const DBPROP_COL_DEFAULT = DBPROPENUM.DBPROP_COL_DEFAULT;
pub const DBPROP_COL_DESCRIPTION = DBPROPENUM.DBPROP_COL_DESCRIPTION;
pub const DBPROP_COL_FIXEDLENGTH = DBPROPENUM.DBPROP_COL_FIXEDLENGTH;
pub const DBPROP_COL_NULLABLE = DBPROPENUM.DBPROP_COL_NULLABLE;
pub const DBPROP_COL_PRIMARYKEY = DBPROPENUM.DBPROP_COL_PRIMARYKEY;
pub const DBPROP_COL_UNIQUE = DBPROPENUM.DBPROP_COL_UNIQUE;
pub const DBPROP_COLUMNDEFINITION = DBPROPENUM.DBPROP_COLUMNDEFINITION;
pub const DBPROP_COLUMNRESTRICT = DBPROPENUM.DBPROP_COLUMNRESTRICT;
pub const DBPROP_COMMANDTIMEOUT = DBPROPENUM.DBPROP_COMMANDTIMEOUT;
pub const DBPROP_COMMITPRESERVE = DBPROPENUM.DBPROP_COMMITPRESERVE;
pub const DBPROP_CONCATNULLBEHAVIOR = DBPROPENUM.DBPROP_CONCATNULLBEHAVIOR;
pub const DBPROP_CURRENTCATALOG = DBPROPENUM.DBPROP_CURRENTCATALOG;
pub const DBPROP_DATASOURCENAME = DBPROPENUM.DBPROP_DATASOURCENAME;
pub const DBPROP_DATASOURCEREADONLY = DBPROPENUM.DBPROP_DATASOURCEREADONLY;
pub const DBPROP_DBMSNAME = DBPROPENUM.DBPROP_DBMSNAME;
pub const DBPROP_DBMSVER = DBPROPENUM.DBPROP_DBMSVER;
pub const DBPROP_DEFERRED = DBPROPENUM.DBPROP_DEFERRED;
pub const DBPROP_DELAYSTORAGEOBJECTS = DBPROPENUM.DBPROP_DELAYSTORAGEOBJECTS;
pub const DBPROP_DSOTHREADMODEL = DBPROPENUM.DBPROP_DSOTHREADMODEL;
pub const DBPROP_GROUPBY = DBPROPENUM.DBPROP_GROUPBY;
pub const DBPROP_HETEROGENEOUSTABLES = DBPROPENUM.DBPROP_HETEROGENEOUSTABLES;
pub const DBPROP_IAccessor = DBPROPENUM.DBPROP_IAccessor;
pub const DBPROP_IColumnsInfo = DBPROPENUM.DBPROP_IColumnsInfo;
pub const DBPROP_IColumnsRowset = DBPROPENUM.DBPROP_IColumnsRowset;
pub const DBPROP_IConnectionPointContainer = DBPROPENUM.DBPROP_IConnectionPointContainer;
pub const DBPROP_IConvertType = DBPROPENUM.DBPROP_IConvertType;
pub const DBPROP_IRowset = DBPROPENUM.DBPROP_IRowset;
pub const DBPROP_IRowsetChange = DBPROPENUM.DBPROP_IRowsetChange;
pub const DBPROP_IRowsetIdentity = DBPROPENUM.DBPROP_IRowsetIdentity;
pub const DBPROP_IRowsetIndex = DBPROPENUM.DBPROP_IRowsetIndex;
pub const DBPROP_IRowsetInfo = DBPROPENUM.DBPROP_IRowsetInfo;
pub const DBPROP_IRowsetLocate = DBPROPENUM.DBPROP_IRowsetLocate;
pub const DBPROP_IRowsetResynch = DBPROPENUM.DBPROP_IRowsetResynch;
pub const DBPROP_IRowsetScroll = DBPROPENUM.DBPROP_IRowsetScroll;
pub const DBPROP_IRowsetUpdate = DBPROPENUM.DBPROP_IRowsetUpdate;
pub const DBPROP_ISupportErrorInfo = DBPROPENUM.DBPROP_ISupportErrorInfo;
pub const DBPROP_ILockBytes = DBPROPENUM.DBPROP_ILockBytes;
pub const DBPROP_ISequentialStream = DBPROPENUM.DBPROP_ISequentialStream;
pub const DBPROP_IStorage = DBPROPENUM.DBPROP_IStorage;
pub const DBPROP_IStream = DBPROPENUM.DBPROP_IStream;
pub const DBPROP_IDENTIFIERCASE = DBPROPENUM.DBPROP_IDENTIFIERCASE;
pub const DBPROP_IMMOBILEROWS = DBPROPENUM.DBPROP_IMMOBILEROWS;
pub const DBPROP_INDEX_AUTOUPDATE = DBPROPENUM.DBPROP_INDEX_AUTOUPDATE;
pub const DBPROP_INDEX_CLUSTERED = DBPROPENUM.DBPROP_INDEX_CLUSTERED;
pub const DBPROP_INDEX_FILLFACTOR = DBPROPENUM.DBPROP_INDEX_FILLFACTOR;
pub const DBPROP_INDEX_INITIALSIZE = DBPROPENUM.DBPROP_INDEX_INITIALSIZE;
pub const DBPROP_INDEX_NULLCOLLATION = DBPROPENUM.DBPROP_INDEX_NULLCOLLATION;
pub const DBPROP_INDEX_NULLS = DBPROPENUM.DBPROP_INDEX_NULLS;
pub const DBPROP_INDEX_PRIMARYKEY = DBPROPENUM.DBPROP_INDEX_PRIMARYKEY;
pub const DBPROP_INDEX_SORTBOOKMARKS = DBPROPENUM.DBPROP_INDEX_SORTBOOKMARKS;
pub const DBPROP_INDEX_TEMPINDEX = DBPROPENUM.DBPROP_INDEX_TEMPINDEX;
pub const DBPROP_INDEX_TYPE = DBPROPENUM.DBPROP_INDEX_TYPE;
pub const DBPROP_INDEX_UNIQUE = DBPROPENUM.DBPROP_INDEX_UNIQUE;
pub const DBPROP_INIT_DATASOURCE = DBPROPENUM.DBPROP_INIT_DATASOURCE;
pub const DBPROP_INIT_HWND = DBPROPENUM.DBPROP_INIT_HWND;
pub const DBPROP_INIT_IMPERSONATION_LEVEL = DBPROPENUM.DBPROP_INIT_IMPERSONATION_LEVEL;
pub const DBPROP_INIT_LCID = DBPROPENUM.DBPROP_INIT_LCID;
pub const DBPROP_INIT_LOCATION = DBPROPENUM.DBPROP_INIT_LOCATION;
pub const DBPROP_INIT_MODE = DBPROPENUM.DBPROP_INIT_MODE;
pub const DBPROP_INIT_PROMPT = DBPROPENUM.DBPROP_INIT_PROMPT;
pub const DBPROP_INIT_PROTECTION_LEVEL = DBPROPENUM.DBPROP_INIT_PROTECTION_LEVEL;
pub const DBPROP_INIT_PROVIDERSTRING = DBPROPENUM.DBPROP_INIT_PROVIDERSTRING;
pub const DBPROP_INIT_TIMEOUT = DBPROPENUM.DBPROP_INIT_TIMEOUT;
pub const DBPROP_LITERALBOOKMARKS = DBPROPENUM.DBPROP_LITERALBOOKMARKS;
pub const DBPROP_LITERALIDENTITY = DBPROPENUM.DBPROP_LITERALIDENTITY;
pub const DBPROP_MAXINDEXSIZE = DBPROPENUM.DBPROP_MAXINDEXSIZE;
pub const DBPROP_MAXOPENROWS = DBPROPENUM.DBPROP_MAXOPENROWS;
pub const DBPROP_MAXPENDINGROWS = DBPROPENUM.DBPROP_MAXPENDINGROWS;
pub const DBPROP_MAXROWS = DBPROPENUM.DBPROP_MAXROWS;
pub const DBPROP_MAXROWSIZE = DBPROPENUM.DBPROP_MAXROWSIZE;
pub const DBPROP_MAXROWSIZEINCLUDESBLOB = DBPROPENUM.DBPROP_MAXROWSIZEINCLUDESBLOB;
pub const DBPROP_MAXTABLESINSELECT = DBPROPENUM.DBPROP_MAXTABLESINSELECT;
pub const DBPROP_MAYWRITECOLUMN = DBPROPENUM.DBPROP_MAYWRITECOLUMN;
pub const DBPROP_MEMORYUSAGE = DBPROPENUM.DBPROP_MEMORYUSAGE;
pub const DBPROP_MULTIPLEPARAMSETS = DBPROPENUM.DBPROP_MULTIPLEPARAMSETS;
pub const DBPROP_MULTIPLERESULTS = DBPROPENUM.DBPROP_MULTIPLERESULTS;
pub const DBPROP_MULTIPLESTORAGEOBJECTS = DBPROPENUM.DBPROP_MULTIPLESTORAGEOBJECTS;
pub const DBPROP_MULTITABLEUPDATE = DBPROPENUM.DBPROP_MULTITABLEUPDATE;
pub const DBPROP_NOTIFICATIONGRANULARITY = DBPROPENUM.DBPROP_NOTIFICATIONGRANULARITY;
pub const DBPROP_NOTIFICATIONPHASES = DBPROPENUM.DBPROP_NOTIFICATIONPHASES;
pub const DBPROP_NOTIFYCOLUMNSET = DBPROPENUM.DBPROP_NOTIFYCOLUMNSET;
pub const DBPROP_NOTIFYROWDELETE = DBPROPENUM.DBPROP_NOTIFYROWDELETE;
pub const DBPROP_NOTIFYROWFIRSTCHANGE = DBPROPENUM.DBPROP_NOTIFYROWFIRSTCHANGE;
pub const DBPROP_NOTIFYROWINSERT = DBPROPENUM.DBPROP_NOTIFYROWINSERT;
pub const DBPROP_NOTIFYROWRESYNCH = DBPROPENUM.DBPROP_NOTIFYROWRESYNCH;
pub const DBPROP_NOTIFYROWSETCHANGED = DBPROPENUM.DBPROP_NOTIFYROWSETCHANGED;
pub const DBPROP_NOTIFYROWSETRELEASE = DBPROPENUM.DBPROP_NOTIFYROWSETRELEASE;
pub const DBPROP_NOTIFYROWSETFETCHPOSITIONCHANGE = DBPROPENUM.DBPROP_NOTIFYROWSETFETCHPOSITIONCHANGE;
pub const DBPROP_NOTIFYROWUNDOCHANGE = DBPROPENUM.DBPROP_NOTIFYROWUNDOCHANGE;
pub const DBPROP_NOTIFYROWUNDODELETE = DBPROPENUM.DBPROP_NOTIFYROWUNDODELETE;
pub const DBPROP_NOTIFYROWUNDOINSERT = DBPROPENUM.DBPROP_NOTIFYROWUNDOINSERT;
pub const DBPROP_NOTIFYROWUPDATE = DBPROPENUM.DBPROP_NOTIFYROWUPDATE;
pub const DBPROP_NULLCOLLATION = DBPROPENUM.DBPROP_NULLCOLLATION;
pub const DBPROP_OLEOBJECTS = DBPROPENUM.DBPROP_OLEOBJECTS;
pub const DBPROP_ORDERBYCOLUMNSINSELECT = DBPROPENUM.DBPROP_ORDERBYCOLUMNSINSELECT;
pub const DBPROP_ORDEREDBOOKMARKS = DBPROPENUM.DBPROP_ORDEREDBOOKMARKS;
pub const DBPROP_OTHERINSERT = DBPROPENUM.DBPROP_OTHERINSERT;
pub const DBPROP_OTHERUPDATEDELETE = DBPROPENUM.DBPROP_OTHERUPDATEDELETE;
pub const DBPROP_OUTPUTPARAMETERAVAILABILITY = DBPROPENUM.DBPROP_OUTPUTPARAMETERAVAILABILITY;
pub const DBPROP_OWNINSERT = DBPROPENUM.DBPROP_OWNINSERT;
pub const DBPROP_OWNUPDATEDELETE = DBPROPENUM.DBPROP_OWNUPDATEDELETE;
pub const DBPROP_PERSISTENTIDTYPE = DBPROPENUM.DBPROP_PERSISTENTIDTYPE;
pub const DBPROP_PREPAREABORTBEHAVIOR = DBPROPENUM.DBPROP_PREPAREABORTBEHAVIOR;
pub const DBPROP_PREPARECOMMITBEHAVIOR = DBPROPENUM.DBPROP_PREPARECOMMITBEHAVIOR;
pub const DBPROP_PROCEDURETERM = DBPROPENUM.DBPROP_PROCEDURETERM;
pub const DBPROP_PROVIDERNAME = DBPROPENUM.DBPROP_PROVIDERNAME;
pub const DBPROP_PROVIDEROLEDBVER = DBPROPENUM.DBPROP_PROVIDEROLEDBVER;
pub const DBPROP_PROVIDERVER = DBPROPENUM.DBPROP_PROVIDERVER;
pub const DBPROP_QUICKRESTART = DBPROPENUM.DBPROP_QUICKRESTART;
pub const DBPROP_QUOTEDIDENTIFIERCASE = DBPROPENUM.DBPROP_QUOTEDIDENTIFIERCASE;
pub const DBPROP_REENTRANTEVENTS = DBPROPENUM.DBPROP_REENTRANTEVENTS;
pub const DBPROP_REMOVEDELETED = DBPROPENUM.DBPROP_REMOVEDELETED;
pub const DBPROP_REPORTMULTIPLECHANGES = DBPROPENUM.DBPROP_REPORTMULTIPLECHANGES;
pub const DBPROP_RETURNPENDINGINSERTS = DBPROPENUM.DBPROP_RETURNPENDINGINSERTS;
pub const DBPROP_ROWRESTRICT = DBPROPENUM.DBPROP_ROWRESTRICT;
pub const DBPROP_ROWSETCONVERSIONSONCOMMAND = DBPROPENUM.DBPROP_ROWSETCONVERSIONSONCOMMAND;
pub const DBPROP_ROWTHREADMODEL = DBPROPENUM.DBPROP_ROWTHREADMODEL;
pub const DBPROP_SCHEMATERM = DBPROPENUM.DBPROP_SCHEMATERM;
pub const DBPROP_SCHEMAUSAGE = DBPROPENUM.DBPROP_SCHEMAUSAGE;
pub const DBPROP_SERVERCURSOR = DBPROPENUM.DBPROP_SERVERCURSOR;
pub const DBPROP_SESS_AUTOCOMMITISOLEVELS = DBPROPENUM.DBPROP_SESS_AUTOCOMMITISOLEVELS;
pub const DBPROP_SQLSUPPORT = DBPROPENUM.DBPROP_SQLSUPPORT;
pub const DBPROP_STRONGIDENTITY = DBPROPENUM.DBPROP_STRONGIDENTITY;
pub const DBPROP_STRUCTUREDSTORAGE = DBPROPENUM.DBPROP_STRUCTUREDSTORAGE;
pub const DBPROP_SUBQUERIES = DBPROPENUM.DBPROP_SUBQUERIES;
pub const DBPROP_SUPPORTEDTXNDDL = DBPROPENUM.DBPROP_SUPPORTEDTXNDDL;
pub const DBPROP_SUPPORTEDTXNISOLEVELS = DBPROPENUM.DBPROP_SUPPORTEDTXNISOLEVELS;
pub const DBPROP_SUPPORTEDTXNISORETAIN = DBPROPENUM.DBPROP_SUPPORTEDTXNISORETAIN;
pub const DBPROP_TABLETERM = DBPROPENUM.DBPROP_TABLETERM;
pub const DBPROP_TBL_TEMPTABLE = DBPROPENUM.DBPROP_TBL_TEMPTABLE;
pub const DBPROP_TRANSACTEDOBJECT = DBPROPENUM.DBPROP_TRANSACTEDOBJECT;
pub const DBPROP_UPDATABILITY = DBPROPENUM.DBPROP_UPDATABILITY;
pub const DBPROP_USERNAME = DBPROPENUM.DBPROP_USERNAME;

pub const DBPROPENUM15 = extern enum(i32) {
    DBPROP_FILTERCOMPAREOPS = 209,
    DBPROP_FINDCOMPAREOPS = 210,
    DBPROP_IChapteredRowset = 202,
    DBPROP_IDBAsynchStatus = 203,
    DBPROP_IRowsetFind = 204,
    DBPROP_IRowsetView = 212,
    DBPROP_IViewChapter = 213,
    DBPROP_IViewFilter = 214,
    DBPROP_IViewRowset = 215,
    DBPROP_IViewSort = 216,
    DBPROP_INIT_ASYNCH = 200,
    DBPROP_MAXOPENCHAPTERS = 199,
    DBPROP_MAXORSINFILTER = 205,
    DBPROP_MAXSORTCOLUMNS = 206,
    DBPROP_ROWSET_ASYNCH = 201,
    DBPROP_SORTONINDEX = 207,
};
pub const DBPROP_FILTERCOMPAREOPS = DBPROPENUM15.DBPROP_FILTERCOMPAREOPS;
pub const DBPROP_FINDCOMPAREOPS = DBPROPENUM15.DBPROP_FINDCOMPAREOPS;
pub const DBPROP_IChapteredRowset = DBPROPENUM15.DBPROP_IChapteredRowset;
pub const DBPROP_IDBAsynchStatus = DBPROPENUM15.DBPROP_IDBAsynchStatus;
pub const DBPROP_IRowsetFind = DBPROPENUM15.DBPROP_IRowsetFind;
pub const DBPROP_IRowsetView = DBPROPENUM15.DBPROP_IRowsetView;
pub const DBPROP_IViewChapter = DBPROPENUM15.DBPROP_IViewChapter;
pub const DBPROP_IViewFilter = DBPROPENUM15.DBPROP_IViewFilter;
pub const DBPROP_IViewRowset = DBPROPENUM15.DBPROP_IViewRowset;
pub const DBPROP_IViewSort = DBPROPENUM15.DBPROP_IViewSort;
pub const DBPROP_INIT_ASYNCH = DBPROPENUM15.DBPROP_INIT_ASYNCH;
pub const DBPROP_MAXOPENCHAPTERS = DBPROPENUM15.DBPROP_MAXOPENCHAPTERS;
pub const DBPROP_MAXORSINFILTER = DBPROPENUM15.DBPROP_MAXORSINFILTER;
pub const DBPROP_MAXSORTCOLUMNS = DBPROPENUM15.DBPROP_MAXSORTCOLUMNS;
pub const DBPROP_ROWSET_ASYNCH = DBPROPENUM15.DBPROP_ROWSET_ASYNCH;
pub const DBPROP_SORTONINDEX = DBPROPENUM15.DBPROP_SORTONINDEX;

pub const DBPROPENUM20 = extern enum(i32) {
    DBPROP_IMultipleResults = 217,
    DBPROP_DATASOURCE_TYPE = 251,
    MDPROP_AXES = 252,
    MDPROP_FLATTENING_SUPPORT = 253,
    MDPROP_MDX_JOINCUBES = 254,
    MDPROP_NAMED_LEVELS = 255,
    MDPROP_RANGEROWSET = 256,
    MDPROP_MDX_SLICER = 218,
    MDPROP_MDX_CUBEQUALIFICATION = 219,
    MDPROP_MDX_OUTERREFERENCE = 220,
    MDPROP_MDX_QUERYBYPROPERTY = 221,
    MDPROP_MDX_CASESUPPORT = 222,
    MDPROP_MDX_STRING_COMPOP = 224,
    MDPROP_MDX_DESCFLAGS = 225,
    MDPROP_MDX_SET_FUNCTIONS = 226,
    MDPROP_MDX_MEMBER_FUNCTIONS = 227,
    MDPROP_MDX_NUMERIC_FUNCTIONS = 228,
    MDPROP_MDX_FORMULAS = 229,
    MDPROP_AGGREGATECELL_UPDATE = 230,
    MDPROP_MDX_AGGREGATECELL_UPDATE = 230,
    MDPROP_MDX_OBJQUALIFICATION = 261,
    MDPROP_MDX_NONMEASURE_EXPRESSIONS = 262,
    DBPROP_ACCESSORDER = 231,
    DBPROP_BOOKMARKINFO = 232,
    DBPROP_INIT_CATALOG = 233,
    DBPROP_ROW_BULKOPS = 234,
    DBPROP_PROVIDERFRIENDLYNAME = 235,
    DBPROP_LOCKMODE = 236,
    DBPROP_MULTIPLECONNECTIONS = 237,
    DBPROP_UNIQUEROWS = 238,
    DBPROP_SERVERDATAONINSERT = 239,
    DBPROP_STORAGEFLAGS = 240,
    DBPROP_CONNECTIONSTATUS = 244,
    DBPROP_ALTERCOLUMN = 245,
    DBPROP_COLUMNLCID = 246,
    DBPROP_RESETDATASOURCE = 247,
    DBPROP_INIT_OLEDBSERVICES = 248,
    DBPROP_IRowsetRefresh = 249,
    DBPROP_SERVERNAME = 250,
    DBPROP_IParentRowset = 257,
    DBPROP_HIDDENCOLUMNS = 258,
    DBPROP_PROVIDERMEMORY = 259,
    DBPROP_CLIENTCURSOR = 260,
};
pub const DBPROP_IMultipleResults = DBPROPENUM20.DBPROP_IMultipleResults;
pub const DBPROP_DATASOURCE_TYPE = DBPROPENUM20.DBPROP_DATASOURCE_TYPE;
pub const MDPROP_AXES = DBPROPENUM20.MDPROP_AXES;
pub const MDPROP_FLATTENING_SUPPORT = DBPROPENUM20.MDPROP_FLATTENING_SUPPORT;
pub const MDPROP_MDX_JOINCUBES = DBPROPENUM20.MDPROP_MDX_JOINCUBES;
pub const MDPROP_NAMED_LEVELS = DBPROPENUM20.MDPROP_NAMED_LEVELS;
pub const MDPROP_RANGEROWSET = DBPROPENUM20.MDPROP_RANGEROWSET;
pub const MDPROP_MDX_SLICER = DBPROPENUM20.MDPROP_MDX_SLICER;
pub const MDPROP_MDX_CUBEQUALIFICATION = DBPROPENUM20.MDPROP_MDX_CUBEQUALIFICATION;
pub const MDPROP_MDX_OUTERREFERENCE = DBPROPENUM20.MDPROP_MDX_OUTERREFERENCE;
pub const MDPROP_MDX_QUERYBYPROPERTY = DBPROPENUM20.MDPROP_MDX_QUERYBYPROPERTY;
pub const MDPROP_MDX_CASESUPPORT = DBPROPENUM20.MDPROP_MDX_CASESUPPORT;
pub const MDPROP_MDX_STRING_COMPOP = DBPROPENUM20.MDPROP_MDX_STRING_COMPOP;
pub const MDPROP_MDX_DESCFLAGS = DBPROPENUM20.MDPROP_MDX_DESCFLAGS;
pub const MDPROP_MDX_SET_FUNCTIONS = DBPROPENUM20.MDPROP_MDX_SET_FUNCTIONS;
pub const MDPROP_MDX_MEMBER_FUNCTIONS = DBPROPENUM20.MDPROP_MDX_MEMBER_FUNCTIONS;
pub const MDPROP_MDX_NUMERIC_FUNCTIONS = DBPROPENUM20.MDPROP_MDX_NUMERIC_FUNCTIONS;
pub const MDPROP_MDX_FORMULAS = DBPROPENUM20.MDPROP_MDX_FORMULAS;
pub const MDPROP_AGGREGATECELL_UPDATE = DBPROPENUM20.MDPROP_AGGREGATECELL_UPDATE;
pub const MDPROP_MDX_AGGREGATECELL_UPDATE = DBPROPENUM20.MDPROP_MDX_AGGREGATECELL_UPDATE;
pub const MDPROP_MDX_OBJQUALIFICATION = DBPROPENUM20.MDPROP_MDX_OBJQUALIFICATION;
pub const MDPROP_MDX_NONMEASURE_EXPRESSIONS = DBPROPENUM20.MDPROP_MDX_NONMEASURE_EXPRESSIONS;
pub const DBPROP_ACCESSORDER = DBPROPENUM20.DBPROP_ACCESSORDER;
pub const DBPROP_BOOKMARKINFO = DBPROPENUM20.DBPROP_BOOKMARKINFO;
pub const DBPROP_INIT_CATALOG = DBPROPENUM20.DBPROP_INIT_CATALOG;
pub const DBPROP_ROW_BULKOPS = DBPROPENUM20.DBPROP_ROW_BULKOPS;
pub const DBPROP_PROVIDERFRIENDLYNAME = DBPROPENUM20.DBPROP_PROVIDERFRIENDLYNAME;
pub const DBPROP_LOCKMODE = DBPROPENUM20.DBPROP_LOCKMODE;
pub const DBPROP_MULTIPLECONNECTIONS = DBPROPENUM20.DBPROP_MULTIPLECONNECTIONS;
pub const DBPROP_UNIQUEROWS = DBPROPENUM20.DBPROP_UNIQUEROWS;
pub const DBPROP_SERVERDATAONINSERT = DBPROPENUM20.DBPROP_SERVERDATAONINSERT;
pub const DBPROP_STORAGEFLAGS = DBPROPENUM20.DBPROP_STORAGEFLAGS;
pub const DBPROP_CONNECTIONSTATUS = DBPROPENUM20.DBPROP_CONNECTIONSTATUS;
pub const DBPROP_ALTERCOLUMN = DBPROPENUM20.DBPROP_ALTERCOLUMN;
pub const DBPROP_COLUMNLCID = DBPROPENUM20.DBPROP_COLUMNLCID;
pub const DBPROP_RESETDATASOURCE = DBPROPENUM20.DBPROP_RESETDATASOURCE;
pub const DBPROP_INIT_OLEDBSERVICES = DBPROPENUM20.DBPROP_INIT_OLEDBSERVICES;
pub const DBPROP_IRowsetRefresh = DBPROPENUM20.DBPROP_IRowsetRefresh;
pub const DBPROP_SERVERNAME = DBPROPENUM20.DBPROP_SERVERNAME;
pub const DBPROP_IParentRowset = DBPROPENUM20.DBPROP_IParentRowset;
pub const DBPROP_HIDDENCOLUMNS = DBPROPENUM20.DBPROP_HIDDENCOLUMNS;
pub const DBPROP_PROVIDERMEMORY = DBPROPENUM20.DBPROP_PROVIDERMEMORY;
pub const DBPROP_CLIENTCURSOR = DBPROPENUM20.DBPROP_CLIENTCURSOR;

pub const DBPROPENUM21 = extern enum(i32) {
    DBPROP_TRUSTEE_USERNAME = 241,
    DBPROP_TRUSTEE_AUTHENTICATION = 242,
    DBPROP_TRUSTEE_NEWAUTHENTICATION = 243,
    DBPROP_IRow = 263,
    DBPROP_IRowChange = 264,
    DBPROP_IRowSchemaChange = 265,
    DBPROP_IGetRow = 266,
    DBPROP_IScopedOperations = 267,
    DBPROP_IBindResource = 268,
    DBPROP_ICreateRow = 269,
    DBPROP_INIT_BINDFLAGS = 270,
    DBPROP_INIT_LOCKOWNER = 271,
    DBPROP_GENERATEURL = 273,
    DBPROP_IDBBinderProperties = 274,
    DBPROP_IColumnsInfo2 = 275,
    DBPROP_IRegisterProvider = 276,
    DBPROP_IGetSession = 277,
    DBPROP_IGetSourceRow = 278,
    DBPROP_IRowsetCurrentIndex = 279,
    DBPROP_OPENROWSETSUPPORT = 280,
    DBPROP_COL_ISLONG = 281,
};
pub const DBPROP_TRUSTEE_USERNAME = DBPROPENUM21.DBPROP_TRUSTEE_USERNAME;
pub const DBPROP_TRUSTEE_AUTHENTICATION = DBPROPENUM21.DBPROP_TRUSTEE_AUTHENTICATION;
pub const DBPROP_TRUSTEE_NEWAUTHENTICATION = DBPROPENUM21.DBPROP_TRUSTEE_NEWAUTHENTICATION;
pub const DBPROP_IRow = DBPROPENUM21.DBPROP_IRow;
pub const DBPROP_IRowChange = DBPROPENUM21.DBPROP_IRowChange;
pub const DBPROP_IRowSchemaChange = DBPROPENUM21.DBPROP_IRowSchemaChange;
pub const DBPROP_IGetRow = DBPROPENUM21.DBPROP_IGetRow;
pub const DBPROP_IScopedOperations = DBPROPENUM21.DBPROP_IScopedOperations;
pub const DBPROP_IBindResource = DBPROPENUM21.DBPROP_IBindResource;
pub const DBPROP_ICreateRow = DBPROPENUM21.DBPROP_ICreateRow;
pub const DBPROP_INIT_BINDFLAGS = DBPROPENUM21.DBPROP_INIT_BINDFLAGS;
pub const DBPROP_INIT_LOCKOWNER = DBPROPENUM21.DBPROP_INIT_LOCKOWNER;
pub const DBPROP_GENERATEURL = DBPROPENUM21.DBPROP_GENERATEURL;
pub const DBPROP_IDBBinderProperties = DBPROPENUM21.DBPROP_IDBBinderProperties;
pub const DBPROP_IColumnsInfo2 = DBPROPENUM21.DBPROP_IColumnsInfo2;
pub const DBPROP_IRegisterProvider = DBPROPENUM21.DBPROP_IRegisterProvider;
pub const DBPROP_IGetSession = DBPROPENUM21.DBPROP_IGetSession;
pub const DBPROP_IGetSourceRow = DBPROPENUM21.DBPROP_IGetSourceRow;
pub const DBPROP_IRowsetCurrentIndex = DBPROPENUM21.DBPROP_IRowsetCurrentIndex;
pub const DBPROP_OPENROWSETSUPPORT = DBPROPENUM21.DBPROP_OPENROWSETSUPPORT;
pub const DBPROP_COL_ISLONG = DBPROPENUM21.DBPROP_COL_ISLONG;

pub const DBPROPENUM25 = extern enum(i32) {
    DBPROP_COL_SEED = 282,
    DBPROP_COL_INCREMENT = 283,
    DBPROP_INIT_GENERALTIMEOUT = 284,
    DBPROP_COMSERVICES = 285,
};
pub const DBPROP_COL_SEED = DBPROPENUM25.DBPROP_COL_SEED;
pub const DBPROP_COL_INCREMENT = DBPROPENUM25.DBPROP_COL_INCREMENT;
pub const DBPROP_INIT_GENERALTIMEOUT = DBPROPENUM25.DBPROP_INIT_GENERALTIMEOUT;
pub const DBPROP_COMSERVICES = DBPROPENUM25.DBPROP_COMSERVICES;

pub const DBPROPENUM26 = extern enum(i32) {
    DBPROP_OUTPUTSTREAM = 286,
    DBPROP_OUTPUTENCODING = 287,
    DBPROP_TABLESTATISTICS = 288,
    DBPROP_SKIPROWCOUNTRESULTS = 291,
    DBPROP_IRowsetBookmark = 292,
    MDPROP_VISUALMODE = 293,
};
pub const DBPROP_OUTPUTSTREAM = DBPROPENUM26.DBPROP_OUTPUTSTREAM;
pub const DBPROP_OUTPUTENCODING = DBPROPENUM26.DBPROP_OUTPUTENCODING;
pub const DBPROP_TABLESTATISTICS = DBPROPENUM26.DBPROP_TABLESTATISTICS;
pub const DBPROP_SKIPROWCOUNTRESULTS = DBPROPENUM26.DBPROP_SKIPROWCOUNTRESULTS;
pub const DBPROP_IRowsetBookmark = DBPROPENUM26.DBPROP_IRowsetBookmark;
pub const MDPROP_VISUALMODE = DBPROPENUM26.MDPROP_VISUALMODE;

pub const DBPARAMS = extern struct {
    pData: *c_void,
    cParamSets: u32,
    hAccessor: ?*c_void,
};

pub const DBPARAMFLAGSENUM = extern enum(i32) {
    DBPARAMFLAGS_ISINPUT = 1,
    DBPARAMFLAGS_ISOUTPUT = 2,
    DBPARAMFLAGS_ISSIGNED = 16,
    DBPARAMFLAGS_ISNULLABLE = 64,
    DBPARAMFLAGS_ISLONG = 128,
};
pub const DBPARAMFLAGS_ISINPUT = DBPARAMFLAGSENUM.DBPARAMFLAGS_ISINPUT;
pub const DBPARAMFLAGS_ISOUTPUT = DBPARAMFLAGSENUM.DBPARAMFLAGS_ISOUTPUT;
pub const DBPARAMFLAGS_ISSIGNED = DBPARAMFLAGSENUM.DBPARAMFLAGS_ISSIGNED;
pub const DBPARAMFLAGS_ISNULLABLE = DBPARAMFLAGSENUM.DBPARAMFLAGS_ISNULLABLE;
pub const DBPARAMFLAGS_ISLONG = DBPARAMFLAGSENUM.DBPARAMFLAGS_ISLONG;

pub const DBPARAMFLAGSENUM20 = extern enum(i32) {
    DBPARAMFLAGS_SCALEISNEGATIVE = 256,
};
pub const DBPARAMFLAGS_SCALEISNEGATIVE = DBPARAMFLAGSENUM20.DBPARAMFLAGS_SCALEISNEGATIVE;

pub const DBPARAMINFO = extern struct {
    dwFlags: u32,
    iOrdinal: u32,
    pwszName: PWSTR,
    pTypeInfo: *ITypeInfo,
    ulParamSize: u32,
    wType: u16,
    bPrecision: u8,
    bScale: u8,
};

pub const DBPROPIDSET = extern struct {
    rgPropertyIDs: *u32,
    cPropertyIDs: u32,
    guidPropertySet: Guid,
};

pub const DBPROPFLAGSENUM = extern enum(i32) {
    DBPROPFLAGS_NOTSUPPORTED = 0,
    DBPROPFLAGS_COLUMN = 1,
    DBPROPFLAGS_DATASOURCE = 2,
    DBPROPFLAGS_DATASOURCECREATE = 4,
    DBPROPFLAGS_DATASOURCEINFO = 8,
    DBPROPFLAGS_DBINIT = 16,
    DBPROPFLAGS_INDEX = 32,
    DBPROPFLAGS_ROWSET = 64,
    DBPROPFLAGS_TABLE = 128,
    DBPROPFLAGS_COLUMNOK = 256,
    DBPROPFLAGS_READ = 512,
    DBPROPFLAGS_WRITE = 1024,
    DBPROPFLAGS_REQUIRED = 2048,
    DBPROPFLAGS_SESSION = 4096,
};
pub const DBPROPFLAGS_NOTSUPPORTED = DBPROPFLAGSENUM.DBPROPFLAGS_NOTSUPPORTED;
pub const DBPROPFLAGS_COLUMN = DBPROPFLAGSENUM.DBPROPFLAGS_COLUMN;
pub const DBPROPFLAGS_DATASOURCE = DBPROPFLAGSENUM.DBPROPFLAGS_DATASOURCE;
pub const DBPROPFLAGS_DATASOURCECREATE = DBPROPFLAGSENUM.DBPROPFLAGS_DATASOURCECREATE;
pub const DBPROPFLAGS_DATASOURCEINFO = DBPROPFLAGSENUM.DBPROPFLAGS_DATASOURCEINFO;
pub const DBPROPFLAGS_DBINIT = DBPROPFLAGSENUM.DBPROPFLAGS_DBINIT;
pub const DBPROPFLAGS_INDEX = DBPROPFLAGSENUM.DBPROPFLAGS_INDEX;
pub const DBPROPFLAGS_ROWSET = DBPROPFLAGSENUM.DBPROPFLAGS_ROWSET;
pub const DBPROPFLAGS_TABLE = DBPROPFLAGSENUM.DBPROPFLAGS_TABLE;
pub const DBPROPFLAGS_COLUMNOK = DBPROPFLAGSENUM.DBPROPFLAGS_COLUMNOK;
pub const DBPROPFLAGS_READ = DBPROPFLAGSENUM.DBPROPFLAGS_READ;
pub const DBPROPFLAGS_WRITE = DBPROPFLAGSENUM.DBPROPFLAGS_WRITE;
pub const DBPROPFLAGS_REQUIRED = DBPROPFLAGSENUM.DBPROPFLAGS_REQUIRED;
pub const DBPROPFLAGS_SESSION = DBPROPFLAGSENUM.DBPROPFLAGS_SESSION;

pub const DBPROPFLAGSENUM21 = extern enum(i32) {
    DBPROPFLAGS_TRUSTEE = 8192,
};
pub const DBPROPFLAGS_TRUSTEE = DBPROPFLAGSENUM21.DBPROPFLAGS_TRUSTEE;

pub const DBPROPFLAGSENUM25 = extern enum(i32) {
    DBPROPFLAGS_VIEW = 16384,
};
pub const DBPROPFLAGS_VIEW = DBPROPFLAGSENUM25.DBPROPFLAGS_VIEW;

pub const DBPROPFLAGSENUM26 = extern enum(i32) {
    DBPROPFLAGS_STREAM = 32768,
};
pub const DBPROPFLAGS_STREAM = DBPROPFLAGSENUM26.DBPROPFLAGS_STREAM;

pub const DBPROPINFO = extern struct {
    pwszDescription: PWSTR,
    dwPropertyID: u32,
    dwFlags: u32,
    vtType: u16,
    vValues: VARIANT,
};

pub const DBPROPINFOSET = extern struct {
    rgPropertyInfos: *DBPROPINFO,
    cPropertyInfos: u32,
    guidPropertySet: Guid,
};

pub const DBPROPOPTIONSENUM = extern enum(i32) {
    DBPROPOPTIONS_REQUIRED = 0,
    DBPROPOPTIONS_SETIFCHEAP = 1,
    DBPROPOPTIONS_OPTIONAL = 1,
};
pub const DBPROPOPTIONS_REQUIRED = DBPROPOPTIONSENUM.DBPROPOPTIONS_REQUIRED;
pub const DBPROPOPTIONS_SETIFCHEAP = DBPROPOPTIONSENUM.DBPROPOPTIONS_SETIFCHEAP;
pub const DBPROPOPTIONS_OPTIONAL = DBPROPOPTIONSENUM.DBPROPOPTIONS_OPTIONAL;

pub const DBPROPSTATUSENUM = extern enum(i32) {
    DBPROPSTATUS_OK = 0,
    DBPROPSTATUS_NOTSUPPORTED = 1,
    DBPROPSTATUS_BADVALUE = 2,
    DBPROPSTATUS_BADOPTION = 3,
    DBPROPSTATUS_BADCOLUMN = 4,
    DBPROPSTATUS_NOTALLSETTABLE = 5,
    DBPROPSTATUS_NOTSETTABLE = 6,
    DBPROPSTATUS_NOTSET = 7,
    DBPROPSTATUS_CONFLICTING = 8,
};
pub const DBPROPSTATUS_OK = DBPROPSTATUSENUM.DBPROPSTATUS_OK;
pub const DBPROPSTATUS_NOTSUPPORTED = DBPROPSTATUSENUM.DBPROPSTATUS_NOTSUPPORTED;
pub const DBPROPSTATUS_BADVALUE = DBPROPSTATUSENUM.DBPROPSTATUS_BADVALUE;
pub const DBPROPSTATUS_BADOPTION = DBPROPSTATUSENUM.DBPROPSTATUS_BADOPTION;
pub const DBPROPSTATUS_BADCOLUMN = DBPROPSTATUSENUM.DBPROPSTATUS_BADCOLUMN;
pub const DBPROPSTATUS_NOTALLSETTABLE = DBPROPSTATUSENUM.DBPROPSTATUS_NOTALLSETTABLE;
pub const DBPROPSTATUS_NOTSETTABLE = DBPROPSTATUSENUM.DBPROPSTATUS_NOTSETTABLE;
pub const DBPROPSTATUS_NOTSET = DBPROPSTATUSENUM.DBPROPSTATUS_NOTSET;
pub const DBPROPSTATUS_CONFLICTING = DBPROPSTATUSENUM.DBPROPSTATUS_CONFLICTING;

pub const DBPROPSTATUSENUM21 = extern enum(i32) {
    DBPROPSTATUS_NOTAVAILABLE = 9,
};
pub const DBPROPSTATUS_NOTAVAILABLE = DBPROPSTATUSENUM21.DBPROPSTATUS_NOTAVAILABLE;

pub const DBPROP = extern struct {
    dwPropertyID: u32,
    dwOptions: u32,
    dwStatus: u32,
    colid: DBID,
    vValue: VARIANT,
};

pub const DBPROPSET = extern struct {
    rgProperties: *DBPROP,
    cProperties: u32,
    guidPropertySet: Guid,
};

pub const DBINDEX_COL_ORDERENUM = extern enum(i32) {
    DBINDEX_COL_ORDER_ASC = 0,
    DBINDEX_COL_ORDER_DESC = 1,
};
pub const DBINDEX_COL_ORDER_ASC = DBINDEX_COL_ORDERENUM.DBINDEX_COL_ORDER_ASC;
pub const DBINDEX_COL_ORDER_DESC = DBINDEX_COL_ORDERENUM.DBINDEX_COL_ORDER_DESC;

pub const DBINDEXCOLUMNDESC = extern struct {
    pColumnID: *DBID,
    eIndexColOrder: u32,
};

pub const DBCOLUMNDESC = extern struct {
    pwszTypeName: PWSTR,
    pTypeInfo: *ITypeInfo,
    rgPropertySets: *DBPROPSET,
    pclsid: *Guid,
    cPropertySets: u32,
    ulColumnSize: u32,
    dbcid: DBID,
    wType: u16,
    bPrecision: u8,
    bScale: u8,
};

pub const DBCOLUMNACCESS = extern struct {
    pData: *c_void,
    columnid: DBID,
    cbDataLen: u32,
    dwStatus: u32,
    cbMaxLen: u32,
    dwReserved: u32,
    wType: u16,
    bPrecision: u8,
    bScale: u8,
};

pub const DBCOLUMNDESCFLAGSENUM = extern enum(i32) {
    DBCOLUMNDESCFLAGS_TYPENAME = 1,
    DBCOLUMNDESCFLAGS_ITYPEINFO = 2,
    DBCOLUMNDESCFLAGS_PROPERTIES = 4,
    DBCOLUMNDESCFLAGS_CLSID = 8,
    DBCOLUMNDESCFLAGS_COLSIZE = 16,
    DBCOLUMNDESCFLAGS_DBCID = 32,
    DBCOLUMNDESCFLAGS_WTYPE = 64,
    DBCOLUMNDESCFLAGS_PRECISION = 128,
    DBCOLUMNDESCFLAGS_SCALE = 256,
};
pub const DBCOLUMNDESCFLAGS_TYPENAME = DBCOLUMNDESCFLAGSENUM.DBCOLUMNDESCFLAGS_TYPENAME;
pub const DBCOLUMNDESCFLAGS_ITYPEINFO = DBCOLUMNDESCFLAGSENUM.DBCOLUMNDESCFLAGS_ITYPEINFO;
pub const DBCOLUMNDESCFLAGS_PROPERTIES = DBCOLUMNDESCFLAGSENUM.DBCOLUMNDESCFLAGS_PROPERTIES;
pub const DBCOLUMNDESCFLAGS_CLSID = DBCOLUMNDESCFLAGSENUM.DBCOLUMNDESCFLAGS_CLSID;
pub const DBCOLUMNDESCFLAGS_COLSIZE = DBCOLUMNDESCFLAGSENUM.DBCOLUMNDESCFLAGS_COLSIZE;
pub const DBCOLUMNDESCFLAGS_DBCID = DBCOLUMNDESCFLAGSENUM.DBCOLUMNDESCFLAGS_DBCID;
pub const DBCOLUMNDESCFLAGS_WTYPE = DBCOLUMNDESCFLAGSENUM.DBCOLUMNDESCFLAGS_WTYPE;
pub const DBCOLUMNDESCFLAGS_PRECISION = DBCOLUMNDESCFLAGSENUM.DBCOLUMNDESCFLAGS_PRECISION;
pub const DBCOLUMNDESCFLAGS_SCALE = DBCOLUMNDESCFLAGSENUM.DBCOLUMNDESCFLAGS_SCALE;

pub const DBEVENTPHASEENUM = extern enum(i32) {
    DBEVENTPHASE_OKTODO = 0,
    DBEVENTPHASE_ABOUTTODO = 1,
    DBEVENTPHASE_SYNCHAFTER = 2,
    DBEVENTPHASE_FAILEDTODO = 3,
    DBEVENTPHASE_DIDEVENT = 4,
};
pub const DBEVENTPHASE_OKTODO = DBEVENTPHASEENUM.DBEVENTPHASE_OKTODO;
pub const DBEVENTPHASE_ABOUTTODO = DBEVENTPHASEENUM.DBEVENTPHASE_ABOUTTODO;
pub const DBEVENTPHASE_SYNCHAFTER = DBEVENTPHASEENUM.DBEVENTPHASE_SYNCHAFTER;
pub const DBEVENTPHASE_FAILEDTODO = DBEVENTPHASEENUM.DBEVENTPHASE_FAILEDTODO;
pub const DBEVENTPHASE_DIDEVENT = DBEVENTPHASEENUM.DBEVENTPHASE_DIDEVENT;

pub const DBREASONENUM = extern enum(i32) {
    DBREASON_ROWSET_FETCHPOSITIONCHANGE = 0,
    DBREASON_ROWSET_RELEASE = 1,
    DBREASON_COLUMN_SET = 2,
    DBREASON_COLUMN_RECALCULATED = 3,
    DBREASON_ROW_ACTIVATE = 4,
    DBREASON_ROW_RELEASE = 5,
    DBREASON_ROW_DELETE = 6,
    DBREASON_ROW_FIRSTCHANGE = 7,
    DBREASON_ROW_INSERT = 8,
    DBREASON_ROW_RESYNCH = 9,
    DBREASON_ROW_UNDOCHANGE = 10,
    DBREASON_ROW_UNDOINSERT = 11,
    DBREASON_ROW_UNDODELETE = 12,
    DBREASON_ROW_UPDATE = 13,
    DBREASON_ROWSET_CHANGED = 14,
};
pub const DBREASON_ROWSET_FETCHPOSITIONCHANGE = DBREASONENUM.DBREASON_ROWSET_FETCHPOSITIONCHANGE;
pub const DBREASON_ROWSET_RELEASE = DBREASONENUM.DBREASON_ROWSET_RELEASE;
pub const DBREASON_COLUMN_SET = DBREASONENUM.DBREASON_COLUMN_SET;
pub const DBREASON_COLUMN_RECALCULATED = DBREASONENUM.DBREASON_COLUMN_RECALCULATED;
pub const DBREASON_ROW_ACTIVATE = DBREASONENUM.DBREASON_ROW_ACTIVATE;
pub const DBREASON_ROW_RELEASE = DBREASONENUM.DBREASON_ROW_RELEASE;
pub const DBREASON_ROW_DELETE = DBREASONENUM.DBREASON_ROW_DELETE;
pub const DBREASON_ROW_FIRSTCHANGE = DBREASONENUM.DBREASON_ROW_FIRSTCHANGE;
pub const DBREASON_ROW_INSERT = DBREASONENUM.DBREASON_ROW_INSERT;
pub const DBREASON_ROW_RESYNCH = DBREASONENUM.DBREASON_ROW_RESYNCH;
pub const DBREASON_ROW_UNDOCHANGE = DBREASONENUM.DBREASON_ROW_UNDOCHANGE;
pub const DBREASON_ROW_UNDOINSERT = DBREASONENUM.DBREASON_ROW_UNDOINSERT;
pub const DBREASON_ROW_UNDODELETE = DBREASONENUM.DBREASON_ROW_UNDODELETE;
pub const DBREASON_ROW_UPDATE = DBREASONENUM.DBREASON_ROW_UPDATE;
pub const DBREASON_ROWSET_CHANGED = DBREASONENUM.DBREASON_ROWSET_CHANGED;

pub const DBREASONENUM15 = extern enum(i32) {
    DBREASON_ROWPOSITION_CHANGED = 15,
    DBREASON_ROWPOSITION_CHAPTERCHANGED = 16,
    DBREASON_ROWPOSITION_CLEARED = 17,
    DBREASON_ROW_ASYNCHINSERT = 18,
};
pub const DBREASON_ROWPOSITION_CHANGED = DBREASONENUM15.DBREASON_ROWPOSITION_CHANGED;
pub const DBREASON_ROWPOSITION_CHAPTERCHANGED = DBREASONENUM15.DBREASON_ROWPOSITION_CHAPTERCHANGED;
pub const DBREASON_ROWPOSITION_CLEARED = DBREASONENUM15.DBREASON_ROWPOSITION_CLEARED;
pub const DBREASON_ROW_ASYNCHINSERT = DBREASONENUM15.DBREASON_ROW_ASYNCHINSERT;

pub const DBCOMPAREOPSENUM = extern enum(i32) {
    DBCOMPAREOPS_LT = 0,
    DBCOMPAREOPS_LE = 1,
    DBCOMPAREOPS_EQ = 2,
    DBCOMPAREOPS_GE = 3,
    DBCOMPAREOPS_GT = 4,
    DBCOMPAREOPS_BEGINSWITH = 5,
    DBCOMPAREOPS_CONTAINS = 6,
    DBCOMPAREOPS_NE = 7,
    DBCOMPAREOPS_IGNORE = 8,
    DBCOMPAREOPS_CASESENSITIVE = 4096,
    DBCOMPAREOPS_CASEINSENSITIVE = 8192,
};
pub const DBCOMPAREOPS_LT = DBCOMPAREOPSENUM.DBCOMPAREOPS_LT;
pub const DBCOMPAREOPS_LE = DBCOMPAREOPSENUM.DBCOMPAREOPS_LE;
pub const DBCOMPAREOPS_EQ = DBCOMPAREOPSENUM.DBCOMPAREOPS_EQ;
pub const DBCOMPAREOPS_GE = DBCOMPAREOPSENUM.DBCOMPAREOPS_GE;
pub const DBCOMPAREOPS_GT = DBCOMPAREOPSENUM.DBCOMPAREOPS_GT;
pub const DBCOMPAREOPS_BEGINSWITH = DBCOMPAREOPSENUM.DBCOMPAREOPS_BEGINSWITH;
pub const DBCOMPAREOPS_CONTAINS = DBCOMPAREOPSENUM.DBCOMPAREOPS_CONTAINS;
pub const DBCOMPAREOPS_NE = DBCOMPAREOPSENUM.DBCOMPAREOPS_NE;
pub const DBCOMPAREOPS_IGNORE = DBCOMPAREOPSENUM.DBCOMPAREOPS_IGNORE;
pub const DBCOMPAREOPS_CASESENSITIVE = DBCOMPAREOPSENUM.DBCOMPAREOPS_CASESENSITIVE;
pub const DBCOMPAREOPS_CASEINSENSITIVE = DBCOMPAREOPSENUM.DBCOMPAREOPS_CASEINSENSITIVE;

pub const DBCOMPAREOPSENUM20 = extern enum(i32) {
    DBCOMPAREOPS_NOTBEGINSWITH = 9,
    DBCOMPAREOPS_NOTCONTAINS = 10,
};
pub const DBCOMPAREOPS_NOTBEGINSWITH = DBCOMPAREOPSENUM20.DBCOMPAREOPS_NOTBEGINSWITH;
pub const DBCOMPAREOPS_NOTCONTAINS = DBCOMPAREOPSENUM20.DBCOMPAREOPS_NOTCONTAINS;

pub const DBASYNCHOPENUM = extern enum(i32) {
    DBASYNCHOP_OPEN = 0,
};
pub const DBASYNCHOP_OPEN = DBASYNCHOPENUM.DBASYNCHOP_OPEN;

pub const DBASYNCHPHASEENUM = extern enum(i32) {
    DBASYNCHPHASE_INITIALIZATION = 0,
    DBASYNCHPHASE_POPULATION = 1,
    DBASYNCHPHASE_COMPLETE = 2,
    DBASYNCHPHASE_CANCELED = 3,
};
pub const DBASYNCHPHASE_INITIALIZATION = DBASYNCHPHASEENUM.DBASYNCHPHASE_INITIALIZATION;
pub const DBASYNCHPHASE_POPULATION = DBASYNCHPHASEENUM.DBASYNCHPHASE_POPULATION;
pub const DBASYNCHPHASE_COMPLETE = DBASYNCHPHASEENUM.DBASYNCHPHASE_COMPLETE;
pub const DBASYNCHPHASE_CANCELED = DBASYNCHPHASEENUM.DBASYNCHPHASE_CANCELED;

pub const DBSORTENUM = extern enum(i32) {
    DBSORT_ASCENDING = 0,
    DBSORT_DESCENDING = 1,
};
pub const DBSORT_ASCENDING = DBSORTENUM.DBSORT_ASCENDING;
pub const DBSORT_DESCENDING = DBSORTENUM.DBSORT_DESCENDING;

pub const DBCOMMANDPERSISTFLAGENUM = extern enum(i32) {
    DBCOMMANDPERSISTFLAG_NOSAVE = 1,
};
pub const DBCOMMANDPERSISTFLAG_NOSAVE = DBCOMMANDPERSISTFLAGENUM.DBCOMMANDPERSISTFLAG_NOSAVE;

pub const DBCOMMANDPERSISTFLAGENUM21 = extern enum(i32) {
    DBCOMMANDPERSISTFLAG_DEFAULT = 0,
    DBCOMMANDPERSISTFLAG_PERSISTVIEW = 2,
    DBCOMMANDPERSISTFLAG_PERSISTPROCEDURE = 4,
};
pub const DBCOMMANDPERSISTFLAG_DEFAULT = DBCOMMANDPERSISTFLAGENUM21.DBCOMMANDPERSISTFLAG_DEFAULT;
pub const DBCOMMANDPERSISTFLAG_PERSISTVIEW = DBCOMMANDPERSISTFLAGENUM21.DBCOMMANDPERSISTFLAG_PERSISTVIEW;
pub const DBCOMMANDPERSISTFLAG_PERSISTPROCEDURE = DBCOMMANDPERSISTFLAGENUM21.DBCOMMANDPERSISTFLAG_PERSISTPROCEDURE;

pub const DBCONSTRAINTTYPEENUM = extern enum(i32) {
    DBCONSTRAINTTYPE_UNIQUE = 0,
    DBCONSTRAINTTYPE_FOREIGNKEY = 1,
    DBCONSTRAINTTYPE_PRIMARYKEY = 2,
    DBCONSTRAINTTYPE_CHECK = 3,
};
pub const DBCONSTRAINTTYPE_UNIQUE = DBCONSTRAINTTYPEENUM.DBCONSTRAINTTYPE_UNIQUE;
pub const DBCONSTRAINTTYPE_FOREIGNKEY = DBCONSTRAINTTYPEENUM.DBCONSTRAINTTYPE_FOREIGNKEY;
pub const DBCONSTRAINTTYPE_PRIMARYKEY = DBCONSTRAINTTYPEENUM.DBCONSTRAINTTYPE_PRIMARYKEY;
pub const DBCONSTRAINTTYPE_CHECK = DBCONSTRAINTTYPEENUM.DBCONSTRAINTTYPE_CHECK;

pub const DBUPDELRULEENUM = extern enum(i32) {
    DBUPDELRULE_NOACTION = 0,
    DBUPDELRULE_CASCADE = 1,
    DBUPDELRULE_SETNULL = 2,
    DBUPDELRULE_SETDEFAULT = 3,
};
pub const DBUPDELRULE_NOACTION = DBUPDELRULEENUM.DBUPDELRULE_NOACTION;
pub const DBUPDELRULE_CASCADE = DBUPDELRULEENUM.DBUPDELRULE_CASCADE;
pub const DBUPDELRULE_SETNULL = DBUPDELRULEENUM.DBUPDELRULE_SETNULL;
pub const DBUPDELRULE_SETDEFAULT = DBUPDELRULEENUM.DBUPDELRULE_SETDEFAULT;

pub const DBMATCHTYPEENUM = extern enum(i32) {
    DBMATCHTYPE_FULL = 0,
    DBMATCHTYPE_NONE = 1,
    DBMATCHTYPE_PARTIAL = 2,
};
pub const DBMATCHTYPE_FULL = DBMATCHTYPEENUM.DBMATCHTYPE_FULL;
pub const DBMATCHTYPE_NONE = DBMATCHTYPEENUM.DBMATCHTYPE_NONE;
pub const DBMATCHTYPE_PARTIAL = DBMATCHTYPEENUM.DBMATCHTYPE_PARTIAL;

pub const DBDEFERRABILITYENUM = extern enum(i32) {
    DBDEFERRABILITY_DEFERRED = 1,
    DBDEFERRABILITY_DEFERRABLE = 2,
};
pub const DBDEFERRABILITY_DEFERRED = DBDEFERRABILITYENUM.DBDEFERRABILITY_DEFERRED;
pub const DBDEFERRABILITY_DEFERRABLE = DBDEFERRABILITYENUM.DBDEFERRABILITY_DEFERRABLE;

pub const DBCONSTRAINTDESC = extern struct {
    pConstraintID: *DBID,
    ConstraintType: u32,
    cColumns: u32,
    rgColumnList: *DBID,
    pReferencedTableID: *DBID,
    cForeignKeyColumns: u32,
    rgForeignKeyColumnList: *DBID,
    pwszConstraintText: PWSTR,
    UpdateRule: u32,
    DeleteRule: u32,
    MatchType: u32,
    Deferrability: u32,
    cReserved: u32,
    rgReserved: *DBPROPSET,
};

pub const MDAXISINFO = extern struct {
    cbSize: u32,
    iAxis: u32,
    cDimensions: u32,
    cCoordinates: u32,
    rgcColumns: *u32,
    rgpwszDimensionNames: *PWSTR,
};

pub const RMTPACK = extern struct {
    pISeqStream: *ISequentialStream,
    cbData: u32,
    cBSTR: u32,
    rgBSTR: *BSTR,
    cVARIANT: u32,
    rgVARIANT: *VARIANT,
    cIDISPATCH: u32,
    rgIDISPATCH: **IDispatch,
    cIUNKNOWN: u32,
    rgIUNKNOWN: **IUnknown,
    cPROPVARIANT: u32,
    rgPROPVARIANT: *PROPVARIANT,
    cArray: u32,
    rgArray: *VARIANT,
};

pub const DBACCESSORFLAGSENUM = extern enum(i32) {
    DBACCESSOR_INVALID = 0,
    DBACCESSOR_PASSBYREF = 1,
    DBACCESSOR_ROWDATA = 2,
    DBACCESSOR_PARAMETERDATA = 4,
    DBACCESSOR_OPTIMIZED = 8,
    DBACCESSOR_INHERITED = 16,
};
pub const DBACCESSOR_INVALID = DBACCESSORFLAGSENUM.DBACCESSOR_INVALID;
pub const DBACCESSOR_PASSBYREF = DBACCESSORFLAGSENUM.DBACCESSOR_PASSBYREF;
pub const DBACCESSOR_ROWDATA = DBACCESSORFLAGSENUM.DBACCESSOR_ROWDATA;
pub const DBACCESSOR_PARAMETERDATA = DBACCESSORFLAGSENUM.DBACCESSOR_PARAMETERDATA;
pub const DBACCESSOR_OPTIMIZED = DBACCESSORFLAGSENUM.DBACCESSOR_OPTIMIZED;
pub const DBACCESSOR_INHERITED = DBACCESSORFLAGSENUM.DBACCESSOR_INHERITED;

pub const DBBINDSTATUSENUM = extern enum(i32) {
    DBBINDSTATUS_OK = 0,
    DBBINDSTATUS_BADORDINAL = 1,
    DBBINDSTATUS_UNSUPPORTEDCONVERSION = 2,
    DBBINDSTATUS_BADBINDINFO = 3,
    DBBINDSTATUS_BADSTORAGEFLAGS = 4,
    DBBINDSTATUS_NOINTERFACE = 5,
    DBBINDSTATUS_MULTIPLESTORAGE = 6,
};
pub const DBBINDSTATUS_OK = DBBINDSTATUSENUM.DBBINDSTATUS_OK;
pub const DBBINDSTATUS_BADORDINAL = DBBINDSTATUSENUM.DBBINDSTATUS_BADORDINAL;
pub const DBBINDSTATUS_UNSUPPORTEDCONVERSION = DBBINDSTATUSENUM.DBBINDSTATUS_UNSUPPORTEDCONVERSION;
pub const DBBINDSTATUS_BADBINDINFO = DBBINDSTATUSENUM.DBBINDSTATUS_BADBINDINFO;
pub const DBBINDSTATUS_BADSTORAGEFLAGS = DBBINDSTATUSENUM.DBBINDSTATUS_BADSTORAGEFLAGS;
pub const DBBINDSTATUS_NOINTERFACE = DBBINDSTATUSENUM.DBBINDSTATUS_NOINTERFACE;
pub const DBBINDSTATUS_MULTIPLESTORAGE = DBBINDSTATUSENUM.DBBINDSTATUS_MULTIPLESTORAGE;

const IID_IAccessor_Value = @import("../zig.zig").Guid.initString("0C733A8C-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IAccessor = &IID_IAccessor_Value;
pub const IAccessor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddRefAccessor: fn(
            self: *const IAccessor,
            hAccessor: ?*c_void,
            pcRefCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateAccessor: fn(
            self: *const IAccessor,
            dwAccessorFlags: u32,
            cBindings: u32,
            rgBindings: [*]const DBBINDING,
            cbRowSize: u32,
            phAccessor: *?*c_void,
            rgStatus: ?[*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBindings: fn(
            self: *const IAccessor,
            hAccessor: ?*c_void,
            pdwAccessorFlags: *u32,
            pcBindings: ?*u32,
            prgBindings: ?*?*DBBINDING,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseAccessor: fn(
            self: *const IAccessor,
            hAccessor: ?*c_void,
            pcRefCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessor_AddRefAccessor(self: *const T, hAccessor: ?*c_void, pcRefCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessor.VTable, self.vtable).AddRefAccessor(@ptrCast(*const IAccessor, self), hAccessor, pcRefCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessor_CreateAccessor(self: *const T, dwAccessorFlags: u32, cBindings: u32, rgBindings: [*]const DBBINDING, cbRowSize: u32, phAccessor: *?*c_void, rgStatus: ?[*]u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessor.VTable, self.vtable).CreateAccessor(@ptrCast(*const IAccessor, self), dwAccessorFlags, cBindings, rgBindings, cbRowSize, phAccessor, rgStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessor_GetBindings(self: *const T, hAccessor: ?*c_void, pdwAccessorFlags: *u32, pcBindings: ?*u32, prgBindings: ?*?*DBBINDING) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessor.VTable, self.vtable).GetBindings(@ptrCast(*const IAccessor, self), hAccessor, pdwAccessorFlags, pcBindings, prgBindings);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessor_ReleaseAccessor(self: *const T, hAccessor: ?*c_void, pcRefCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessor.VTable, self.vtable).ReleaseAccessor(@ptrCast(*const IAccessor, self), hAccessor, pcRefCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowset_Value = @import("../zig.zig").Guid.initString("0C733A7C-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IRowset = &IID_IRowset_Value;
pub const IRowset = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddRefRows: fn(
            self: *const IRowset,
            cRows: u32,
            rghRows: *const ?*c_void,
            rgRefCounts: *u32,
            rgRowStatus: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetData: fn(
            self: *const IRowset,
            hRow: ?*c_void,
            hAccessor: ?*c_void,
            pData: *c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextRows: fn(
            self: *const IRowset,
            hReserved: ?*c_void,
            lRowsOffset: i32,
            cRows: i32,
            pcRowsObtained: *u32,
            prghRows: **?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseRows: fn(
            self: *const IRowset,
            cRows: u32,
            rghRows: *const ?*c_void,
            rgRowOptions: *u32,
            rgRefCounts: *u32,
            rgRowStatus: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RestartPosition: fn(
            self: *const IRowset,
            hReserved: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowset_AddRefRows(self: *const T, cRows: u32, rghRows: *const ?*c_void, rgRefCounts: *u32, rgRowStatus: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowset.VTable, self.vtable).AddRefRows(@ptrCast(*const IRowset, self), cRows, rghRows, rgRefCounts, rgRowStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowset_GetData(self: *const T, hRow: ?*c_void, hAccessor: ?*c_void, pData: *c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowset.VTable, self.vtable).GetData(@ptrCast(*const IRowset, self), hRow, hAccessor, pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowset_GetNextRows(self: *const T, hReserved: ?*c_void, lRowsOffset: i32, cRows: i32, pcRowsObtained: *u32, prghRows: **?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowset.VTable, self.vtable).GetNextRows(@ptrCast(*const IRowset, self), hReserved, lRowsOffset, cRows, pcRowsObtained, prghRows);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowset_ReleaseRows(self: *const T, cRows: u32, rghRows: *const ?*c_void, rgRowOptions: *u32, rgRefCounts: *u32, rgRowStatus: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowset.VTable, self.vtable).ReleaseRows(@ptrCast(*const IRowset, self), cRows, rghRows, rgRowOptions, rgRefCounts, rgRowStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowset_RestartPosition(self: *const T, hReserved: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowset.VTable, self.vtable).RestartPosition(@ptrCast(*const IRowset, self), hReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetInfo_Value = @import("../zig.zig").Guid.initString("0C733A55-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IRowsetInfo = &IID_IRowsetInfo_Value;
pub const IRowsetInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperties: fn(
            self: *const IRowsetInfo,
            cPropertyIDSets: u32,
            rgPropertyIDSets: ?[*]const DBPROPIDSET,
            pcPropertySets: *u32,
            prgPropertySets: ?*?*DBPROPSET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetReferencedRowset: fn(
            self: *const IRowsetInfo,
            iOrdinal: u32,
            riid: *const Guid,
            ppReferencedRowset: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpecification: fn(
            self: *const IRowsetInfo,
            riid: *const Guid,
            ppSpecification: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowsetInfo_GetProperties(self: *const T, cPropertyIDSets: u32, rgPropertyIDSets: ?[*]const DBPROPIDSET, pcPropertySets: *u32, prgPropertySets: ?*?*DBPROPSET) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowsetInfo.VTable, self.vtable).GetProperties(@ptrCast(*const IRowsetInfo, self), cPropertyIDSets, rgPropertyIDSets, pcPropertySets, prgPropertySets);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowsetInfo_GetReferencedRowset(self: *const T, iOrdinal: u32, riid: *const Guid, ppReferencedRowset: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowsetInfo.VTable, self.vtable).GetReferencedRowset(@ptrCast(*const IRowsetInfo, self), iOrdinal, riid, ppReferencedRowset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowsetInfo_GetSpecification(self: *const T, riid: *const Guid, ppSpecification: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowsetInfo.VTable, self.vtable).GetSpecification(@ptrCast(*const IRowsetInfo, self), riid, ppSpecification);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DBCOMPAREENUM = extern enum(i32) {
    DBCOMPARE_LT = 0,
    DBCOMPARE_EQ = 1,
    DBCOMPARE_GT = 2,
    DBCOMPARE_NE = 3,
    DBCOMPARE_NOTCOMPARABLE = 4,
};
pub const DBCOMPARE_LT = DBCOMPAREENUM.DBCOMPARE_LT;
pub const DBCOMPARE_EQ = DBCOMPAREENUM.DBCOMPARE_EQ;
pub const DBCOMPARE_GT = DBCOMPAREENUM.DBCOMPARE_GT;
pub const DBCOMPARE_NE = DBCOMPAREENUM.DBCOMPARE_NE;
pub const DBCOMPARE_NOTCOMPARABLE = DBCOMPAREENUM.DBCOMPARE_NOTCOMPARABLE;

const IID_IRowsetLocate_Value = @import("../zig.zig").Guid.initString("0C733A7D-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IRowsetLocate = &IID_IRowsetLocate_Value;
pub const IRowsetLocate = extern struct {
    pub const VTable = extern struct {
        base: IRowset.VTable,
        Compare: fn(
            self: *const IRowsetLocate,
            hReserved: ?*c_void,
            cbBookmark1: u32,
            pBookmark1: *const u8,
            cbBookmark2: u32,
            pBookmark2: *const u8,
            pComparison: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRowsAt: fn(
            self: *const IRowsetLocate,
            hReserved1: ?*c_void,
            hReserved2: ?*c_void,
            cbBookmark: u32,
            pBookmark: *const u8,
            lRowsOffset: i32,
            cRows: i32,
            pcRowsObtained: *u32,
            prghRows: **?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRowsByBookmark: fn(
            self: *const IRowsetLocate,
            hReserved: ?*c_void,
            cRows: u32,
            rgcbBookmarks: *const u32,
            rgpBookmarks: *const *const u8,
            rghRows: *?*c_void,
            rgRowStatus: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Hash: fn(
            self: *const IRowsetLocate,
            hReserved: ?*c_void,
            cBookmarks: u32,
            rgcbBookmarks: *const u32,
            rgpBookmarks: *const *const u8,
            rgHashedValues: *u32,
            rgBookmarkStatus: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IRowset.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowsetLocate_Compare(self: *const T, hReserved: ?*c_void, cbBookmark1: u32, pBookmark1: *const u8, cbBookmark2: u32, pBookmark2: *const u8, pComparison: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowsetLocate.VTable, self.vtable).Compare(@ptrCast(*const IRowsetLocate, self), hReserved, cbBookmark1, pBookmark1, cbBookmark2, pBookmark2, pComparison);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowsetLocate_GetRowsAt(self: *const T, hReserved1: ?*c_void, hReserved2: ?*c_void, cbBookmark: u32, pBookmark: *const u8, lRowsOffset: i32, cRows: i32, pcRowsObtained: *u32, prghRows: **?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowsetLocate.VTable, self.vtable).GetRowsAt(@ptrCast(*const IRowsetLocate, self), hReserved1, hReserved2, cbBookmark, pBookmark, lRowsOffset, cRows, pcRowsObtained, prghRows);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowsetLocate_GetRowsByBookmark(self: *const T, hReserved: ?*c_void, cRows: u32, rgcbBookmarks: *const u32, rgpBookmarks: *const *const u8, rghRows: *?*c_void, rgRowStatus: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowsetLocate.VTable, self.vtable).GetRowsByBookmark(@ptrCast(*const IRowsetLocate, self), hReserved, cRows, rgcbBookmarks, rgpBookmarks, rghRows, rgRowStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowsetLocate_Hash(self: *const T, hReserved: ?*c_void, cBookmarks: u32, rgcbBookmarks: *const u32, rgpBookmarks: *const *const u8, rgHashedValues: *u32, rgBookmarkStatus: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowsetLocate.VTable, self.vtable).Hash(@ptrCast(*const IRowsetLocate, self), hReserved, cBookmarks, rgcbBookmarks, rgpBookmarks, rgHashedValues, rgBookmarkStatus);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetResynch_Value = @import("../zig.zig").Guid.initString("0C733A84-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IRowsetResynch = &IID_IRowsetResynch_Value;
pub const IRowsetResynch = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetVisibleData: fn(
            self: *const IRowsetResynch,
            hRow: ?*c_void,
            hAccessor: ?*c_void,
            pData: *c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResynchRows: fn(
            self: *const IRowsetResynch,
            cRows: u32,
            rghRows: *const ?*c_void,
            pcRowsResynched: *u32,
            prghRowsResynched: **?*c_void,
            prgRowStatus: **u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowsetResynch_GetVisibleData(self: *const T, hRow: ?*c_void, hAccessor: ?*c_void, pData: *c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowsetResynch.VTable, self.vtable).GetVisibleData(@ptrCast(*const IRowsetResynch, self), hRow, hAccessor, pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowsetResynch_ResynchRows(self: *const T, cRows: u32, rghRows: *const ?*c_void, pcRowsResynched: *u32, prghRowsResynched: **?*c_void, prgRowStatus: **u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowsetResynch.VTable, self.vtable).ResynchRows(@ptrCast(*const IRowsetResynch, self), cRows, rghRows, pcRowsResynched, prghRowsResynched, prgRowStatus);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetScroll_Value = @import("../zig.zig").Guid.initString("0C733A7E-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IRowsetScroll = &IID_IRowsetScroll_Value;
pub const IRowsetScroll = extern struct {
    pub const VTable = extern struct {
        base: IRowsetLocate.VTable,
        GetApproximatePosition: fn(
            self: *const IRowsetScroll,
            hReserved: ?*c_void,
            cbBookmark: u32,
            pBookmark: *const u8,
            pulPosition: *u32,
            pcRows: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRowsAtRatio: fn(
            self: *const IRowsetScroll,
            hReserved1: ?*c_void,
            hReserved2: ?*c_void,
            ulNumerator: u32,
            ulDenominator: u32,
            cRows: i32,
            pcRowsObtained: *u32,
            prghRows: **?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IRowsetLocate.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowsetScroll_GetApproximatePosition(self: *const T, hReserved: ?*c_void, cbBookmark: u32, pBookmark: *const u8, pulPosition: *u32, pcRows: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowsetScroll.VTable, self.vtable).GetApproximatePosition(@ptrCast(*const IRowsetScroll, self), hReserved, cbBookmark, pBookmark, pulPosition, pcRows);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowsetScroll_GetRowsAtRatio(self: *const T, hReserved1: ?*c_void, hReserved2: ?*c_void, ulNumerator: u32, ulDenominator: u32, cRows: i32, pcRowsObtained: *u32, prghRows: **?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowsetScroll.VTable, self.vtable).GetRowsAtRatio(@ptrCast(*const IRowsetScroll, self), hReserved1, hReserved2, ulNumerator, ulDenominator, cRows, pcRowsObtained, prghRows);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IChapteredRowset_Value = @import("../zig.zig").Guid.initString("0C733A93-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IChapteredRowset = &IID_IChapteredRowset_Value;
pub const IChapteredRowset = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddRefChapter: fn(
            self: *const IChapteredRowset,
            hChapter: ?*c_void,
            pcRefCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseChapter: fn(
            self: *const IChapteredRowset,
            hChapter: ?*c_void,
            pcRefCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IChapteredRowset_AddRefChapter(self: *const T, hChapter: ?*c_void, pcRefCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IChapteredRowset.VTable, self.vtable).AddRefChapter(@ptrCast(*const IChapteredRowset, self), hChapter, pcRefCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IChapteredRowset_ReleaseChapter(self: *const T, hChapter: ?*c_void, pcRefCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IChapteredRowset.VTable, self.vtable).ReleaseChapter(@ptrCast(*const IChapteredRowset, self), hChapter, pcRefCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetFind_Value = @import("../zig.zig").Guid.initString("0C733A9D-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IRowsetFind = &IID_IRowsetFind_Value;
pub const IRowsetFind = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FindNextRow: fn(
            self: *const IRowsetFind,
            hChapter: ?*c_void,
            hAccessor: ?*c_void,
            pFindValue: *c_void,
            CompareOp: u32,
            cbBookmark: u32,
            pBookmark: *const u8,
            lRowsOffset: i32,
            cRows: i32,
            pcRowsObtained: *u32,
            prghRows: **?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowsetFind_FindNextRow(self: *const T, hChapter: ?*c_void, hAccessor: ?*c_void, pFindValue: *c_void, CompareOp: u32, cbBookmark: u32, pBookmark: *const u8, lRowsOffset: i32, cRows: i32, pcRowsObtained: *u32, prghRows: **?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowsetFind.VTable, self.vtable).FindNextRow(@ptrCast(*const IRowsetFind, self), hChapter, hAccessor, pFindValue, CompareOp, cbBookmark, pBookmark, lRowsOffset, cRows, pcRowsObtained, prghRows);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DBPOSITIONFLAGSENUM = extern enum(i32) {
    DBPOSITION_OK = 0,
    DBPOSITION_NOROW = 1,
    DBPOSITION_BOF = 2,
    DBPOSITION_EOF = 3,
};
pub const DBPOSITION_OK = DBPOSITIONFLAGSENUM.DBPOSITION_OK;
pub const DBPOSITION_NOROW = DBPOSITIONFLAGSENUM.DBPOSITION_NOROW;
pub const DBPOSITION_BOF = DBPOSITIONFLAGSENUM.DBPOSITION_BOF;
pub const DBPOSITION_EOF = DBPOSITIONFLAGSENUM.DBPOSITION_EOF;

const IID_IRowPosition_Value = @import("../zig.zig").Guid.initString("0C733A94-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IRowPosition = &IID_IRowPosition_Value;
pub const IRowPosition = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ClearRowPosition: fn(
            self: *const IRowPosition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRowPosition: fn(
            self: *const IRowPosition,
            phChapter: ?*?*c_void,
            phRow: *?*c_void,
            pdwPositionFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRowset: fn(
            self: *const IRowPosition,
            riid: *const Guid,
            ppRowset: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Initialize: fn(
            self: *const IRowPosition,
            pRowset: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRowPosition: fn(
            self: *const IRowPosition,
            hChapter: ?*c_void,
            hRow: ?*c_void,
            dwPositionFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowPosition_ClearRowPosition(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowPosition.VTable, self.vtable).ClearRowPosition(@ptrCast(*const IRowPosition, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowPosition_GetRowPosition(self: *const T, phChapter: ?*?*c_void, phRow: *?*c_void, pdwPositionFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowPosition.VTable, self.vtable).GetRowPosition(@ptrCast(*const IRowPosition, self), phChapter, phRow, pdwPositionFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowPosition_GetRowset(self: *const T, riid: *const Guid, ppRowset: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowPosition.VTable, self.vtable).GetRowset(@ptrCast(*const IRowPosition, self), riid, ppRowset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowPosition_Initialize(self: *const T, pRowset: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowPosition.VTable, self.vtable).Initialize(@ptrCast(*const IRowPosition, self), pRowset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowPosition_SetRowPosition(self: *const T, hChapter: ?*c_void, hRow: ?*c_void, dwPositionFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowPosition.VTable, self.vtable).SetRowPosition(@ptrCast(*const IRowPosition, self), hChapter, hRow, dwPositionFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowPositionChange_Value = @import("../zig.zig").Guid.initString("0997A571-126E-11D0-9F8A-00A0C9A0631E");
pub const IID_IRowPositionChange = &IID_IRowPositionChange_Value;
pub const IRowPositionChange = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnRowPositionChange: fn(
            self: *const IRowPositionChange,
            eReason: u32,
            ePhase: u32,
            fCantDeny: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowPositionChange_OnRowPositionChange(self: *const T, eReason: u32, ePhase: u32, fCantDeny: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowPositionChange.VTable, self.vtable).OnRowPositionChange(@ptrCast(*const IRowPositionChange, self), eReason, ePhase, fCantDeny);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IViewRowset_Value = @import("../zig.zig").Guid.initString("0C733A97-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IViewRowset = &IID_IViewRowset_Value;
pub const IViewRowset = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSpecification: fn(
            self: *const IViewRowset,
            riid: *const Guid,
            ppObject: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenViewRowset: fn(
            self: *const IViewRowset,
            pUnkOuter: ?*IUnknown,
            riid: *const Guid,
            ppRowset: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewRowset_GetSpecification(self: *const T, riid: *const Guid, ppObject: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IViewRowset.VTable, self.vtable).GetSpecification(@ptrCast(*const IViewRowset, self), riid, ppObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewRowset_OpenViewRowset(self: *const T, pUnkOuter: ?*IUnknown, riid: *const Guid, ppRowset: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IViewRowset.VTable, self.vtable).OpenViewRowset(@ptrCast(*const IViewRowset, self), pUnkOuter, riid, ppRowset);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IViewChapter_Value = @import("../zig.zig").Guid.initString("0C733A98-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IViewChapter = &IID_IViewChapter_Value;
pub const IViewChapter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSpecification: fn(
            self: *const IViewChapter,
            riid: *const Guid,
            ppRowset: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenViewChapter: fn(
            self: *const IViewChapter,
            hSource: ?*c_void,
            phViewChapter: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewChapter_GetSpecification(self: *const T, riid: *const Guid, ppRowset: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IViewChapter.VTable, self.vtable).GetSpecification(@ptrCast(*const IViewChapter, self), riid, ppRowset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewChapter_OpenViewChapter(self: *const T, hSource: ?*c_void, phViewChapter: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IViewChapter.VTable, self.vtable).OpenViewChapter(@ptrCast(*const IViewChapter, self), hSource, phViewChapter);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IViewSort_Value = @import("../zig.zig").Guid.initString("0C733A9A-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IViewSort = &IID_IViewSort_Value;
pub const IViewSort = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSortOrder: fn(
            self: *const IViewSort,
            pcValues: *u32,
            prgColumns: **u32,
            prgOrders: **u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSortOrder: fn(
            self: *const IViewSort,
            cValues: u32,
            rgColumns: [*]const u32,
            rgOrders: [*]const u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewSort_GetSortOrder(self: *const T, pcValues: *u32, prgColumns: **u32, prgOrders: **u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IViewSort.VTable, self.vtable).GetSortOrder(@ptrCast(*const IViewSort, self), pcValues, prgColumns, prgOrders);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewSort_SetSortOrder(self: *const T, cValues: u32, rgColumns: [*]const u32, rgOrders: [*]const u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IViewSort.VTable, self.vtable).SetSortOrder(@ptrCast(*const IViewSort, self), cValues, rgColumns, rgOrders);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IViewFilter_Value = @import("../zig.zig").Guid.initString("0C733A9B-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IViewFilter = &IID_IViewFilter_Value;
pub const IViewFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFilter: fn(
            self: *const IViewFilter,
            hAccessor: ?*c_void,
            pcRows: *u32,
            pCompareOps: [*]*u32,
            pCriteriaData: *c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFilterBindings: fn(
            self: *const IViewFilter,
            pcBindings: *u32,
            prgBindings: ?*?*DBBINDING,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFilter: fn(
            self: *const IViewFilter,
            hAccessor: ?*c_void,
            cRows: u32,
            CompareOps: [*]u32,
            pCriteriaData: *c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewFilter_GetFilter(self: *const T, hAccessor: ?*c_void, pcRows: *u32, pCompareOps: [*]*u32, pCriteriaData: *c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IViewFilter.VTable, self.vtable).GetFilter(@ptrCast(*const IViewFilter, self), hAccessor, pcRows, pCompareOps, pCriteriaData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewFilter_GetFilterBindings(self: *const T, pcBindings: *u32, prgBindings: ?*?*DBBINDING) callconv(.Inline) HRESULT {
            return @ptrCast(*const IViewFilter.VTable, self.vtable).GetFilterBindings(@ptrCast(*const IViewFilter, self), pcBindings, prgBindings);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewFilter_SetFilter(self: *const T, hAccessor: ?*c_void, cRows: u32, CompareOps: [*]u32, pCriteriaData: *c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IViewFilter.VTable, self.vtable).SetFilter(@ptrCast(*const IViewFilter, self), hAccessor, cRows, CompareOps, pCriteriaData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetView_Value = @import("../zig.zig").Guid.initString("0C733A99-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IRowsetView = &IID_IRowsetView_Value;
pub const IRowsetView = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateView: fn(
            self: *const IRowsetView,
            pUnkOuter: ?*IUnknown,
            riid: *const Guid,
            ppView: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetView: fn(
            self: *const IRowsetView,
            hChapter: ?*c_void,
            riid: *const Guid,
            phChapterSource: *?*c_void,
            ppView: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowsetView_CreateView(self: *const T, pUnkOuter: ?*IUnknown, riid: *const Guid, ppView: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowsetView.VTable, self.vtable).CreateView(@ptrCast(*const IRowsetView, self), pUnkOuter, riid, ppView);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowsetView_GetView(self: *const T, hChapter: ?*c_void, riid: *const Guid, phChapterSource: *?*c_void, ppView: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowsetView.VTable, self.vtable).GetView(@ptrCast(*const IRowsetView, self), hChapter, riid, phChapterSource, ppView);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetChange_Value = @import("../zig.zig").Guid.initString("0C733A05-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IRowsetChange = &IID_IRowsetChange_Value;
pub const IRowsetChange = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DeleteRows: fn(
            self: *const IRowsetChange,
            hReserved: ?*c_void,
            cRows: u32,
            rghRows: *const ?*c_void,
            rgRowStatus: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetData: fn(
            self: *const IRowsetChange,
            hRow: ?*c_void,
            hAccessor: ?*c_void,
            pData: *c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertRow: fn(
            self: *const IRowsetChange,
            hReserved: ?*c_void,
            hAccessor: ?*c_void,
            pData: *c_void,
            phRow: *?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowsetChange_DeleteRows(self: *const T, hReserved: ?*c_void, cRows: u32, rghRows: *const ?*c_void, rgRowStatus: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowsetChange.VTable, self.vtable).DeleteRows(@ptrCast(*const IRowsetChange, self), hReserved, cRows, rghRows, rgRowStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowsetChange_SetData(self: *const T, hRow: ?*c_void, hAccessor: ?*c_void, pData: *c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowsetChange.VTable, self.vtable).SetData(@ptrCast(*const IRowsetChange, self), hRow, hAccessor, pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowsetChange_InsertRow(self: *const T, hReserved: ?*c_void, hAccessor: ?*c_void, pData: *c_void, phRow: *?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowsetChange.VTable, self.vtable).InsertRow(@ptrCast(*const IRowsetChange, self), hReserved, hAccessor, pData, phRow);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DBPENDINGSTATUSENUM = extern enum(i32) {
    DBPENDINGSTATUS_NEW = 1,
    DBPENDINGSTATUS_CHANGED = 2,
    DBPENDINGSTATUS_DELETED = 4,
    DBPENDINGSTATUS_UNCHANGED = 8,
    DBPENDINGSTATUS_INVALIDROW = 16,
};
pub const DBPENDINGSTATUS_NEW = DBPENDINGSTATUSENUM.DBPENDINGSTATUS_NEW;
pub const DBPENDINGSTATUS_CHANGED = DBPENDINGSTATUSENUM.DBPENDINGSTATUS_CHANGED;
pub const DBPENDINGSTATUS_DELETED = DBPENDINGSTATUSENUM.DBPENDINGSTATUS_DELETED;
pub const DBPENDINGSTATUS_UNCHANGED = DBPENDINGSTATUSENUM.DBPENDINGSTATUS_UNCHANGED;
pub const DBPENDINGSTATUS_INVALIDROW = DBPENDINGSTATUSENUM.DBPENDINGSTATUS_INVALIDROW;

const IID_IRowsetUpdate_Value = @import("../zig.zig").Guid.initString("0C733A6D-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IRowsetUpdate = &IID_IRowsetUpdate_Value;
pub const IRowsetUpdate = extern struct {
    pub const VTable = extern struct {
        base: IRowsetChange.VTable,
        GetOriginalData: fn(
            self: *const IRowsetUpdate,
            hRow: ?*c_void,
            hAccessor: ?*c_void,
            pData: *c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPendingRows: fn(
            self: *const IRowsetUpdate,
            hReserved: ?*c_void,
            dwRowStatus: u32,
            pcPendingRows: *u32,
            prgPendingRows: **?*c_void,
            prgPendingStatus: **u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRowStatus: fn(
            self: *const IRowsetUpdate,
            hReserved: ?*c_void,
            cRows: u32,
            rghRows: *const ?*c_void,
            rgPendingStatus: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Undo: fn(
            self: *const IRowsetUpdate,
            hReserved: ?*c_void,
            cRows: u32,
            rghRows: *const ?*c_void,
            pcRowsUndone: *u32,
            prgRowsUndone: **?*c_void,
            prgRowStatus: **u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Update: fn(
            self: *const IRowsetUpdate,
            hReserved: ?*c_void,
            cRows: u32,
            rghRows: *const ?*c_void,
            pcRows: *u32,
            prgRows: **?*c_void,
            prgRowStatus: **u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IRowsetChange.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowsetUpdate_GetOriginalData(self: *const T, hRow: ?*c_void, hAccessor: ?*c_void, pData: *c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowsetUpdate.VTable, self.vtable).GetOriginalData(@ptrCast(*const IRowsetUpdate, self), hRow, hAccessor, pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowsetUpdate_GetPendingRows(self: *const T, hReserved: ?*c_void, dwRowStatus: u32, pcPendingRows: *u32, prgPendingRows: **?*c_void, prgPendingStatus: **u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowsetUpdate.VTable, self.vtable).GetPendingRows(@ptrCast(*const IRowsetUpdate, self), hReserved, dwRowStatus, pcPendingRows, prgPendingRows, prgPendingStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowsetUpdate_GetRowStatus(self: *const T, hReserved: ?*c_void, cRows: u32, rghRows: *const ?*c_void, rgPendingStatus: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowsetUpdate.VTable, self.vtable).GetRowStatus(@ptrCast(*const IRowsetUpdate, self), hReserved, cRows, rghRows, rgPendingStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowsetUpdate_Undo(self: *const T, hReserved: ?*c_void, cRows: u32, rghRows: *const ?*c_void, pcRowsUndone: *u32, prgRowsUndone: **?*c_void, prgRowStatus: **u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowsetUpdate.VTable, self.vtable).Undo(@ptrCast(*const IRowsetUpdate, self), hReserved, cRows, rghRows, pcRowsUndone, prgRowsUndone, prgRowStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowsetUpdate_Update(self: *const T, hReserved: ?*c_void, cRows: u32, rghRows: *const ?*c_void, pcRows: *u32, prgRows: **?*c_void, prgRowStatus: **u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowsetUpdate.VTable, self.vtable).Update(@ptrCast(*const IRowsetUpdate, self), hReserved, cRows, rghRows, pcRows, prgRows, prgRowStatus);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetIdentity_Value = @import("../zig.zig").Guid.initString("0C733A09-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IRowsetIdentity = &IID_IRowsetIdentity_Value;
pub const IRowsetIdentity = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsSameRow: fn(
            self: *const IRowsetIdentity,
            hThisRow: ?*c_void,
            hThatRow: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowsetIdentity_IsSameRow(self: *const T, hThisRow: ?*c_void, hThatRow: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowsetIdentity.VTable, self.vtable).IsSameRow(@ptrCast(*const IRowsetIdentity, self), hThisRow, hThatRow);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetNotify_Value = @import("../zig.zig").Guid.initString("0C733A83-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IRowsetNotify = &IID_IRowsetNotify_Value;
pub const IRowsetNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnFieldChange: fn(
            self: *const IRowsetNotify,
            pRowset: *IRowset,
            hRow: ?*c_void,
            cColumns: u32,
            rgColumns: [*]u32,
            eReason: u32,
            ePhase: u32,
            fCantDeny: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnRowChange: fn(
            self: *const IRowsetNotify,
            pRowset: *IRowset,
            cRows: u32,
            rghRows: [*]const ?*c_void,
            eReason: u32,
            ePhase: u32,
            fCantDeny: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnRowsetChange: fn(
            self: *const IRowsetNotify,
            pRowset: *IRowset,
            eReason: u32,
            ePhase: u32,
            fCantDeny: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowsetNotify_OnFieldChange(self: *const T, pRowset: *IRowset, hRow: ?*c_void, cColumns: u32, rgColumns: [*]u32, eReason: u32, ePhase: u32, fCantDeny: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowsetNotify.VTable, self.vtable).OnFieldChange(@ptrCast(*const IRowsetNotify, self), pRowset, hRow, cColumns, rgColumns, eReason, ePhase, fCantDeny);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowsetNotify_OnRowChange(self: *const T, pRowset: *IRowset, cRows: u32, rghRows: [*]const ?*c_void, eReason: u32, ePhase: u32, fCantDeny: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowsetNotify.VTable, self.vtable).OnRowChange(@ptrCast(*const IRowsetNotify, self), pRowset, cRows, rghRows, eReason, ePhase, fCantDeny);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowsetNotify_OnRowsetChange(self: *const T, pRowset: *IRowset, eReason: u32, ePhase: u32, fCantDeny: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowsetNotify.VTable, self.vtable).OnRowsetChange(@ptrCast(*const IRowsetNotify, self), pRowset, eReason, ePhase, fCantDeny);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DBSEEKENUM = extern enum(i32) {
    DBSEEK_INVALID = 0,
    DBSEEK_FIRSTEQ = 1,
    DBSEEK_LASTEQ = 2,
    DBSEEK_AFTEREQ = 4,
    DBSEEK_AFTER = 8,
    DBSEEK_BEFOREEQ = 16,
    DBSEEK_BEFORE = 32,
};
pub const DBSEEK_INVALID = DBSEEKENUM.DBSEEK_INVALID;
pub const DBSEEK_FIRSTEQ = DBSEEKENUM.DBSEEK_FIRSTEQ;
pub const DBSEEK_LASTEQ = DBSEEKENUM.DBSEEK_LASTEQ;
pub const DBSEEK_AFTEREQ = DBSEEKENUM.DBSEEK_AFTEREQ;
pub const DBSEEK_AFTER = DBSEEKENUM.DBSEEK_AFTER;
pub const DBSEEK_BEFOREEQ = DBSEEKENUM.DBSEEK_BEFOREEQ;
pub const DBSEEK_BEFORE = DBSEEKENUM.DBSEEK_BEFORE;

pub const DBRANGEENUM = extern enum(i32) {
    DBRANGE_INCLUSIVESTART = 0,
    DBRANGE_INCLUSIVEEND = 0,
    DBRANGE_EXCLUSIVESTART = 1,
    DBRANGE_EXCLUSIVEEND = 2,
    DBRANGE_EXCLUDENULLS = 4,
    DBRANGE_PREFIX = 8,
    DBRANGE_MATCH = 16,
};
pub const DBRANGE_INCLUSIVESTART = DBRANGEENUM.DBRANGE_INCLUSIVESTART;
pub const DBRANGE_INCLUSIVEEND = DBRANGEENUM.DBRANGE_INCLUSIVEEND;
pub const DBRANGE_EXCLUSIVESTART = DBRANGEENUM.DBRANGE_EXCLUSIVESTART;
pub const DBRANGE_EXCLUSIVEEND = DBRANGEENUM.DBRANGE_EXCLUSIVEEND;
pub const DBRANGE_EXCLUDENULLS = DBRANGEENUM.DBRANGE_EXCLUDENULLS;
pub const DBRANGE_PREFIX = DBRANGEENUM.DBRANGE_PREFIX;
pub const DBRANGE_MATCH = DBRANGEENUM.DBRANGE_MATCH;

pub const DBRANGEENUM20 = extern enum(i32) {
    DBRANGE_MATCH_N_SHIFT = 24,
    DBRANGE_MATCH_N_MASK = 255,
};
pub const DBRANGE_MATCH_N_SHIFT = DBRANGEENUM20.DBRANGE_MATCH_N_SHIFT;
pub const DBRANGE_MATCH_N_MASK = DBRANGEENUM20.DBRANGE_MATCH_N_MASK;

const IID_IRowsetIndex_Value = @import("../zig.zig").Guid.initString("0C733A82-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IRowsetIndex = &IID_IRowsetIndex_Value;
pub const IRowsetIndex = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIndexInfo: fn(
            self: *const IRowsetIndex,
            pcKeyColumns: *u32,
            prgIndexColumnDesc: **DBINDEXCOLUMNDESC,
            pcIndexPropertySets: *u32,
            prgIndexPropertySets: **DBPROPSET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Seek: fn(
            self: *const IRowsetIndex,
            hAccessor: ?*c_void,
            cKeyValues: u32,
            pData: *c_void,
            dwSeekOptions: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRange: fn(
            self: *const IRowsetIndex,
            hAccessor: ?*c_void,
            cStartKeyColumns: u32,
            pStartData: *c_void,
            cEndKeyColumns: u32,
            pEndData: *c_void,
            dwRangeOptions: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowsetIndex_GetIndexInfo(self: *const T, pcKeyColumns: *u32, prgIndexColumnDesc: **DBINDEXCOLUMNDESC, pcIndexPropertySets: *u32, prgIndexPropertySets: **DBPROPSET) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowsetIndex.VTable, self.vtable).GetIndexInfo(@ptrCast(*const IRowsetIndex, self), pcKeyColumns, prgIndexColumnDesc, pcIndexPropertySets, prgIndexPropertySets);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowsetIndex_Seek(self: *const T, hAccessor: ?*c_void, cKeyValues: u32, pData: *c_void, dwSeekOptions: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowsetIndex.VTable, self.vtable).Seek(@ptrCast(*const IRowsetIndex, self), hAccessor, cKeyValues, pData, dwSeekOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowsetIndex_SetRange(self: *const T, hAccessor: ?*c_void, cStartKeyColumns: u32, pStartData: *c_void, cEndKeyColumns: u32, pEndData: *c_void, dwRangeOptions: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowsetIndex.VTable, self.vtable).SetRange(@ptrCast(*const IRowsetIndex, self), hAccessor, cStartKeyColumns, pStartData, cEndKeyColumns, pEndData, dwRangeOptions);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICommand_Value = @import("../zig.zig").Guid.initString("0C733A63-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_ICommand = &IID_ICommand_Value;
pub const ICommand = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Cancel: fn(
            self: *const ICommand,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Execute: fn(
            self: *const ICommand,
            pUnkOuter: ?*IUnknown,
            riid: *const Guid,
            pParams: ?*DBPARAMS,
            pcRowsAffected: ?*i32,
            ppRowset: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDBSession: fn(
            self: *const ICommand,
            riid: *const Guid,
            ppSession: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICommand_Cancel(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICommand.VTable, self.vtable).Cancel(@ptrCast(*const ICommand, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICommand_Execute(self: *const T, pUnkOuter: ?*IUnknown, riid: *const Guid, pParams: ?*DBPARAMS, pcRowsAffected: ?*i32, ppRowset: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICommand.VTable, self.vtable).Execute(@ptrCast(*const ICommand, self), pUnkOuter, riid, pParams, pcRowsAffected, ppRowset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICommand_GetDBSession(self: *const T, riid: *const Guid, ppSession: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICommand.VTable, self.vtable).GetDBSession(@ptrCast(*const ICommand, self), riid, ppSession);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DBRESULTFLAGENUM = extern enum(i32) {
    DBRESULTFLAG_DEFAULT = 0,
    DBRESULTFLAG_ROWSET = 1,
    DBRESULTFLAG_ROW = 2,
};
pub const DBRESULTFLAG_DEFAULT = DBRESULTFLAGENUM.DBRESULTFLAG_DEFAULT;
pub const DBRESULTFLAG_ROWSET = DBRESULTFLAGENUM.DBRESULTFLAG_ROWSET;
pub const DBRESULTFLAG_ROW = DBRESULTFLAGENUM.DBRESULTFLAG_ROW;

const IID_IMultipleResults_Value = @import("../zig.zig").Guid.initString("0C733A90-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IMultipleResults = &IID_IMultipleResults_Value;
pub const IMultipleResults = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetResult: fn(
            self: *const IMultipleResults,
            pUnkOuter: ?*IUnknown,
            lResultFlag: i32,
            riid: *const Guid,
            pcRowsAffected: ?*i32,
            ppRowset: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultipleResults_GetResult(self: *const T, pUnkOuter: ?*IUnknown, lResultFlag: i32, riid: *const Guid, pcRowsAffected: ?*i32, ppRowset: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMultipleResults.VTable, self.vtable).GetResult(@ptrCast(*const IMultipleResults, self), pUnkOuter, lResultFlag, riid, pcRowsAffected, ppRowset);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DBCONVERTFLAGSENUM = extern enum(i32) {
    DBCONVERTFLAGS_COLUMN = 0,
    DBCONVERTFLAGS_PARAMETER = 1,
};
pub const DBCONVERTFLAGS_COLUMN = DBCONVERTFLAGSENUM.DBCONVERTFLAGS_COLUMN;
pub const DBCONVERTFLAGS_PARAMETER = DBCONVERTFLAGSENUM.DBCONVERTFLAGS_PARAMETER;

pub const DBCONVERTFLAGSENUM20 = extern enum(i32) {
    DBCONVERTFLAGS_ISLONG = 2,
    DBCONVERTFLAGS_ISFIXEDLENGTH = 4,
    DBCONVERTFLAGS_FROMVARIANT = 8,
};
pub const DBCONVERTFLAGS_ISLONG = DBCONVERTFLAGSENUM20.DBCONVERTFLAGS_ISLONG;
pub const DBCONVERTFLAGS_ISFIXEDLENGTH = DBCONVERTFLAGSENUM20.DBCONVERTFLAGS_ISFIXEDLENGTH;
pub const DBCONVERTFLAGS_FROMVARIANT = DBCONVERTFLAGSENUM20.DBCONVERTFLAGS_FROMVARIANT;

const IID_IConvertType_Value = @import("../zig.zig").Guid.initString("0C733A88-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IConvertType = &IID_IConvertType_Value;
pub const IConvertType = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CanConvert: fn(
            self: *const IConvertType,
            wFromType: u16,
            wToType: u16,
            dwConvertFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConvertType_CanConvert(self: *const T, wFromType: u16, wToType: u16, dwConvertFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConvertType.VTable, self.vtable).CanConvert(@ptrCast(*const IConvertType, self), wFromType, wToType, dwConvertFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICommandPrepare_Value = @import("../zig.zig").Guid.initString("0C733A26-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_ICommandPrepare = &IID_ICommandPrepare_Value;
pub const ICommandPrepare = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Prepare: fn(
            self: *const ICommandPrepare,
            cExpectedRuns: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unprepare: fn(
            self: *const ICommandPrepare,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICommandPrepare_Prepare(self: *const T, cExpectedRuns: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICommandPrepare.VTable, self.vtable).Prepare(@ptrCast(*const ICommandPrepare, self), cExpectedRuns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICommandPrepare_Unprepare(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICommandPrepare.VTable, self.vtable).Unprepare(@ptrCast(*const ICommandPrepare, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICommandProperties_Value = @import("../zig.zig").Guid.initString("0C733A79-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_ICommandProperties = &IID_ICommandProperties_Value;
pub const ICommandProperties = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperties: fn(
            self: *const ICommandProperties,
            cPropertyIDSets: u32,
            rgPropertyIDSets: ?[*]const DBPROPIDSET,
            pcPropertySets: *u32,
            prgPropertySets: ?*?*DBPROPSET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperties: fn(
            self: *const ICommandProperties,
            cPropertySets: u32,
            rgPropertySets: [*]DBPROPSET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICommandProperties_GetProperties(self: *const T, cPropertyIDSets: u32, rgPropertyIDSets: ?[*]const DBPROPIDSET, pcPropertySets: *u32, prgPropertySets: ?*?*DBPROPSET) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICommandProperties.VTable, self.vtable).GetProperties(@ptrCast(*const ICommandProperties, self), cPropertyIDSets, rgPropertyIDSets, pcPropertySets, prgPropertySets);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICommandProperties_SetProperties(self: *const T, cPropertySets: u32, rgPropertySets: [*]DBPROPSET) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICommandProperties.VTable, self.vtable).SetProperties(@ptrCast(*const ICommandProperties, self), cPropertySets, rgPropertySets);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICommandText_Value = @import("../zig.zig").Guid.initString("0C733A27-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_ICommandText = &IID_ICommandText_Value;
pub const ICommandText = extern struct {
    pub const VTable = extern struct {
        base: ICommand.VTable,
        GetCommandText: fn(
            self: *const ICommandText,
            pguidDialect: ?*Guid,
            ppwszCommand: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCommandText: fn(
            self: *const ICommandText,
            rguidDialect: *const Guid,
            pwszCommand: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ICommand.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICommandText_GetCommandText(self: *const T, pguidDialect: ?*Guid, ppwszCommand: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICommandText.VTable, self.vtable).GetCommandText(@ptrCast(*const ICommandText, self), pguidDialect, ppwszCommand);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICommandText_SetCommandText(self: *const T, rguidDialect: *const Guid, pwszCommand: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICommandText.VTable, self.vtable).SetCommandText(@ptrCast(*const ICommandText, self), rguidDialect, pwszCommand);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DBPARAMBINDINFO = extern struct {
    pwszDataSourceType: PWSTR,
    pwszName: PWSTR,
    ulParamSize: u32,
    dwFlags: u32,
    bPrecision: u8,
    bScale: u8,
};

const IID_ICommandWithParameters_Value = @import("../zig.zig").Guid.initString("0C733A64-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_ICommandWithParameters = &IID_ICommandWithParameters_Value;
pub const ICommandWithParameters = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetParameterInfo: fn(
            self: *const ICommandWithParameters,
            pcParams: *u32,
            prgParamInfo: ?*?*DBPARAMINFO,
            ppNamesBuffer: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MapParameterNames: fn(
            self: *const ICommandWithParameters,
            cParamNames: u32,
            rgParamNames: [*]*PWSTR,
            rgParamOrdinals: [*]i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetParameterInfo: fn(
            self: *const ICommandWithParameters,
            cParams: u32,
            rgParamOrdinals: ?[*]const u32,
            rgParamBindInfo: ?[*]const DBPARAMBINDINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICommandWithParameters_GetParameterInfo(self: *const T, pcParams: *u32, prgParamInfo: ?*?*DBPARAMINFO, ppNamesBuffer: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICommandWithParameters.VTable, self.vtable).GetParameterInfo(@ptrCast(*const ICommandWithParameters, self), pcParams, prgParamInfo, ppNamesBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICommandWithParameters_MapParameterNames(self: *const T, cParamNames: u32, rgParamNames: [*]*PWSTR, rgParamOrdinals: [*]i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICommandWithParameters.VTable, self.vtable).MapParameterNames(@ptrCast(*const ICommandWithParameters, self), cParamNames, rgParamNames, rgParamOrdinals);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICommandWithParameters_SetParameterInfo(self: *const T, cParams: u32, rgParamOrdinals: ?[*]const u32, rgParamBindInfo: ?[*]const DBPARAMBINDINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICommandWithParameters.VTable, self.vtable).SetParameterInfo(@ptrCast(*const ICommandWithParameters, self), cParams, rgParamOrdinals, rgParamBindInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IColumnsRowset_Value = @import("../zig.zig").Guid.initString("0C733A10-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IColumnsRowset = &IID_IColumnsRowset_Value;
pub const IColumnsRowset = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAvailableColumns: fn(
            self: *const IColumnsRowset,
            pcOptColumns: *u32,
            prgOptColumns: **DBID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColumnsRowset: fn(
            self: *const IColumnsRowset,
            pUnkOuter: ?*IUnknown,
            cOptColumns: u32,
            rgOptColumns: [*]const DBID,
            riid: *const Guid,
            cPropertySets: u32,
            rgPropertySets: ?[*]DBPROPSET,
            ppColRowset: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IColumnsRowset_GetAvailableColumns(self: *const T, pcOptColumns: *u32, prgOptColumns: **DBID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IColumnsRowset.VTable, self.vtable).GetAvailableColumns(@ptrCast(*const IColumnsRowset, self), pcOptColumns, prgOptColumns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IColumnsRowset_GetColumnsRowset(self: *const T, pUnkOuter: ?*IUnknown, cOptColumns: u32, rgOptColumns: [*]const DBID, riid: *const Guid, cPropertySets: u32, rgPropertySets: ?[*]DBPROPSET, ppColRowset: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IColumnsRowset.VTable, self.vtable).GetColumnsRowset(@ptrCast(*const IColumnsRowset, self), pUnkOuter, cOptColumns, rgOptColumns, riid, cPropertySets, rgPropertySets, ppColRowset);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IColumnsInfo_Value = @import("../zig.zig").Guid.initString("0C733A11-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IColumnsInfo = &IID_IColumnsInfo_Value;
pub const IColumnsInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetColumnInfo: fn(
            self: *const IColumnsInfo,
            pcColumns: *u32,
            prgInfo: ?*?*DBCOLUMNINFO,
            ppStringsBuffer: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MapColumnIDs: fn(
            self: *const IColumnsInfo,
            cColumnIDs: u32,
            rgColumnIDs: ?[*]const DBID,
            rgColumns: ?[*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IColumnsInfo_GetColumnInfo(self: *const T, pcColumns: *u32, prgInfo: ?*?*DBCOLUMNINFO, ppStringsBuffer: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IColumnsInfo.VTable, self.vtable).GetColumnInfo(@ptrCast(*const IColumnsInfo, self), pcColumns, prgInfo, ppStringsBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IColumnsInfo_MapColumnIDs(self: *const T, cColumnIDs: u32, rgColumnIDs: ?[*]const DBID, rgColumns: ?[*]u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IColumnsInfo.VTable, self.vtable).MapColumnIDs(@ptrCast(*const IColumnsInfo, self), cColumnIDs, rgColumnIDs, rgColumns);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDBCreateCommand_Value = @import("../zig.zig").Guid.initString("0C733A1D-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IDBCreateCommand = &IID_IDBCreateCommand_Value;
pub const IDBCreateCommand = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateCommand: fn(
            self: *const IDBCreateCommand,
            pUnkOuter: ?*IUnknown,
            riid: *const Guid,
            ppCommand: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDBCreateCommand_CreateCommand(self: *const T, pUnkOuter: ?*IUnknown, riid: *const Guid, ppCommand: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDBCreateCommand.VTable, self.vtable).CreateCommand(@ptrCast(*const IDBCreateCommand, self), pUnkOuter, riid, ppCommand);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDBCreateSession_Value = @import("../zig.zig").Guid.initString("0C733A5D-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IDBCreateSession = &IID_IDBCreateSession_Value;
pub const IDBCreateSession = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateSession: fn(
            self: *const IDBCreateSession,
            pUnkOuter: ?*IUnknown,
            riid: *const Guid,
            ppDBSession: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDBCreateSession_CreateSession(self: *const T, pUnkOuter: ?*IUnknown, riid: *const Guid, ppDBSession: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDBCreateSession.VTable, self.vtable).CreateSession(@ptrCast(*const IDBCreateSession, self), pUnkOuter, riid, ppDBSession);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DBSOURCETYPEENUM = extern enum(i32) {
    DBSOURCETYPE_DATASOURCE = 1,
    DBSOURCETYPE_ENUMERATOR = 2,
};
pub const DBSOURCETYPE_DATASOURCE = DBSOURCETYPEENUM.DBSOURCETYPE_DATASOURCE;
pub const DBSOURCETYPE_ENUMERATOR = DBSOURCETYPEENUM.DBSOURCETYPE_ENUMERATOR;

pub const DBSOURCETYPEENUM20 = extern enum(i32) {
    DBSOURCETYPE_DATASOURCE_TDP = 1,
    DBSOURCETYPE_DATASOURCE_MDP = 3,
};
pub const DBSOURCETYPE_DATASOURCE_TDP = DBSOURCETYPEENUM20.DBSOURCETYPE_DATASOURCE_TDP;
pub const DBSOURCETYPE_DATASOURCE_MDP = DBSOURCETYPEENUM20.DBSOURCETYPE_DATASOURCE_MDP;

pub const DBSOURCETYPEENUM25 = extern enum(i32) {
    DBSOURCETYPE_BINDER = 4,
};
pub const DBSOURCETYPE_BINDER = DBSOURCETYPEENUM25.DBSOURCETYPE_BINDER;

const IID_ISourcesRowset_Value = @import("../zig.zig").Guid.initString("0C733A1E-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_ISourcesRowset = &IID_ISourcesRowset_Value;
pub const ISourcesRowset = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSourcesRowset: fn(
            self: *const ISourcesRowset,
            pUnkOuter: ?*IUnknown,
            riid: *const Guid,
            cPropertySets: u32,
            rgProperties: ?[*]DBPROPSET,
            ppSourcesRowset: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISourcesRowset_GetSourcesRowset(self: *const T, pUnkOuter: ?*IUnknown, riid: *const Guid, cPropertySets: u32, rgProperties: ?[*]DBPROPSET, ppSourcesRowset: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISourcesRowset.VTable, self.vtable).GetSourcesRowset(@ptrCast(*const ISourcesRowset, self), pUnkOuter, riid, cPropertySets, rgProperties, ppSourcesRowset);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDBProperties_Value = @import("../zig.zig").Guid.initString("0C733A8A-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IDBProperties = &IID_IDBProperties_Value;
pub const IDBProperties = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperties: fn(
            self: *const IDBProperties,
            cPropertyIDSets: u32,
            rgPropertyIDSets: ?[*]const DBPROPIDSET,
            pcPropertySets: *u32,
            prgPropertySets: ?*?*DBPROPSET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropertyInfo: fn(
            self: *const IDBProperties,
            cPropertyIDSets: u32,
            rgPropertyIDSets: ?[*]const DBPROPIDSET,
            pcPropertyInfoSets: *u32,
            prgPropertyInfoSets: ?*?*DBPROPINFOSET,
            ppDescBuffer: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperties: fn(
            self: *const IDBProperties,
            cPropertySets: u32,
            rgPropertySets: ?[*]DBPROPSET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDBProperties_GetProperties(self: *const T, cPropertyIDSets: u32, rgPropertyIDSets: ?[*]const DBPROPIDSET, pcPropertySets: *u32, prgPropertySets: ?*?*DBPROPSET) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDBProperties.VTable, self.vtable).GetProperties(@ptrCast(*const IDBProperties, self), cPropertyIDSets, rgPropertyIDSets, pcPropertySets, prgPropertySets);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDBProperties_GetPropertyInfo(self: *const T, cPropertyIDSets: u32, rgPropertyIDSets: ?[*]const DBPROPIDSET, pcPropertyInfoSets: *u32, prgPropertyInfoSets: ?*?*DBPROPINFOSET, ppDescBuffer: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDBProperties.VTable, self.vtable).GetPropertyInfo(@ptrCast(*const IDBProperties, self), cPropertyIDSets, rgPropertyIDSets, pcPropertyInfoSets, prgPropertyInfoSets, ppDescBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDBProperties_SetProperties(self: *const T, cPropertySets: u32, rgPropertySets: ?[*]DBPROPSET) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDBProperties.VTable, self.vtable).SetProperties(@ptrCast(*const IDBProperties, self), cPropertySets, rgPropertySets);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDBInitialize_Value = @import("../zig.zig").Guid.initString("0C733A8B-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IDBInitialize = &IID_IDBInitialize_Value;
pub const IDBInitialize = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IDBInitialize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Uninitialize: fn(
            self: *const IDBInitialize,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDBInitialize_Initialize(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDBInitialize.VTable, self.vtable).Initialize(@ptrCast(*const IDBInitialize, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDBInitialize_Uninitialize(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDBInitialize.VTable, self.vtable).Uninitialize(@ptrCast(*const IDBInitialize, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DBLITERALENUM = extern enum(i32) {
    DBLITERAL_INVALID = 0,
    DBLITERAL_BINARY_LITERAL = 1,
    DBLITERAL_CATALOG_NAME = 2,
    DBLITERAL_CATALOG_SEPARATOR = 3,
    DBLITERAL_CHAR_LITERAL = 4,
    DBLITERAL_COLUMN_ALIAS = 5,
    DBLITERAL_COLUMN_NAME = 6,
    DBLITERAL_CORRELATION_NAME = 7,
    DBLITERAL_CURSOR_NAME = 8,
    DBLITERAL_ESCAPE_PERCENT = 9,
    DBLITERAL_ESCAPE_UNDERSCORE = 10,
    DBLITERAL_INDEX_NAME = 11,
    DBLITERAL_LIKE_PERCENT = 12,
    DBLITERAL_LIKE_UNDERSCORE = 13,
    DBLITERAL_PROCEDURE_NAME = 14,
    DBLITERAL_QUOTE = 15,
    DBLITERAL_SCHEMA_NAME = 16,
    DBLITERAL_TABLE_NAME = 17,
    DBLITERAL_TEXT_COMMAND = 18,
    DBLITERAL_USER_NAME = 19,
    DBLITERAL_VIEW_NAME = 20,
};
pub const DBLITERAL_INVALID = DBLITERALENUM.DBLITERAL_INVALID;
pub const DBLITERAL_BINARY_LITERAL = DBLITERALENUM.DBLITERAL_BINARY_LITERAL;
pub const DBLITERAL_CATALOG_NAME = DBLITERALENUM.DBLITERAL_CATALOG_NAME;
pub const DBLITERAL_CATALOG_SEPARATOR = DBLITERALENUM.DBLITERAL_CATALOG_SEPARATOR;
pub const DBLITERAL_CHAR_LITERAL = DBLITERALENUM.DBLITERAL_CHAR_LITERAL;
pub const DBLITERAL_COLUMN_ALIAS = DBLITERALENUM.DBLITERAL_COLUMN_ALIAS;
pub const DBLITERAL_COLUMN_NAME = DBLITERALENUM.DBLITERAL_COLUMN_NAME;
pub const DBLITERAL_CORRELATION_NAME = DBLITERALENUM.DBLITERAL_CORRELATION_NAME;
pub const DBLITERAL_CURSOR_NAME = DBLITERALENUM.DBLITERAL_CURSOR_NAME;
pub const DBLITERAL_ESCAPE_PERCENT = DBLITERALENUM.DBLITERAL_ESCAPE_PERCENT;
pub const DBLITERAL_ESCAPE_UNDERSCORE = DBLITERALENUM.DBLITERAL_ESCAPE_UNDERSCORE;
pub const DBLITERAL_INDEX_NAME = DBLITERALENUM.DBLITERAL_INDEX_NAME;
pub const DBLITERAL_LIKE_PERCENT = DBLITERALENUM.DBLITERAL_LIKE_PERCENT;
pub const DBLITERAL_LIKE_UNDERSCORE = DBLITERALENUM.DBLITERAL_LIKE_UNDERSCORE;
pub const DBLITERAL_PROCEDURE_NAME = DBLITERALENUM.DBLITERAL_PROCEDURE_NAME;
pub const DBLITERAL_QUOTE = DBLITERALENUM.DBLITERAL_QUOTE;
pub const DBLITERAL_SCHEMA_NAME = DBLITERALENUM.DBLITERAL_SCHEMA_NAME;
pub const DBLITERAL_TABLE_NAME = DBLITERALENUM.DBLITERAL_TABLE_NAME;
pub const DBLITERAL_TEXT_COMMAND = DBLITERALENUM.DBLITERAL_TEXT_COMMAND;
pub const DBLITERAL_USER_NAME = DBLITERALENUM.DBLITERAL_USER_NAME;
pub const DBLITERAL_VIEW_NAME = DBLITERALENUM.DBLITERAL_VIEW_NAME;

pub const DBLITERALENUM20 = extern enum(i32) {
    DBLITERAL_CUBE_NAME = 21,
    DBLITERAL_DIMENSION_NAME = 22,
    DBLITERAL_HIERARCHY_NAME = 23,
    DBLITERAL_LEVEL_NAME = 24,
    DBLITERAL_MEMBER_NAME = 25,
    DBLITERAL_PROPERTY_NAME = 26,
    DBLITERAL_SCHEMA_SEPARATOR = 27,
    DBLITERAL_QUOTE_SUFFIX = 28,
};
pub const DBLITERAL_CUBE_NAME = DBLITERALENUM20.DBLITERAL_CUBE_NAME;
pub const DBLITERAL_DIMENSION_NAME = DBLITERALENUM20.DBLITERAL_DIMENSION_NAME;
pub const DBLITERAL_HIERARCHY_NAME = DBLITERALENUM20.DBLITERAL_HIERARCHY_NAME;
pub const DBLITERAL_LEVEL_NAME = DBLITERALENUM20.DBLITERAL_LEVEL_NAME;
pub const DBLITERAL_MEMBER_NAME = DBLITERALENUM20.DBLITERAL_MEMBER_NAME;
pub const DBLITERAL_PROPERTY_NAME = DBLITERALENUM20.DBLITERAL_PROPERTY_NAME;
pub const DBLITERAL_SCHEMA_SEPARATOR = DBLITERALENUM20.DBLITERAL_SCHEMA_SEPARATOR;
pub const DBLITERAL_QUOTE_SUFFIX = DBLITERALENUM20.DBLITERAL_QUOTE_SUFFIX;

pub const DBLITERALENUM21 = extern enum(i32) {
    DBLITERAL_ESCAPE_PERCENT_SUFFIX = 29,
    DBLITERAL_ESCAPE_UNDERSCORE_SUFFIX = 30,
};
pub const DBLITERAL_ESCAPE_PERCENT_SUFFIX = DBLITERALENUM21.DBLITERAL_ESCAPE_PERCENT_SUFFIX;
pub const DBLITERAL_ESCAPE_UNDERSCORE_SUFFIX = DBLITERALENUM21.DBLITERAL_ESCAPE_UNDERSCORE_SUFFIX;

pub const DBLITERALINFO = extern struct {
    pwszLiteralValue: PWSTR,
    pwszInvalidChars: PWSTR,
    pwszInvalidStartingChars: PWSTR,
    lt: u32,
    fSupported: BOOL,
    cchMaxLen: u32,
};

const IID_IDBInfo_Value = @import("../zig.zig").Guid.initString("0C733A89-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IDBInfo = &IID_IDBInfo_Value;
pub const IDBInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetKeywords: fn(
            self: *const IDBInfo,
            ppwszKeywords: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLiteralInfo: fn(
            self: *const IDBInfo,
            cLiterals: u32,
            rgLiterals: ?[*]const u32,
            pcLiteralInfo: *u32,
            prgLiteralInfo: **DBLITERALINFO,
            ppCharBuffer: **u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDBInfo_GetKeywords(self: *const T, ppwszKeywords: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDBInfo.VTable, self.vtable).GetKeywords(@ptrCast(*const IDBInfo, self), ppwszKeywords);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDBInfo_GetLiteralInfo(self: *const T, cLiterals: u32, rgLiterals: ?[*]const u32, pcLiteralInfo: *u32, prgLiteralInfo: **DBLITERALINFO, ppCharBuffer: **u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDBInfo.VTable, self.vtable).GetLiteralInfo(@ptrCast(*const IDBInfo, self), cLiterals, rgLiterals, pcLiteralInfo, prgLiteralInfo, ppCharBuffer);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDBDataSourceAdmin_Value = @import("../zig.zig").Guid.initString("0C733A7A-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IDBDataSourceAdmin = &IID_IDBDataSourceAdmin_Value;
pub const IDBDataSourceAdmin = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateDataSource: fn(
            self: *const IDBDataSourceAdmin,
            cPropertySets: u32,
            rgPropertySets: ?[*]DBPROPSET,
            pUnkOuter: ?*IUnknown,
            riid: *const Guid,
            ppDBSession: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DestroyDataSource: fn(
            self: *const IDBDataSourceAdmin,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCreationProperties: fn(
            self: *const IDBDataSourceAdmin,
            cPropertyIDSets: u32,
            rgPropertyIDSets: ?[*]const DBPROPIDSET,
            pcPropertyInfoSets: *u32,
            prgPropertyInfoSets: ?*?*DBPROPINFOSET,
            ppDescBuffer: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ModifyDataSource: fn(
            self: *const IDBDataSourceAdmin,
            cPropertySets: u32,
            rgPropertySets: ?[*]DBPROPSET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDBDataSourceAdmin_CreateDataSource(self: *const T, cPropertySets: u32, rgPropertySets: ?[*]DBPROPSET, pUnkOuter: ?*IUnknown, riid: *const Guid, ppDBSession: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDBDataSourceAdmin.VTable, self.vtable).CreateDataSource(@ptrCast(*const IDBDataSourceAdmin, self), cPropertySets, rgPropertySets, pUnkOuter, riid, ppDBSession);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDBDataSourceAdmin_DestroyDataSource(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDBDataSourceAdmin.VTable, self.vtable).DestroyDataSource(@ptrCast(*const IDBDataSourceAdmin, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDBDataSourceAdmin_GetCreationProperties(self: *const T, cPropertyIDSets: u32, rgPropertyIDSets: ?[*]const DBPROPIDSET, pcPropertyInfoSets: *u32, prgPropertyInfoSets: ?*?*DBPROPINFOSET, ppDescBuffer: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDBDataSourceAdmin.VTable, self.vtable).GetCreationProperties(@ptrCast(*const IDBDataSourceAdmin, self), cPropertyIDSets, rgPropertyIDSets, pcPropertyInfoSets, prgPropertyInfoSets, ppDescBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDBDataSourceAdmin_ModifyDataSource(self: *const T, cPropertySets: u32, rgPropertySets: ?[*]DBPROPSET) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDBDataSourceAdmin.VTable, self.vtable).ModifyDataSource(@ptrCast(*const IDBDataSourceAdmin, self), cPropertySets, rgPropertySets);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDBAsynchNotify_Value = @import("../zig.zig").Guid.initString("0C733A96-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IDBAsynchNotify = &IID_IDBAsynchNotify_Value;
pub const IDBAsynchNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnLowResource: fn(
            self: *const IDBAsynchNotify,
            dwReserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnProgress: fn(
            self: *const IDBAsynchNotify,
            hChapter: ?*c_void,
            eOperation: u32,
            ulProgress: u32,
            ulProgressMax: u32,
            eAsynchPhase: u32,
            pwszStatusText: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnStop: fn(
            self: *const IDBAsynchNotify,
            hChapter: ?*c_void,
            eOperation: u32,
            hrStatus: HRESULT,
            pwszStatusText: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDBAsynchNotify_OnLowResource(self: *const T, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDBAsynchNotify.VTable, self.vtable).OnLowResource(@ptrCast(*const IDBAsynchNotify, self), dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDBAsynchNotify_OnProgress(self: *const T, hChapter: ?*c_void, eOperation: u32, ulProgress: u32, ulProgressMax: u32, eAsynchPhase: u32, pwszStatusText: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDBAsynchNotify.VTable, self.vtable).OnProgress(@ptrCast(*const IDBAsynchNotify, self), hChapter, eOperation, ulProgress, ulProgressMax, eAsynchPhase, pwszStatusText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDBAsynchNotify_OnStop(self: *const T, hChapter: ?*c_void, eOperation: u32, hrStatus: HRESULT, pwszStatusText: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDBAsynchNotify.VTable, self.vtable).OnStop(@ptrCast(*const IDBAsynchNotify, self), hChapter, eOperation, hrStatus, pwszStatusText);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDBAsynchStatus_Value = @import("../zig.zig").Guid.initString("0C733A95-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IDBAsynchStatus = &IID_IDBAsynchStatus_Value;
pub const IDBAsynchStatus = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Abort: fn(
            self: *const IDBAsynchStatus,
            hChapter: ?*c_void,
            eOperation: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatus: fn(
            self: *const IDBAsynchStatus,
            hChapter: ?*c_void,
            eOperation: u32,
            pulProgress: ?*u32,
            pulProgressMax: ?*u32,
            peAsynchPhase: *u32,
            ppwszStatusText: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDBAsynchStatus_Abort(self: *const T, hChapter: ?*c_void, eOperation: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDBAsynchStatus.VTable, self.vtable).Abort(@ptrCast(*const IDBAsynchStatus, self), hChapter, eOperation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDBAsynchStatus_GetStatus(self: *const T, hChapter: ?*c_void, eOperation: u32, pulProgress: ?*u32, pulProgressMax: ?*u32, peAsynchPhase: *u32, ppwszStatusText: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDBAsynchStatus.VTable, self.vtable).GetStatus(@ptrCast(*const IDBAsynchStatus, self), hChapter, eOperation, pulProgress, pulProgressMax, peAsynchPhase, ppwszStatusText);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISessionProperties_Value = @import("../zig.zig").Guid.initString("0C733A85-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_ISessionProperties = &IID_ISessionProperties_Value;
pub const ISessionProperties = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperties: fn(
            self: *const ISessionProperties,
            cPropertyIDSets: u32,
            rgPropertyIDSets: ?[*]const DBPROPIDSET,
            pcPropertySets: *u32,
            prgPropertySets: ?*?*DBPROPSET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperties: fn(
            self: *const ISessionProperties,
            cPropertySets: u32,
            rgPropertySets: ?[*]DBPROPSET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISessionProperties_GetProperties(self: *const T, cPropertyIDSets: u32, rgPropertyIDSets: ?[*]const DBPROPIDSET, pcPropertySets: *u32, prgPropertySets: ?*?*DBPROPSET) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISessionProperties.VTable, self.vtable).GetProperties(@ptrCast(*const ISessionProperties, self), cPropertyIDSets, rgPropertyIDSets, pcPropertySets, prgPropertySets);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISessionProperties_SetProperties(self: *const T, cPropertySets: u32, rgPropertySets: ?[*]DBPROPSET) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISessionProperties.VTable, self.vtable).SetProperties(@ptrCast(*const ISessionProperties, self), cPropertySets, rgPropertySets);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IIndexDefinition_Value = @import("../zig.zig").Guid.initString("0C733A68-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IIndexDefinition = &IID_IIndexDefinition_Value;
pub const IIndexDefinition = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateIndex: fn(
            self: *const IIndexDefinition,
            pTableID: *DBID,
            pIndexID: ?*DBID,
            cIndexColumnDescs: u32,
            rgIndexColumnDescs: [*]const DBINDEXCOLUMNDESC,
            cPropertySets: u32,
            rgPropertySets: [*]DBPROPSET,
            ppIndexID: ?*?*DBID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DropIndex: fn(
            self: *const IIndexDefinition,
            pTableID: *DBID,
            pIndexID: ?*DBID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIndexDefinition_CreateIndex(self: *const T, pTableID: *DBID, pIndexID: ?*DBID, cIndexColumnDescs: u32, rgIndexColumnDescs: [*]const DBINDEXCOLUMNDESC, cPropertySets: u32, rgPropertySets: [*]DBPROPSET, ppIndexID: ?*?*DBID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIndexDefinition.VTable, self.vtable).CreateIndex(@ptrCast(*const IIndexDefinition, self), pTableID, pIndexID, cIndexColumnDescs, rgIndexColumnDescs, cPropertySets, rgPropertySets, ppIndexID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIndexDefinition_DropIndex(self: *const T, pTableID: *DBID, pIndexID: ?*DBID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIndexDefinition.VTable, self.vtable).DropIndex(@ptrCast(*const IIndexDefinition, self), pTableID, pIndexID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITableDefinition_Value = @import("../zig.zig").Guid.initString("0C733A86-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_ITableDefinition = &IID_ITableDefinition_Value;
pub const ITableDefinition = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateTable: fn(
            self: *const ITableDefinition,
            pUnkOuter: ?*IUnknown,
            pTableID: ?*DBID,
            cColumnDescs: u32,
            rgColumnDescs: ?[*]const DBCOLUMNDESC,
            riid: *const Guid,
            cPropertySets: u32,
            rgPropertySets: ?[*]DBPROPSET,
            ppTableID: ?*?*DBID,
            ppRowset: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DropTable: fn(
            self: *const ITableDefinition,
            pTableID: *DBID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddColumn: fn(
            self: *const ITableDefinition,
            pTableID: *DBID,
            pColumnDesc: *DBCOLUMNDESC,
            ppColumnID: ?*?*DBID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DropColumn: fn(
            self: *const ITableDefinition,
            pTableID: *DBID,
            pColumnID: *DBID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITableDefinition_CreateTable(self: *const T, pUnkOuter: ?*IUnknown, pTableID: ?*DBID, cColumnDescs: u32, rgColumnDescs: ?[*]const DBCOLUMNDESC, riid: *const Guid, cPropertySets: u32, rgPropertySets: ?[*]DBPROPSET, ppTableID: ?*?*DBID, ppRowset: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITableDefinition.VTable, self.vtable).CreateTable(@ptrCast(*const ITableDefinition, self), pUnkOuter, pTableID, cColumnDescs, rgColumnDescs, riid, cPropertySets, rgPropertySets, ppTableID, ppRowset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITableDefinition_DropTable(self: *const T, pTableID: *DBID) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITableDefinition.VTable, self.vtable).DropTable(@ptrCast(*const ITableDefinition, self), pTableID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITableDefinition_AddColumn(self: *const T, pTableID: *DBID, pColumnDesc: *DBCOLUMNDESC, ppColumnID: ?*?*DBID) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITableDefinition.VTable, self.vtable).AddColumn(@ptrCast(*const ITableDefinition, self), pTableID, pColumnDesc, ppColumnID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITableDefinition_DropColumn(self: *const T, pTableID: *DBID, pColumnID: *DBID) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITableDefinition.VTable, self.vtable).DropColumn(@ptrCast(*const ITableDefinition, self), pTableID, pColumnID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IOpenRowset_Value = @import("../zig.zig").Guid.initString("0C733A69-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IOpenRowset = &IID_IOpenRowset_Value;
pub const IOpenRowset = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OpenRowset: fn(
            self: *const IOpenRowset,
            pUnkOuter: ?*IUnknown,
            pTableID: ?*DBID,
            pIndexID: ?*DBID,
            riid: *const Guid,
            cPropertySets: u32,
            rgPropertySets: ?[*]DBPROPSET,
            ppRowset: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpenRowset_OpenRowset(self: *const T, pUnkOuter: ?*IUnknown, pTableID: ?*DBID, pIndexID: ?*DBID, riid: *const Guid, cPropertySets: u32, rgPropertySets: ?[*]DBPROPSET, ppRowset: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpenRowset.VTable, self.vtable).OpenRowset(@ptrCast(*const IOpenRowset, self), pUnkOuter, pTableID, pIndexID, riid, cPropertySets, rgPropertySets, ppRowset);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDBSchemaRowset_Value = @import("../zig.zig").Guid.initString("0C733A7B-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IDBSchemaRowset = &IID_IDBSchemaRowset_Value;
pub const IDBSchemaRowset = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRowset: fn(
            self: *const IDBSchemaRowset,
            pUnkOuter: ?*IUnknown,
            rguidSchema: *const Guid,
            cRestrictions: u32,
            rgRestrictions: ?[*]const VARIANT,
            riid: *const Guid,
            cPropertySets: u32,
            rgPropertySets: ?[*]DBPROPSET,
            ppRowset: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSchemas: fn(
            self: *const IDBSchemaRowset,
            pcSchemas: *u32,
            prgSchemas: ?*?*Guid,
            prgRestrictionSupport: ?*?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDBSchemaRowset_GetRowset(self: *const T, pUnkOuter: ?*IUnknown, rguidSchema: *const Guid, cRestrictions: u32, rgRestrictions: ?[*]const VARIANT, riid: *const Guid, cPropertySets: u32, rgPropertySets: ?[*]DBPROPSET, ppRowset: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDBSchemaRowset.VTable, self.vtable).GetRowset(@ptrCast(*const IDBSchemaRowset, self), pUnkOuter, rguidSchema, cRestrictions, rgRestrictions, riid, cPropertySets, rgPropertySets, ppRowset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDBSchemaRowset_GetSchemas(self: *const T, pcSchemas: *u32, prgSchemas: ?*?*Guid, prgRestrictionSupport: ?*?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDBSchemaRowset.VTable, self.vtable).GetSchemas(@ptrCast(*const IDBSchemaRowset, self), pcSchemas, prgSchemas, prgRestrictionSupport);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMDDataset_Value = @import("../zig.zig").Guid.initString("A07CCCD1-8148-11D0-87BB-00C04FC33942");
pub const IID_IMDDataset = &IID_IMDDataset_Value;
pub const IMDDataset = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FreeAxisInfo: fn(
            self: *const IMDDataset,
            cAxes: u32,
            rgAxisInfo: *MDAXISINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAxisInfo: fn(
            self: *const IMDDataset,
            pcAxes: *u32,
            prgAxisInfo: **MDAXISINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAxisRowset: fn(
            self: *const IMDDataset,
            pUnkOuter: *IUnknown,
            iAxis: u32,
            riid: *const Guid,
            cPropertySets: u32,
            rgPropertySets: *DBPROPSET,
            ppRowset: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellData: fn(
            self: *const IMDDataset,
            hAccessor: ?*c_void,
            ulStartCell: u32,
            ulEndCell: u32,
            pData: *c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpecification: fn(
            self: *const IMDDataset,
            riid: *const Guid,
            ppSpecification: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMDDataset_FreeAxisInfo(self: *const T, cAxes: u32, rgAxisInfo: *MDAXISINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMDDataset.VTable, self.vtable).FreeAxisInfo(@ptrCast(*const IMDDataset, self), cAxes, rgAxisInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMDDataset_GetAxisInfo(self: *const T, pcAxes: *u32, prgAxisInfo: **MDAXISINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMDDataset.VTable, self.vtable).GetAxisInfo(@ptrCast(*const IMDDataset, self), pcAxes, prgAxisInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMDDataset_GetAxisRowset(self: *const T, pUnkOuter: *IUnknown, iAxis: u32, riid: *const Guid, cPropertySets: u32, rgPropertySets: *DBPROPSET, ppRowset: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMDDataset.VTable, self.vtable).GetAxisRowset(@ptrCast(*const IMDDataset, self), pUnkOuter, iAxis, riid, cPropertySets, rgPropertySets, ppRowset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMDDataset_GetCellData(self: *const T, hAccessor: ?*c_void, ulStartCell: u32, ulEndCell: u32, pData: *c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMDDataset.VTable, self.vtable).GetCellData(@ptrCast(*const IMDDataset, self), hAccessor, ulStartCell, ulEndCell, pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMDDataset_GetSpecification(self: *const T, riid: *const Guid, ppSpecification: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMDDataset.VTable, self.vtable).GetSpecification(@ptrCast(*const IMDDataset, self), riid, ppSpecification);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMDFind_Value = @import("../zig.zig").Guid.initString("A07CCCD2-8148-11D0-87BB-00C04FC33942");
pub const IID_IMDFind = &IID_IMDFind_Value;
pub const IMDFind = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FindCell: fn(
            self: *const IMDFind,
            ulStartingOrdinal: u32,
            cMembers: u32,
            rgpwszMember: *PWSTR,
            pulCellOrdinal: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindTuple: fn(
            self: *const IMDFind,
            ulAxisIdentifier: u32,
            ulStartingOrdinal: u32,
            cMembers: u32,
            rgpwszMember: *PWSTR,
            pulTupleOrdinal: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMDFind_FindCell(self: *const T, ulStartingOrdinal: u32, cMembers: u32, rgpwszMember: *PWSTR, pulCellOrdinal: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMDFind.VTable, self.vtable).FindCell(@ptrCast(*const IMDFind, self), ulStartingOrdinal, cMembers, rgpwszMember, pulCellOrdinal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMDFind_FindTuple(self: *const T, ulAxisIdentifier: u32, ulStartingOrdinal: u32, cMembers: u32, rgpwszMember: *PWSTR, pulTupleOrdinal: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMDFind.VTable, self.vtable).FindTuple(@ptrCast(*const IMDFind, self), ulAxisIdentifier, ulStartingOrdinal, cMembers, rgpwszMember, pulTupleOrdinal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMDRangeRowset_Value = @import("../zig.zig").Guid.initString("0C733AA0-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IMDRangeRowset = &IID_IMDRangeRowset_Value;
pub const IMDRangeRowset = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRangeRowset: fn(
            self: *const IMDRangeRowset,
            pUnkOuter: *IUnknown,
            ulStartCell: u32,
            ulEndCell: u32,
            riid: *const Guid,
            cPropertySets: u32,
            rgPropertySets: *DBPROPSET,
            ppRowset: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMDRangeRowset_GetRangeRowset(self: *const T, pUnkOuter: *IUnknown, ulStartCell: u32, ulEndCell: u32, riid: *const Guid, cPropertySets: u32, rgPropertySets: *DBPROPSET, ppRowset: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMDRangeRowset.VTable, self.vtable).GetRangeRowset(@ptrCast(*const IMDRangeRowset, self), pUnkOuter, ulStartCell, ulEndCell, riid, cPropertySets, rgPropertySets, ppRowset);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAlterTable_Value = @import("../zig.zig").Guid.initString("0C733AA5-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IAlterTable = &IID_IAlterTable_Value;
pub const IAlterTable = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AlterColumn: fn(
            self: *const IAlterTable,
            pTableId: *DBID,
            pColumnId: *DBID,
            dwColumnDescFlags: u32,
            pColumnDesc: *DBCOLUMNDESC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AlterTable: fn(
            self: *const IAlterTable,
            pTableId: *DBID,
            pNewTableId: *DBID,
            cPropertySets: u32,
            rgPropertySets: *DBPROPSET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAlterTable_AlterColumn(self: *const T, pTableId: *DBID, pColumnId: *DBID, dwColumnDescFlags: u32, pColumnDesc: *DBCOLUMNDESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAlterTable.VTable, self.vtable).AlterColumn(@ptrCast(*const IAlterTable, self), pTableId, pColumnId, dwColumnDescFlags, pColumnDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAlterTable_AlterTable(self: *const T, pTableId: *DBID, pNewTableId: *DBID, cPropertySets: u32, rgPropertySets: *DBPROPSET) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAlterTable.VTable, self.vtable).AlterTable(@ptrCast(*const IAlterTable, self), pTableId, pNewTableId, cPropertySets, rgPropertySets);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAlterIndex_Value = @import("../zig.zig").Guid.initString("0C733AA6-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IAlterIndex = &IID_IAlterIndex_Value;
pub const IAlterIndex = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AlterIndex: fn(
            self: *const IAlterIndex,
            pTableId: *DBID,
            pIndexId: *DBID,
            pNewIndexId: *DBID,
            cPropertySets: u32,
            rgPropertySets: *DBPROPSET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAlterIndex_AlterIndex(self: *const T, pTableId: *DBID, pIndexId: *DBID, pNewIndexId: *DBID, cPropertySets: u32, rgPropertySets: *DBPROPSET) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAlterIndex.VTable, self.vtable).AlterIndex(@ptrCast(*const IAlterIndex, self), pTableId, pIndexId, pNewIndexId, cPropertySets, rgPropertySets);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetChapterMember_Value = @import("../zig.zig").Guid.initString("0C733AA8-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IRowsetChapterMember = &IID_IRowsetChapterMember_Value;
pub const IRowsetChapterMember = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsRowInChapter: fn(
            self: *const IRowsetChapterMember,
            hChapter: ?*c_void,
            hRow: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowsetChapterMember_IsRowInChapter(self: *const T, hChapter: ?*c_void, hRow: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowsetChapterMember.VTable, self.vtable).IsRowInChapter(@ptrCast(*const IRowsetChapterMember, self), hChapter, hRow);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICommandPersist_Value = @import("../zig.zig").Guid.initString("0C733AA7-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_ICommandPersist = &IID_ICommandPersist_Value;
pub const ICommandPersist = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DeleteCommand: fn(
            self: *const ICommandPersist,
            pCommandID: *DBID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentCommand: fn(
            self: *const ICommandPersist,
            ppCommandID: **DBID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadCommand: fn(
            self: *const ICommandPersist,
            pCommandID: *DBID,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveCommand: fn(
            self: *const ICommandPersist,
            pCommandID: *DBID,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICommandPersist_DeleteCommand(self: *const T, pCommandID: *DBID) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICommandPersist.VTable, self.vtable).DeleteCommand(@ptrCast(*const ICommandPersist, self), pCommandID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICommandPersist_GetCurrentCommand(self: *const T, ppCommandID: **DBID) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICommandPersist.VTable, self.vtable).GetCurrentCommand(@ptrCast(*const ICommandPersist, self), ppCommandID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICommandPersist_LoadCommand(self: *const T, pCommandID: *DBID, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICommandPersist.VTable, self.vtable).LoadCommand(@ptrCast(*const ICommandPersist, self), pCommandID, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICommandPersist_SaveCommand(self: *const T, pCommandID: *DBID, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICommandPersist.VTable, self.vtable).SaveCommand(@ptrCast(*const ICommandPersist, self), pCommandID, dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetRefresh_Value = @import("../zig.zig").Guid.initString("0C733AA9-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IRowsetRefresh = &IID_IRowsetRefresh_Value;
pub const IRowsetRefresh = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RefreshVisibleData: fn(
            self: *const IRowsetRefresh,
            hChapter: ?*c_void,
            cRows: u32,
            rghRows: *const ?*c_void,
            fOverWrite: BOOL,
            pcRowsRefreshed: *u32,
            prghRowsRefreshed: **?*c_void,
            prgRowStatus: **u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastVisibleData: fn(
            self: *const IRowsetRefresh,
            hRow: ?*c_void,
            hAccessor: ?*c_void,
            pData: *c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowsetRefresh_RefreshVisibleData(self: *const T, hChapter: ?*c_void, cRows: u32, rghRows: *const ?*c_void, fOverWrite: BOOL, pcRowsRefreshed: *u32, prghRowsRefreshed: **?*c_void, prgRowStatus: **u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowsetRefresh.VTable, self.vtable).RefreshVisibleData(@ptrCast(*const IRowsetRefresh, self), hChapter, cRows, rghRows, fOverWrite, pcRowsRefreshed, prghRowsRefreshed, prgRowStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowsetRefresh_GetLastVisibleData(self: *const T, hRow: ?*c_void, hAccessor: ?*c_void, pData: *c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowsetRefresh.VTable, self.vtable).GetLastVisibleData(@ptrCast(*const IRowsetRefresh, self), hRow, hAccessor, pData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IParentRowset_Value = @import("../zig.zig").Guid.initString("0C733AAA-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IParentRowset = &IID_IParentRowset_Value;
pub const IParentRowset = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetChildRowset: fn(
            self: *const IParentRowset,
            pUnkOuter: *IUnknown,
            iOrdinal: u32,
            riid: *const Guid,
            ppRowset: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IParentRowset_GetChildRowset(self: *const T, pUnkOuter: *IUnknown, iOrdinal: u32, riid: *const Guid, ppRowset: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IParentRowset.VTable, self.vtable).GetChildRowset(@ptrCast(*const IParentRowset, self), pUnkOuter, iOrdinal, riid, ppRowset);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ERRORINFO = extern struct {
    hrError: HRESULT,
    dwMinor: u32,
    clsid: Guid,
    iid: Guid,
    dispid: i32,
};

const IID_IErrorRecords_Value = @import("../zig.zig").Guid.initString("0C733A67-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IErrorRecords = &IID_IErrorRecords_Value;
pub const IErrorRecords = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddErrorRecord: fn(
            self: *const IErrorRecords,
            pErrorInfo: *ERRORINFO,
            dwLookupID: u32,
            pdispparams: ?*DISPPARAMS,
            punkCustomError: ?*IUnknown,
            dwDynamicErrorID: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBasicErrorInfo: fn(
            self: *const IErrorRecords,
            ulRecordNum: u32,
            pErrorInfo: *ERRORINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCustomErrorObject: fn(
            self: *const IErrorRecords,
            ulRecordNum: u32,
            riid: *const Guid,
            ppObject: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetErrorInfo: fn(
            self: *const IErrorRecords,
            ulRecordNum: u32,
            lcid: u32,
            ppErrorInfo: **IErrorInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetErrorParameters: fn(
            self: *const IErrorRecords,
            ulRecordNum: u32,
            pdispparams: *DISPPARAMS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCount: fn(
            self: *const IErrorRecords,
            pcRecords: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IErrorRecords_AddErrorRecord(self: *const T, pErrorInfo: *ERRORINFO, dwLookupID: u32, pdispparams: ?*DISPPARAMS, punkCustomError: ?*IUnknown, dwDynamicErrorID: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IErrorRecords.VTable, self.vtable).AddErrorRecord(@ptrCast(*const IErrorRecords, self), pErrorInfo, dwLookupID, pdispparams, punkCustomError, dwDynamicErrorID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IErrorRecords_GetBasicErrorInfo(self: *const T, ulRecordNum: u32, pErrorInfo: *ERRORINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IErrorRecords.VTable, self.vtable).GetBasicErrorInfo(@ptrCast(*const IErrorRecords, self), ulRecordNum, pErrorInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IErrorRecords_GetCustomErrorObject(self: *const T, ulRecordNum: u32, riid: *const Guid, ppObject: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IErrorRecords.VTable, self.vtable).GetCustomErrorObject(@ptrCast(*const IErrorRecords, self), ulRecordNum, riid, ppObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IErrorRecords_GetErrorInfo(self: *const T, ulRecordNum: u32, lcid: u32, ppErrorInfo: **IErrorInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IErrorRecords.VTable, self.vtable).GetErrorInfo(@ptrCast(*const IErrorRecords, self), ulRecordNum, lcid, ppErrorInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IErrorRecords_GetErrorParameters(self: *const T, ulRecordNum: u32, pdispparams: *DISPPARAMS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IErrorRecords.VTable, self.vtable).GetErrorParameters(@ptrCast(*const IErrorRecords, self), ulRecordNum, pdispparams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IErrorRecords_GetRecordCount(self: *const T, pcRecords: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IErrorRecords.VTable, self.vtable).GetRecordCount(@ptrCast(*const IErrorRecords, self), pcRecords);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IErrorLookup_Value = @import("../zig.zig").Guid.initString("0C733A66-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IErrorLookup = &IID_IErrorLookup_Value;
pub const IErrorLookup = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetErrorDescription: fn(
            self: *const IErrorLookup,
            hrError: HRESULT,
            dwLookupID: u32,
            pdispparams: *DISPPARAMS,
            lcid: u32,
            pbstrSource: ?*BSTR,
            pbstrDescription: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHelpInfo: fn(
            self: *const IErrorLookup,
            hrError: HRESULT,
            dwLookupID: u32,
            lcid: u32,
            pbstrHelpFile: ?*BSTR,
            pdwHelpContext: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseErrors: fn(
            self: *const IErrorLookup,
            dwDynamicErrorID: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IErrorLookup_GetErrorDescription(self: *const T, hrError: HRESULT, dwLookupID: u32, pdispparams: *DISPPARAMS, lcid: u32, pbstrSource: ?*BSTR, pbstrDescription: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IErrorLookup.VTable, self.vtable).GetErrorDescription(@ptrCast(*const IErrorLookup, self), hrError, dwLookupID, pdispparams, lcid, pbstrSource, pbstrDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IErrorLookup_GetHelpInfo(self: *const T, hrError: HRESULT, dwLookupID: u32, lcid: u32, pbstrHelpFile: ?*BSTR, pdwHelpContext: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IErrorLookup.VTable, self.vtable).GetHelpInfo(@ptrCast(*const IErrorLookup, self), hrError, dwLookupID, lcid, pbstrHelpFile, pdwHelpContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IErrorLookup_ReleaseErrors(self: *const T, dwDynamicErrorID: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IErrorLookup.VTable, self.vtable).ReleaseErrors(@ptrCast(*const IErrorLookup, self), dwDynamicErrorID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISQLErrorInfo_Value = @import("../zig.zig").Guid.initString("0C733A74-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_ISQLErrorInfo = &IID_ISQLErrorInfo_Value;
pub const ISQLErrorInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSQLInfo: fn(
            self: *const ISQLErrorInfo,
            pbstrSQLState: *BSTR,
            plNativeError: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISQLErrorInfo_GetSQLInfo(self: *const T, pbstrSQLState: *BSTR, plNativeError: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISQLErrorInfo.VTable, self.vtable).GetSQLInfo(@ptrCast(*const ISQLErrorInfo, self), pbstrSQLState, plNativeError);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IGetDataSource_Value = @import("../zig.zig").Guid.initString("0C733A75-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IGetDataSource = &IID_IGetDataSource_Value;
pub const IGetDataSource = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDataSource: fn(
            self: *const IGetDataSource,
            riid: *const Guid,
            ppDataSource: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGetDataSource_GetDataSource(self: *const T, riid: *const Guid, ppDataSource: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGetDataSource.VTable, self.vtable).GetDataSource(@ptrCast(*const IGetDataSource, self), riid, ppDataSource);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITransactionLocal_Value = @import("../zig.zig").Guid.initString("0C733A5F-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_ITransactionLocal = &IID_ITransactionLocal_Value;
pub const ITransactionLocal = extern struct {
    pub const VTable = extern struct {
        base: ITransaction.VTable,
        GetOptionsObject: fn(
            self: *const ITransactionLocal,
            ppOptions: **ITransactionOptions,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartTransaction: fn(
            self: *const ITransactionLocal,
            isoLevel: i32,
            isoFlags: u32,
            pOtherOptions: ?*ITransactionOptions,
            pulTransactionLevel: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITransaction.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransactionLocal_GetOptionsObject(self: *const T, ppOptions: **ITransactionOptions) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransactionLocal.VTable, self.vtable).GetOptionsObject(@ptrCast(*const ITransactionLocal, self), ppOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransactionLocal_StartTransaction(self: *const T, isoLevel: i32, isoFlags: u32, pOtherOptions: ?*ITransactionOptions, pulTransactionLevel: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransactionLocal.VTable, self.vtable).StartTransaction(@ptrCast(*const ITransactionLocal, self), isoLevel, isoFlags, pOtherOptions, pulTransactionLevel);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITransactionJoin_Value = @import("../zig.zig").Guid.initString("0C733A5E-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_ITransactionJoin = &IID_ITransactionJoin_Value;
pub const ITransactionJoin = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetOptionsObject: fn(
            self: *const ITransactionJoin,
            ppOptions: **ITransactionOptions,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        JoinTransaction: fn(
            self: *const ITransactionJoin,
            punkTransactionCoord: ?*IUnknown,
            isoLevel: i32,
            isoFlags: u32,
            pOtherOptions: ?*ITransactionOptions,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransactionJoin_GetOptionsObject(self: *const T, ppOptions: **ITransactionOptions) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransactionJoin.VTable, self.vtable).GetOptionsObject(@ptrCast(*const ITransactionJoin, self), ppOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransactionJoin_JoinTransaction(self: *const T, punkTransactionCoord: ?*IUnknown, isoLevel: i32, isoFlags: u32, pOtherOptions: ?*ITransactionOptions) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransactionJoin.VTable, self.vtable).JoinTransaction(@ptrCast(*const ITransactionJoin, self), punkTransactionCoord, isoLevel, isoFlags, pOtherOptions);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITransactionObject_Value = @import("../zig.zig").Guid.initString("0C733A60-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_ITransactionObject = &IID_ITransactionObject_Value;
pub const ITransactionObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTransactionObject: fn(
            self: *const ITransactionObject,
            ulTransactionLevel: u32,
            ppTransactionObject: **ITransaction,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransactionObject_GetTransactionObject(self: *const T, ulTransactionLevel: u32, ppTransactionObject: **ITransaction) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransactionObject.VTable, self.vtable).GetTransactionObject(@ptrCast(*const ITransactionObject, self), ulTransactionLevel, ppTransactionObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITrusteeAdmin_Value = @import("../zig.zig").Guid.initString("0C733AA1-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_ITrusteeAdmin = &IID_ITrusteeAdmin_Value;
pub const ITrusteeAdmin = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CompareTrustees: fn(
            self: *const ITrusteeAdmin,
            pTrustee1: *TRUSTEE_W,
            pTrustee2: *TRUSTEE_W,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateTrustee: fn(
            self: *const ITrusteeAdmin,
            pTrustee: *TRUSTEE_W,
            cPropertySets: u32,
            rgPropertySets: *DBPROPSET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteTrustee: fn(
            self: *const ITrusteeAdmin,
            pTrustee: *TRUSTEE_W,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTrusteeProperties: fn(
            self: *const ITrusteeAdmin,
            pTrustee: *TRUSTEE_W,
            cPropertySets: u32,
            rgPropertySets: *DBPROPSET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTrusteeProperties: fn(
            self: *const ITrusteeAdmin,
            pTrustee: *TRUSTEE_W,
            cPropertyIDSets: u32,
            rgPropertyIDSets: *const DBPROPIDSET,
            pcPropertySets: *u32,
            prgPropertySets: **DBPROPSET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITrusteeAdmin_CompareTrustees(self: *const T, pTrustee1: *TRUSTEE_W, pTrustee2: *TRUSTEE_W) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITrusteeAdmin.VTable, self.vtable).CompareTrustees(@ptrCast(*const ITrusteeAdmin, self), pTrustee1, pTrustee2);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITrusteeAdmin_CreateTrustee(self: *const T, pTrustee: *TRUSTEE_W, cPropertySets: u32, rgPropertySets: *DBPROPSET) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITrusteeAdmin.VTable, self.vtable).CreateTrustee(@ptrCast(*const ITrusteeAdmin, self), pTrustee, cPropertySets, rgPropertySets);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITrusteeAdmin_DeleteTrustee(self: *const T, pTrustee: *TRUSTEE_W) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITrusteeAdmin.VTable, self.vtable).DeleteTrustee(@ptrCast(*const ITrusteeAdmin, self), pTrustee);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITrusteeAdmin_SetTrusteeProperties(self: *const T, pTrustee: *TRUSTEE_W, cPropertySets: u32, rgPropertySets: *DBPROPSET) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITrusteeAdmin.VTable, self.vtable).SetTrusteeProperties(@ptrCast(*const ITrusteeAdmin, self), pTrustee, cPropertySets, rgPropertySets);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITrusteeAdmin_GetTrusteeProperties(self: *const T, pTrustee: *TRUSTEE_W, cPropertyIDSets: u32, rgPropertyIDSets: *const DBPROPIDSET, pcPropertySets: *u32, prgPropertySets: **DBPROPSET) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITrusteeAdmin.VTable, self.vtable).GetTrusteeProperties(@ptrCast(*const ITrusteeAdmin, self), pTrustee, cPropertyIDSets, rgPropertyIDSets, pcPropertySets, prgPropertySets);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITrusteeGroupAdmin_Value = @import("../zig.zig").Guid.initString("0C733AA2-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_ITrusteeGroupAdmin = &IID_ITrusteeGroupAdmin_Value;
pub const ITrusteeGroupAdmin = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddMember: fn(
            self: *const ITrusteeGroupAdmin,
            pMembershipTrustee: *TRUSTEE_W,
            pMemberTrustee: *TRUSTEE_W,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteMember: fn(
            self: *const ITrusteeGroupAdmin,
            pMembershipTrustee: *TRUSTEE_W,
            pMemberTrustee: *TRUSTEE_W,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsMember: fn(
            self: *const ITrusteeGroupAdmin,
            pMembershipTrustee: *TRUSTEE_W,
            pMemberTrustee: *TRUSTEE_W,
            pfStatus: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMembers: fn(
            self: *const ITrusteeGroupAdmin,
            pMembershipTrustee: *TRUSTEE_W,
            pcMembers: *u32,
            prgMembers: **TRUSTEE_W,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMemberships: fn(
            self: *const ITrusteeGroupAdmin,
            pTrustee: *TRUSTEE_W,
            pcMemberships: *u32,
            prgMemberships: **TRUSTEE_W,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITrusteeGroupAdmin_AddMember(self: *const T, pMembershipTrustee: *TRUSTEE_W, pMemberTrustee: *TRUSTEE_W) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITrusteeGroupAdmin.VTable, self.vtable).AddMember(@ptrCast(*const ITrusteeGroupAdmin, self), pMembershipTrustee, pMemberTrustee);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITrusteeGroupAdmin_DeleteMember(self: *const T, pMembershipTrustee: *TRUSTEE_W, pMemberTrustee: *TRUSTEE_W) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITrusteeGroupAdmin.VTable, self.vtable).DeleteMember(@ptrCast(*const ITrusteeGroupAdmin, self), pMembershipTrustee, pMemberTrustee);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITrusteeGroupAdmin_IsMember(self: *const T, pMembershipTrustee: *TRUSTEE_W, pMemberTrustee: *TRUSTEE_W, pfStatus: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITrusteeGroupAdmin.VTable, self.vtable).IsMember(@ptrCast(*const ITrusteeGroupAdmin, self), pMembershipTrustee, pMemberTrustee, pfStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITrusteeGroupAdmin_GetMembers(self: *const T, pMembershipTrustee: *TRUSTEE_W, pcMembers: *u32, prgMembers: **TRUSTEE_W) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITrusteeGroupAdmin.VTable, self.vtable).GetMembers(@ptrCast(*const ITrusteeGroupAdmin, self), pMembershipTrustee, pcMembers, prgMembers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITrusteeGroupAdmin_GetMemberships(self: *const T, pTrustee: *TRUSTEE_W, pcMemberships: *u32, prgMemberships: **TRUSTEE_W) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITrusteeGroupAdmin.VTable, self.vtable).GetMemberships(@ptrCast(*const ITrusteeGroupAdmin, self), pTrustee, pcMemberships, prgMemberships);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IObjectAccessControl_Value = @import("../zig.zig").Guid.initString("0C733AA3-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IObjectAccessControl = &IID_IObjectAccessControl_Value;
pub const IObjectAccessControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetObjectAccessRights: fn(
            self: *const IObjectAccessControl,
            pObject: *SEC_OBJECT,
            pcAccessEntries: *u32,
            prgAccessEntries: **EXPLICIT_ACCESS_W,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetObjectOwner: fn(
            self: *const IObjectAccessControl,
            pObject: *SEC_OBJECT,
            ppOwner: **TRUSTEE_W,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsObjectAccessAllowed: fn(
            self: *const IObjectAccessControl,
            pObject: *SEC_OBJECT,
            pAccessEntry: *EXPLICIT_ACCESS_W,
            pfResult: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetObjectAccessRights: fn(
            self: *const IObjectAccessControl,
            pObject: *SEC_OBJECT,
            cAccessEntries: u32,
            prgAccessEntries: *EXPLICIT_ACCESS_W,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetObjectOwner: fn(
            self: *const IObjectAccessControl,
            pObject: *SEC_OBJECT,
            pOwner: *TRUSTEE_W,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IObjectAccessControl_GetObjectAccessRights(self: *const T, pObject: *SEC_OBJECT, pcAccessEntries: *u32, prgAccessEntries: **EXPLICIT_ACCESS_W) callconv(.Inline) HRESULT {
            return @ptrCast(*const IObjectAccessControl.VTable, self.vtable).GetObjectAccessRights(@ptrCast(*const IObjectAccessControl, self), pObject, pcAccessEntries, prgAccessEntries);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IObjectAccessControl_GetObjectOwner(self: *const T, pObject: *SEC_OBJECT, ppOwner: **TRUSTEE_W) callconv(.Inline) HRESULT {
            return @ptrCast(*const IObjectAccessControl.VTable, self.vtable).GetObjectOwner(@ptrCast(*const IObjectAccessControl, self), pObject, ppOwner);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IObjectAccessControl_IsObjectAccessAllowed(self: *const T, pObject: *SEC_OBJECT, pAccessEntry: *EXPLICIT_ACCESS_W, pfResult: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IObjectAccessControl.VTable, self.vtable).IsObjectAccessAllowed(@ptrCast(*const IObjectAccessControl, self), pObject, pAccessEntry, pfResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IObjectAccessControl_SetObjectAccessRights(self: *const T, pObject: *SEC_OBJECT, cAccessEntries: u32, prgAccessEntries: *EXPLICIT_ACCESS_W) callconv(.Inline) HRESULT {
            return @ptrCast(*const IObjectAccessControl.VTable, self.vtable).SetObjectAccessRights(@ptrCast(*const IObjectAccessControl, self), pObject, cAccessEntries, prgAccessEntries);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IObjectAccessControl_SetObjectOwner(self: *const T, pObject: *SEC_OBJECT, pOwner: *TRUSTEE_W) callconv(.Inline) HRESULT {
            return @ptrCast(*const IObjectAccessControl.VTable, self.vtable).SetObjectOwner(@ptrCast(*const IObjectAccessControl, self), pObject, pOwner);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ACCESS_MASKENUM = extern enum(i32) {
    PERM_EXCLUSIVE = 512,
    PERM_READDESIGN = 1024,
    PERM_WRITEDESIGN = 2048,
    PERM_WITHGRANT = 4096,
    PERM_REFERENCE = 8192,
    PERM_CREATE = 16384,
    PERM_INSERT = 32768,
    PERM_DELETE = 65536,
    PERM_READCONTROL = 131072,
    PERM_WRITEPERMISSIONS = 262144,
    PERM_WRITEOWNER = 524288,
    PERM_MAXIMUM_ALLOWED = 33554432,
    PERM_ALL = 268435456,
    PERM_EXECUTE = 536870912,
    PERM_READ = -2147483648,
    PERM_UPDATE = 1073741824,
    PERM_DROP = 256,
};
pub const PERM_EXCLUSIVE = ACCESS_MASKENUM.PERM_EXCLUSIVE;
pub const PERM_READDESIGN = ACCESS_MASKENUM.PERM_READDESIGN;
pub const PERM_WRITEDESIGN = ACCESS_MASKENUM.PERM_WRITEDESIGN;
pub const PERM_WITHGRANT = ACCESS_MASKENUM.PERM_WITHGRANT;
pub const PERM_REFERENCE = ACCESS_MASKENUM.PERM_REFERENCE;
pub const PERM_CREATE = ACCESS_MASKENUM.PERM_CREATE;
pub const PERM_INSERT = ACCESS_MASKENUM.PERM_INSERT;
pub const PERM_DELETE = ACCESS_MASKENUM.PERM_DELETE;
pub const PERM_READCONTROL = ACCESS_MASKENUM.PERM_READCONTROL;
pub const PERM_WRITEPERMISSIONS = ACCESS_MASKENUM.PERM_WRITEPERMISSIONS;
pub const PERM_WRITEOWNER = ACCESS_MASKENUM.PERM_WRITEOWNER;
pub const PERM_MAXIMUM_ALLOWED = ACCESS_MASKENUM.PERM_MAXIMUM_ALLOWED;
pub const PERM_ALL = ACCESS_MASKENUM.PERM_ALL;
pub const PERM_EXECUTE = ACCESS_MASKENUM.PERM_EXECUTE;
pub const PERM_READ = ACCESS_MASKENUM.PERM_READ;
pub const PERM_UPDATE = ACCESS_MASKENUM.PERM_UPDATE;
pub const PERM_DROP = ACCESS_MASKENUM.PERM_DROP;

const IID_ISecurityInfo_Value = @import("../zig.zig").Guid.initString("0C733AA4-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_ISecurityInfo = &IID_ISecurityInfo_Value;
pub const ISecurityInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrentTrustee: fn(
            self: *const ISecurityInfo,
            ppTrustee: **TRUSTEE_W,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetObjectTypes: fn(
            self: *const ISecurityInfo,
            cObjectTypes: *u32,
            rgObjectTypes: **Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPermissions: fn(
            self: *const ISecurityInfo,
            ObjectType: Guid,
            pPermissions: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISecurityInfo_GetCurrentTrustee(self: *const T, ppTrustee: **TRUSTEE_W) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISecurityInfo.VTable, self.vtable).GetCurrentTrustee(@ptrCast(*const ISecurityInfo, self), ppTrustee);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISecurityInfo_GetObjectTypes(self: *const T, cObjectTypes: *u32, rgObjectTypes: **Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISecurityInfo.VTable, self.vtable).GetObjectTypes(@ptrCast(*const ISecurityInfo, self), cObjectTypes, rgObjectTypes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISecurityInfo_GetPermissions(self: *const T, ObjectType: Guid, pPermissions: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISecurityInfo.VTable, self.vtable).GetPermissions(@ptrCast(*const ISecurityInfo, self), ObjectType, pPermissions);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITableCreation_Value = @import("../zig.zig").Guid.initString("0C733ABC-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_ITableCreation = &IID_ITableCreation_Value;
pub const ITableCreation = extern struct {
    pub const VTable = extern struct {
        base: ITableDefinition.VTable,
        GetTableDefinition: fn(
            self: *const ITableCreation,
            pTableID: *DBID,
            pcColumnDescs: ?*u32,
            prgColumnDescs: ?[*]?*DBCOLUMNDESC,
            pcPropertySets: ?*u32,
            prgPropertySets: ?[*]?*DBPROPSET,
            pcConstraintDescs: ?*u32,
            prgConstraintDescs: ?[*]?*DBCONSTRAINTDESC,
            ppwszStringBuffer: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITableDefinition.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITableCreation_GetTableDefinition(self: *const T, pTableID: *DBID, pcColumnDescs: ?*u32, prgColumnDescs: ?[*]?*DBCOLUMNDESC, pcPropertySets: ?*u32, prgPropertySets: ?[*]?*DBPROPSET, pcConstraintDescs: ?*u32, prgConstraintDescs: ?[*]?*DBCONSTRAINTDESC, ppwszStringBuffer: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITableCreation.VTable, self.vtable).GetTableDefinition(@ptrCast(*const ITableCreation, self), pTableID, pcColumnDescs, prgColumnDescs, pcPropertySets, prgPropertySets, pcConstraintDescs, prgConstraintDescs, ppwszStringBuffer);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITableDefinitionWithConstraints_Value = @import("../zig.zig").Guid.initString("0C733AAB-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_ITableDefinitionWithConstraints = &IID_ITableDefinitionWithConstraints_Value;
pub const ITableDefinitionWithConstraints = extern struct {
    pub const VTable = extern struct {
        base: ITableCreation.VTable,
        AddConstraint: fn(
            self: *const ITableDefinitionWithConstraints,
            pTableID: *DBID,
            pConstraintDesc: *DBCONSTRAINTDESC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateTableWithConstraints: fn(
            self: *const ITableDefinitionWithConstraints,
            pUnkOuter: *IUnknown,
            pTableID: *DBID,
            cColumnDescs: u32,
            rgColumnDescs: *DBCOLUMNDESC,
            cConstraintDescs: u32,
            rgConstraintDescs: *DBCONSTRAINTDESC,
            riid: *const Guid,
            cPropertySets: u32,
            rgPropertySets: *DBPROPSET,
            ppTableID: **DBID,
            ppRowset: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DropConstraint: fn(
            self: *const ITableDefinitionWithConstraints,
            pTableID: *DBID,
            pConstraintID: *DBID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITableCreation.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITableDefinitionWithConstraints_AddConstraint(self: *const T, pTableID: *DBID, pConstraintDesc: *DBCONSTRAINTDESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITableDefinitionWithConstraints.VTable, self.vtable).AddConstraint(@ptrCast(*const ITableDefinitionWithConstraints, self), pTableID, pConstraintDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITableDefinitionWithConstraints_CreateTableWithConstraints(self: *const T, pUnkOuter: *IUnknown, pTableID: *DBID, cColumnDescs: u32, rgColumnDescs: *DBCOLUMNDESC, cConstraintDescs: u32, rgConstraintDescs: *DBCONSTRAINTDESC, riid: *const Guid, cPropertySets: u32, rgPropertySets: *DBPROPSET, ppTableID: **DBID, ppRowset: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITableDefinitionWithConstraints.VTable, self.vtable).CreateTableWithConstraints(@ptrCast(*const ITableDefinitionWithConstraints, self), pUnkOuter, pTableID, cColumnDescs, rgColumnDescs, cConstraintDescs, rgConstraintDescs, riid, cPropertySets, rgPropertySets, ppTableID, ppRowset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITableDefinitionWithConstraints_DropConstraint(self: *const T, pTableID: *DBID, pConstraintID: *DBID) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITableDefinitionWithConstraints.VTable, self.vtable).DropConstraint(@ptrCast(*const ITableDefinitionWithConstraints, self), pTableID, pConstraintID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRow_Value = @import("../zig.zig").Guid.initString("0C733AB4-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IRow = &IID_IRow_Value;
pub const IRow = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetColumns: fn(
            self: *const IRow,
            cColumns: u32,
            rgColumns: [*]DBCOLUMNACCESS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceRowset: fn(
            self: *const IRow,
            riid: *const Guid,
            ppRowset: ?*?*IUnknown,
            phRow: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Open: fn(
            self: *const IRow,
            pUnkOuter: ?*IUnknown,
            pColumnID: *DBID,
            rguidColumnType: *const Guid,
            dwBindFlags: u32,
            riid: *const Guid,
            ppUnk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRow_GetColumns(self: *const T, cColumns: u32, rgColumns: [*]DBCOLUMNACCESS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRow.VTable, self.vtable).GetColumns(@ptrCast(*const IRow, self), cColumns, rgColumns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRow_GetSourceRowset(self: *const T, riid: *const Guid, ppRowset: ?*?*IUnknown, phRow: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRow.VTable, self.vtable).GetSourceRowset(@ptrCast(*const IRow, self), riid, ppRowset, phRow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRow_Open(self: *const T, pUnkOuter: ?*IUnknown, pColumnID: *DBID, rguidColumnType: *const Guid, dwBindFlags: u32, riid: *const Guid, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRow.VTable, self.vtable).Open(@ptrCast(*const IRow, self), pUnkOuter, pColumnID, rguidColumnType, dwBindFlags, riid, ppUnk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowChange_Value = @import("../zig.zig").Guid.initString("0C733AB5-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IRowChange = &IID_IRowChange_Value;
pub const IRowChange = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetColumns: fn(
            self: *const IRowChange,
            cColumns: u32,
            rgColumns: [*]DBCOLUMNACCESS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowChange_SetColumns(self: *const T, cColumns: u32, rgColumns: [*]DBCOLUMNACCESS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowChange.VTable, self.vtable).SetColumns(@ptrCast(*const IRowChange, self), cColumns, rgColumns);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowSchemaChange_Value = @import("../zig.zig").Guid.initString("0C733AAE-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IRowSchemaChange = &IID_IRowSchemaChange_Value;
pub const IRowSchemaChange = extern struct {
    pub const VTable = extern struct {
        base: IRowChange.VTable,
        DeleteColumns: fn(
            self: *const IRowSchemaChange,
            cColumns: u32,
            rgColumnIDs: *const DBID,
            rgdwStatus: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddColumns: fn(
            self: *const IRowSchemaChange,
            cColumns: u32,
            rgNewColumnInfo: *const DBCOLUMNINFO,
            rgColumns: *DBCOLUMNACCESS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IRowChange.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowSchemaChange_DeleteColumns(self: *const T, cColumns: u32, rgColumnIDs: *const DBID, rgdwStatus: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowSchemaChange.VTable, self.vtable).DeleteColumns(@ptrCast(*const IRowSchemaChange, self), cColumns, rgColumnIDs, rgdwStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowSchemaChange_AddColumns(self: *const T, cColumns: u32, rgNewColumnInfo: *const DBCOLUMNINFO, rgColumns: *DBCOLUMNACCESS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowSchemaChange.VTable, self.vtable).AddColumns(@ptrCast(*const IRowSchemaChange, self), cColumns, rgNewColumnInfo, rgColumns);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IGetRow_Value = @import("../zig.zig").Guid.initString("0C733AAF-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IGetRow = &IID_IGetRow_Value;
pub const IGetRow = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRowFromHROW: fn(
            self: *const IGetRow,
            pUnkOuter: *IUnknown,
            hRow: ?*c_void,
            riid: *const Guid,
            ppUnk: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetURLFromHROW: fn(
            self: *const IGetRow,
            hRow: ?*c_void,
            ppwszURL: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGetRow_GetRowFromHROW(self: *const T, pUnkOuter: *IUnknown, hRow: ?*c_void, riid: *const Guid, ppUnk: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGetRow.VTable, self.vtable).GetRowFromHROW(@ptrCast(*const IGetRow, self), pUnkOuter, hRow, riid, ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGetRow_GetURLFromHROW(self: *const T, hRow: ?*c_void, ppwszURL: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGetRow.VTable, self.vtable).GetURLFromHROW(@ptrCast(*const IGetRow, self), hRow, ppwszURL);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBindResource_Value = @import("../zig.zig").Guid.initString("0C733AB1-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IBindResource = &IID_IBindResource_Value;
pub const IBindResource = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Bind: fn(
            self: *const IBindResource,
            pUnkOuter: ?*IUnknown,
            pwszURL: [*:0]const u16,
            dwBindURLFlags: u32,
            rguid: *const Guid,
            riid: *const Guid,
            pAuthenticate: ?*IAuthenticate,
            pImplSession: ?*DBIMPLICITSESSION,
            pdwBindStatus: ?*u32,
            ppUnk: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindResource_Bind(self: *const T, pUnkOuter: ?*IUnknown, pwszURL: [*:0]const u16, dwBindURLFlags: u32, rguid: *const Guid, riid: *const Guid, pAuthenticate: ?*IAuthenticate, pImplSession: ?*DBIMPLICITSESSION, pdwBindStatus: ?*u32, ppUnk: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindResource.VTable, self.vtable).Bind(@ptrCast(*const IBindResource, self), pUnkOuter, pwszURL, dwBindURLFlags, rguid, riid, pAuthenticate, pImplSession, pdwBindStatus, ppUnk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DBCOPYFLAGSENUM = extern enum(i32) {
    DBCOPY_ASYNC = 256,
    DBCOPY_REPLACE_EXISTING = 512,
    DBCOPY_ALLOW_EMULATION = 1024,
    DBCOPY_NON_RECURSIVE = 2048,
    DBCOPY_ATOMIC = 4096,
};
pub const DBCOPY_ASYNC = DBCOPYFLAGSENUM.DBCOPY_ASYNC;
pub const DBCOPY_REPLACE_EXISTING = DBCOPYFLAGSENUM.DBCOPY_REPLACE_EXISTING;
pub const DBCOPY_ALLOW_EMULATION = DBCOPYFLAGSENUM.DBCOPY_ALLOW_EMULATION;
pub const DBCOPY_NON_RECURSIVE = DBCOPYFLAGSENUM.DBCOPY_NON_RECURSIVE;
pub const DBCOPY_ATOMIC = DBCOPYFLAGSENUM.DBCOPY_ATOMIC;

pub const DBMOVEFLAGSENUM = extern enum(i32) {
    DBMOVE_REPLACE_EXISTING = 1,
    DBMOVE_ASYNC = 256,
    DBMOVE_DONT_UPDATE_LINKS = 512,
    DBMOVE_ALLOW_EMULATION = 1024,
    DBMOVE_ATOMIC = 4096,
};
pub const DBMOVE_REPLACE_EXISTING = DBMOVEFLAGSENUM.DBMOVE_REPLACE_EXISTING;
pub const DBMOVE_ASYNC = DBMOVEFLAGSENUM.DBMOVE_ASYNC;
pub const DBMOVE_DONT_UPDATE_LINKS = DBMOVEFLAGSENUM.DBMOVE_DONT_UPDATE_LINKS;
pub const DBMOVE_ALLOW_EMULATION = DBMOVEFLAGSENUM.DBMOVE_ALLOW_EMULATION;
pub const DBMOVE_ATOMIC = DBMOVEFLAGSENUM.DBMOVE_ATOMIC;

pub const DBDELETEFLAGSENUM = extern enum(i32) {
    DBDELETE_ASYNC = 256,
    DBDELETE_ATOMIC = 4096,
};
pub const DBDELETE_ASYNC = DBDELETEFLAGSENUM.DBDELETE_ASYNC;
pub const DBDELETE_ATOMIC = DBDELETEFLAGSENUM.DBDELETE_ATOMIC;

const IID_IScopedOperations_Value = @import("../zig.zig").Guid.initString("0C733AB0-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IScopedOperations = &IID_IScopedOperations_Value;
pub const IScopedOperations = extern struct {
    pub const VTable = extern struct {
        base: IBindResource.VTable,
        Copy: fn(
            self: *const IScopedOperations,
            cRows: u32,
            rgpwszSourceURLs: ?[*]?*?PWSTR,
            rgpwszDestURLs: [*]*PWSTR,
            dwCopyFlags: u32,
            pAuthenticate: ?*IAuthenticate,
            rgdwStatus: [*]u32,
            rgpwszNewURLs: ?[*]?*?PWSTR,
            ppStringsBuffer: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Move: fn(
            self: *const IScopedOperations,
            cRows: u32,
            rgpwszSourceURLs: ?[*]?*?PWSTR,
            rgpwszDestURLs: [*]*PWSTR,
            dwMoveFlags: u32,
            pAuthenticate: ?*IAuthenticate,
            rgdwStatus: [*]u32,
            rgpwszNewURLs: ?[*]?*?PWSTR,
            ppStringsBuffer: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: fn(
            self: *const IScopedOperations,
            cRows: u32,
            rgpwszURLs: [*]*PWSTR,
            dwDeleteFlags: u32,
            rgdwStatus: [*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenRowset: fn(
            self: *const IScopedOperations,
            pUnkOuter: ?*IUnknown,
            pTableID: ?*DBID,
            pIndexID: ?*DBID,
            riid: *const Guid,
            cPropertySets: u32,
            rgPropertySets: [*]DBPROPSET,
            ppRowset: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IBindResource.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScopedOperations_Copy(self: *const T, cRows: u32, rgpwszSourceURLs: ?[*]?*?PWSTR, rgpwszDestURLs: [*]*PWSTR, dwCopyFlags: u32, pAuthenticate: ?*IAuthenticate, rgdwStatus: [*]u32, rgpwszNewURLs: ?[*]?*?PWSTR, ppStringsBuffer: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScopedOperations.VTable, self.vtable).Copy(@ptrCast(*const IScopedOperations, self), cRows, rgpwszSourceURLs, rgpwszDestURLs, dwCopyFlags, pAuthenticate, rgdwStatus, rgpwszNewURLs, ppStringsBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScopedOperations_Move(self: *const T, cRows: u32, rgpwszSourceURLs: ?[*]?*?PWSTR, rgpwszDestURLs: [*]*PWSTR, dwMoveFlags: u32, pAuthenticate: ?*IAuthenticate, rgdwStatus: [*]u32, rgpwszNewURLs: ?[*]?*?PWSTR, ppStringsBuffer: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScopedOperations.VTable, self.vtable).Move(@ptrCast(*const IScopedOperations, self), cRows, rgpwszSourceURLs, rgpwszDestURLs, dwMoveFlags, pAuthenticate, rgdwStatus, rgpwszNewURLs, ppStringsBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScopedOperations_Delete(self: *const T, cRows: u32, rgpwszURLs: [*]*PWSTR, dwDeleteFlags: u32, rgdwStatus: [*]u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScopedOperations.VTable, self.vtable).Delete(@ptrCast(*const IScopedOperations, self), cRows, rgpwszURLs, dwDeleteFlags, rgdwStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScopedOperations_OpenRowset(self: *const T, pUnkOuter: ?*IUnknown, pTableID: ?*DBID, pIndexID: ?*DBID, riid: *const Guid, cPropertySets: u32, rgPropertySets: [*]DBPROPSET, ppRowset: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScopedOperations.VTable, self.vtable).OpenRowset(@ptrCast(*const IScopedOperations, self), pUnkOuter, pTableID, pIndexID, riid, cPropertySets, rgPropertySets, ppRowset);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICreateRow_Value = @import("../zig.zig").Guid.initString("0C733AB2-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_ICreateRow = &IID_ICreateRow_Value;
pub const ICreateRow = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateRow: fn(
            self: *const ICreateRow,
            pUnkOuter: ?*IUnknown,
            pwszURL: [*:0]const u16,
            dwBindURLFlags: u32,
            rguid: *const Guid,
            riid: *const Guid,
            pAuthenticate: ?*IAuthenticate,
            pImplSession: ?*DBIMPLICITSESSION,
            pdwBindStatus: *u32,
            ppwszNewURL: ?*?PWSTR,
            ppUnk: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICreateRow_CreateRow(self: *const T, pUnkOuter: ?*IUnknown, pwszURL: [*:0]const u16, dwBindURLFlags: u32, rguid: *const Guid, riid: *const Guid, pAuthenticate: ?*IAuthenticate, pImplSession: ?*DBIMPLICITSESSION, pdwBindStatus: *u32, ppwszNewURL: ?*?PWSTR, ppUnk: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICreateRow.VTable, self.vtable).CreateRow(@ptrCast(*const ICreateRow, self), pUnkOuter, pwszURL, dwBindURLFlags, rguid, riid, pAuthenticate, pImplSession, pdwBindStatus, ppwszNewURL, ppUnk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDBBinderProperties_Value = @import("../zig.zig").Guid.initString("0C733AB3-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IDBBinderProperties = &IID_IDBBinderProperties_Value;
pub const IDBBinderProperties = extern struct {
    pub const VTable = extern struct {
        base: IDBProperties.VTable,
        Reset: fn(
            self: *const IDBBinderProperties,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDBProperties.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDBBinderProperties_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDBBinderProperties.VTable, self.vtable).Reset(@ptrCast(*const IDBBinderProperties, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IColumnsInfo2_Value = @import("../zig.zig").Guid.initString("0C733AB8-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IColumnsInfo2 = &IID_IColumnsInfo2_Value;
pub const IColumnsInfo2 = extern struct {
    pub const VTable = extern struct {
        base: IColumnsInfo.VTable,
        GetRestrictedColumnInfo: fn(
            self: *const IColumnsInfo2,
            cColumnIDMasks: u32,
            rgColumnIDMasks: [*]const DBID,
            dwFlags: u32,
            pcColumns: *u32,
            prgColumnIDs: **DBID,
            prgColumnInfo: **DBCOLUMNINFO,
            ppStringsBuffer: ?*?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IColumnsInfo.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IColumnsInfo2_GetRestrictedColumnInfo(self: *const T, cColumnIDMasks: u32, rgColumnIDMasks: [*]const DBID, dwFlags: u32, pcColumns: *u32, prgColumnIDs: **DBID, prgColumnInfo: **DBCOLUMNINFO, ppStringsBuffer: ?*?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IColumnsInfo2.VTable, self.vtable).GetRestrictedColumnInfo(@ptrCast(*const IColumnsInfo2, self), cColumnIDMasks, rgColumnIDMasks, dwFlags, pcColumns, prgColumnIDs, prgColumnInfo, ppStringsBuffer);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRegisterProvider_Value = @import("../zig.zig").Guid.initString("0C733AB9-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IRegisterProvider = &IID_IRegisterProvider_Value;
pub const IRegisterProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetURLMapping: fn(
            self: *const IRegisterProvider,
            pwszURL: [*:0]const u16,
            dwReserved: u32,
            pclsidProvider: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetURLMapping: fn(
            self: *const IRegisterProvider,
            pwszURL: ?[*:0]const u16,
            dwReserved: u32,
            rclsidProvider: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterProvider: fn(
            self: *const IRegisterProvider,
            pwszURL: ?[*:0]const u16,
            dwReserved: u32,
            rclsidProvider: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegisterProvider_GetURLMapping(self: *const T, pwszURL: [*:0]const u16, dwReserved: u32, pclsidProvider: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegisterProvider.VTable, self.vtable).GetURLMapping(@ptrCast(*const IRegisterProvider, self), pwszURL, dwReserved, pclsidProvider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegisterProvider_SetURLMapping(self: *const T, pwszURL: ?[*:0]const u16, dwReserved: u32, rclsidProvider: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegisterProvider.VTable, self.vtable).SetURLMapping(@ptrCast(*const IRegisterProvider, self), pwszURL, dwReserved, rclsidProvider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRegisterProvider_UnregisterProvider(self: *const T, pwszURL: ?[*:0]const u16, dwReserved: u32, rclsidProvider: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRegisterProvider.VTable, self.vtable).UnregisterProvider(@ptrCast(*const IRegisterProvider, self), pwszURL, dwReserved, rclsidProvider);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IGetSession_Value = @import("../zig.zig").Guid.initString("0C733ABA-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IGetSession = &IID_IGetSession_Value;
pub const IGetSession = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSession: fn(
            self: *const IGetSession,
            riid: *const Guid,
            ppSession: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGetSession_GetSession(self: *const T, riid: *const Guid, ppSession: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGetSession.VTable, self.vtable).GetSession(@ptrCast(*const IGetSession, self), riid, ppSession);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IGetSourceRow_Value = @import("../zig.zig").Guid.initString("0C733ABB-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IGetSourceRow = &IID_IGetSourceRow_Value;
pub const IGetSourceRow = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSourceRow: fn(
            self: *const IGetSourceRow,
            riid: *const Guid,
            ppRow: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGetSourceRow_GetSourceRow(self: *const T, riid: *const Guid, ppRow: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGetSourceRow.VTable, self.vtable).GetSourceRow(@ptrCast(*const IGetSourceRow, self), riid, ppRow);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetCurrentIndex_Value = @import("../zig.zig").Guid.initString("0C733ABD-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IRowsetCurrentIndex = &IID_IRowsetCurrentIndex_Value;
pub const IRowsetCurrentIndex = extern struct {
    pub const VTable = extern struct {
        base: IRowsetIndex.VTable,
        GetIndex: fn(
            self: *const IRowsetCurrentIndex,
            ppIndexID: **DBID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIndex: fn(
            self: *const IRowsetCurrentIndex,
            pIndexID: *DBID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IRowsetIndex.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowsetCurrentIndex_GetIndex(self: *const T, ppIndexID: **DBID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowsetCurrentIndex.VTable, self.vtable).GetIndex(@ptrCast(*const IRowsetCurrentIndex, self), ppIndexID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowsetCurrentIndex_SetIndex(self: *const T, pIndexID: *DBID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowsetCurrentIndex.VTable, self.vtable).SetIndex(@ptrCast(*const IRowsetCurrentIndex, self), pIndexID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICommandStream_Value = @import("../zig.zig").Guid.initString("0C733ABF-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_ICommandStream = &IID_ICommandStream_Value;
pub const ICommandStream = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCommandStream: fn(
            self: *const ICommandStream,
            piid: ?*Guid,
            pguidDialect: ?*Guid,
            ppCommandStream: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCommandStream: fn(
            self: *const ICommandStream,
            riid: *const Guid,
            rguidDialect: *const Guid,
            pCommandStream: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICommandStream_GetCommandStream(self: *const T, piid: ?*Guid, pguidDialect: ?*Guid, ppCommandStream: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICommandStream.VTable, self.vtable).GetCommandStream(@ptrCast(*const ICommandStream, self), piid, pguidDialect, ppCommandStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICommandStream_SetCommandStream(self: *const T, riid: *const Guid, rguidDialect: *const Guid, pCommandStream: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICommandStream.VTable, self.vtable).SetCommandStream(@ptrCast(*const ICommandStream, self), riid, rguidDialect, pCommandStream);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRowsetBookmark_Value = @import("../zig.zig").Guid.initString("0C733AC2-2A1C-11CE-ADE5-00AA0044773D");
pub const IID_IRowsetBookmark = &IID_IRowsetBookmark_Value;
pub const IRowsetBookmark = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PositionOnBookmark: fn(
            self: *const IRowsetBookmark,
            hChapter: ?*c_void,
            cbBookmark: u32,
            pBookmark: [*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowsetBookmark_PositionOnBookmark(self: *const T, hChapter: ?*c_void, cbBookmark: u32, pBookmark: [*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowsetBookmark.VTable, self.vtable).PositionOnBookmark(@ptrCast(*const IRowsetBookmark, self), hChapter, cbBookmark, pBookmark);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_QueryParser_Value = @import("../zig.zig").Guid.initString("B72F8FD8-0FAB-4DD9-BDBF-245A6CE1485B");
pub const CLSID_QueryParser = &CLSID_QueryParser_Value;

const CLSID_NegationCondition_Value = @import("../zig.zig").Guid.initString("8DE9C74C-605A-4ACD-BEE3-2B222AA2D23D");
pub const CLSID_NegationCondition = &CLSID_NegationCondition_Value;

const CLSID_CompoundCondition_Value = @import("../zig.zig").Guid.initString("116F8D13-101E-4FA5-84D4-FF8279381935");
pub const CLSID_CompoundCondition = &CLSID_CompoundCondition_Value;

const CLSID_LeafCondition_Value = @import("../zig.zig").Guid.initString("52F15C89-5A17-48E1-BBCD-46A3F89C7CC2");
pub const CLSID_LeafCondition = &CLSID_LeafCondition_Value;

const CLSID_ConditionFactory_Value = @import("../zig.zig").Guid.initString("E03E85B0-7BE3-4000-BA98-6C13DE9FA486");
pub const CLSID_ConditionFactory = &CLSID_ConditionFactory_Value;

const CLSID_Interval_Value = @import("../zig.zig").Guid.initString("D957171F-4BF9-4DE2-BCD5-C70A7CA55836");
pub const CLSID_Interval = &CLSID_Interval_Value;

const CLSID_QueryParserManager_Value = @import("../zig.zig").Guid.initString("5088B39A-29B4-4D9D-8245-4EE289222F66");
pub const CLSID_QueryParserManager = &CLSID_QueryParserManager_Value;

pub const STRUCTURED_QUERY_SYNTAX = extern enum(i32) {
    SQS_NO_SYNTAX = 0,
    SQS_ADVANCED_QUERY_SYNTAX = 1,
    SQS_NATURAL_QUERY_SYNTAX = 2,
};
pub const SQS_NO_SYNTAX = STRUCTURED_QUERY_SYNTAX.SQS_NO_SYNTAX;
pub const SQS_ADVANCED_QUERY_SYNTAX = STRUCTURED_QUERY_SYNTAX.SQS_ADVANCED_QUERY_SYNTAX;
pub const SQS_NATURAL_QUERY_SYNTAX = STRUCTURED_QUERY_SYNTAX.SQS_NATURAL_QUERY_SYNTAX;

pub const STRUCTURED_QUERY_SINGLE_OPTION = extern enum(i32) {
    SQSO_SCHEMA = 0,
    SQSO_LOCALE_WORD_BREAKING = 1,
    SQSO_WORD_BREAKER = 2,
    SQSO_NATURAL_SYNTAX = 3,
    SQSO_AUTOMATIC_WILDCARD = 4,
    SQSO_TRACE_LEVEL = 5,
    SQSO_LANGUAGE_KEYWORDS = 6,
    SQSO_SYNTAX = 7,
    SQSO_TIME_ZONE = 8,
    SQSO_IMPLICIT_CONNECTOR = 9,
    SQSO_CONNECTOR_CASE = 10,
};
pub const SQSO_SCHEMA = STRUCTURED_QUERY_SINGLE_OPTION.SQSO_SCHEMA;
pub const SQSO_LOCALE_WORD_BREAKING = STRUCTURED_QUERY_SINGLE_OPTION.SQSO_LOCALE_WORD_BREAKING;
pub const SQSO_WORD_BREAKER = STRUCTURED_QUERY_SINGLE_OPTION.SQSO_WORD_BREAKER;
pub const SQSO_NATURAL_SYNTAX = STRUCTURED_QUERY_SINGLE_OPTION.SQSO_NATURAL_SYNTAX;
pub const SQSO_AUTOMATIC_WILDCARD = STRUCTURED_QUERY_SINGLE_OPTION.SQSO_AUTOMATIC_WILDCARD;
pub const SQSO_TRACE_LEVEL = STRUCTURED_QUERY_SINGLE_OPTION.SQSO_TRACE_LEVEL;
pub const SQSO_LANGUAGE_KEYWORDS = STRUCTURED_QUERY_SINGLE_OPTION.SQSO_LANGUAGE_KEYWORDS;
pub const SQSO_SYNTAX = STRUCTURED_QUERY_SINGLE_OPTION.SQSO_SYNTAX;
pub const SQSO_TIME_ZONE = STRUCTURED_QUERY_SINGLE_OPTION.SQSO_TIME_ZONE;
pub const SQSO_IMPLICIT_CONNECTOR = STRUCTURED_QUERY_SINGLE_OPTION.SQSO_IMPLICIT_CONNECTOR;
pub const SQSO_CONNECTOR_CASE = STRUCTURED_QUERY_SINGLE_OPTION.SQSO_CONNECTOR_CASE;

pub const STRUCTURED_QUERY_MULTIOPTION = extern enum(i32) {
    SQMO_VIRTUAL_PROPERTY = 0,
    SQMO_DEFAULT_PROPERTY = 1,
    SQMO_GENERATOR_FOR_TYPE = 2,
    SQMO_MAP_PROPERTY = 3,
};
pub const SQMO_VIRTUAL_PROPERTY = STRUCTURED_QUERY_MULTIOPTION.SQMO_VIRTUAL_PROPERTY;
pub const SQMO_DEFAULT_PROPERTY = STRUCTURED_QUERY_MULTIOPTION.SQMO_DEFAULT_PROPERTY;
pub const SQMO_GENERATOR_FOR_TYPE = STRUCTURED_QUERY_MULTIOPTION.SQMO_GENERATOR_FOR_TYPE;
pub const SQMO_MAP_PROPERTY = STRUCTURED_QUERY_MULTIOPTION.SQMO_MAP_PROPERTY;

pub const STRUCTURED_QUERY_PARSE_ERROR = extern enum(i32) {
    SQPE_NONE = 0,
    SQPE_EXTRA_OPENING_PARENTHESIS = 1,
    SQPE_EXTRA_CLOSING_PARENTHESIS = 2,
    SQPE_IGNORED_MODIFIER = 3,
    SQPE_IGNORED_CONNECTOR = 4,
    SQPE_IGNORED_KEYWORD = 5,
    SQPE_UNHANDLED = 6,
};
pub const SQPE_NONE = STRUCTURED_QUERY_PARSE_ERROR.SQPE_NONE;
pub const SQPE_EXTRA_OPENING_PARENTHESIS = STRUCTURED_QUERY_PARSE_ERROR.SQPE_EXTRA_OPENING_PARENTHESIS;
pub const SQPE_EXTRA_CLOSING_PARENTHESIS = STRUCTURED_QUERY_PARSE_ERROR.SQPE_EXTRA_CLOSING_PARENTHESIS;
pub const SQPE_IGNORED_MODIFIER = STRUCTURED_QUERY_PARSE_ERROR.SQPE_IGNORED_MODIFIER;
pub const SQPE_IGNORED_CONNECTOR = STRUCTURED_QUERY_PARSE_ERROR.SQPE_IGNORED_CONNECTOR;
pub const SQPE_IGNORED_KEYWORD = STRUCTURED_QUERY_PARSE_ERROR.SQPE_IGNORED_KEYWORD;
pub const SQPE_UNHANDLED = STRUCTURED_QUERY_PARSE_ERROR.SQPE_UNHANDLED;

pub const STRUCTURED_QUERY_RESOLVE_OPTION = extern enum(i32) {
    SQRO_DEFAULT = 0,
    SQRO_DONT_RESOLVE_DATETIME = 1,
    SQRO_ALWAYS_ONE_INTERVAL = 2,
    SQRO_DONT_SIMPLIFY_CONDITION_TREES = 4,
    SQRO_DONT_MAP_RELATIONS = 8,
    SQRO_DONT_RESOLVE_RANGES = 16,
    SQRO_DONT_REMOVE_UNRESTRICTED_KEYWORDS = 32,
    SQRO_DONT_SPLIT_WORDS = 64,
    SQRO_IGNORE_PHRASE_ORDER = 128,
    SQRO_ADD_VALUE_TYPE_FOR_PLAIN_VALUES = 256,
    SQRO_ADD_ROBUST_ITEM_NAME = 512,
};
pub const SQRO_DEFAULT = STRUCTURED_QUERY_RESOLVE_OPTION.SQRO_DEFAULT;
pub const SQRO_DONT_RESOLVE_DATETIME = STRUCTURED_QUERY_RESOLVE_OPTION.SQRO_DONT_RESOLVE_DATETIME;
pub const SQRO_ALWAYS_ONE_INTERVAL = STRUCTURED_QUERY_RESOLVE_OPTION.SQRO_ALWAYS_ONE_INTERVAL;
pub const SQRO_DONT_SIMPLIFY_CONDITION_TREES = STRUCTURED_QUERY_RESOLVE_OPTION.SQRO_DONT_SIMPLIFY_CONDITION_TREES;
pub const SQRO_DONT_MAP_RELATIONS = STRUCTURED_QUERY_RESOLVE_OPTION.SQRO_DONT_MAP_RELATIONS;
pub const SQRO_DONT_RESOLVE_RANGES = STRUCTURED_QUERY_RESOLVE_OPTION.SQRO_DONT_RESOLVE_RANGES;
pub const SQRO_DONT_REMOVE_UNRESTRICTED_KEYWORDS = STRUCTURED_QUERY_RESOLVE_OPTION.SQRO_DONT_REMOVE_UNRESTRICTED_KEYWORDS;
pub const SQRO_DONT_SPLIT_WORDS = STRUCTURED_QUERY_RESOLVE_OPTION.SQRO_DONT_SPLIT_WORDS;
pub const SQRO_IGNORE_PHRASE_ORDER = STRUCTURED_QUERY_RESOLVE_OPTION.SQRO_IGNORE_PHRASE_ORDER;
pub const SQRO_ADD_VALUE_TYPE_FOR_PLAIN_VALUES = STRUCTURED_QUERY_RESOLVE_OPTION.SQRO_ADD_VALUE_TYPE_FOR_PLAIN_VALUES;
pub const SQRO_ADD_ROBUST_ITEM_NAME = STRUCTURED_QUERY_RESOLVE_OPTION.SQRO_ADD_ROBUST_ITEM_NAME;

pub const CASE_REQUIREMENT = extern enum(i32) {
    ANY = 0,
    UPPER_IF_AQS = 1,
};
pub const CASE_REQUIREMENT_ANY = CASE_REQUIREMENT.ANY;
pub const CASE_REQUIREMENT_UPPER_IF_AQS = CASE_REQUIREMENT.UPPER_IF_AQS;

pub const INTERVAL_LIMIT_KIND = extern enum(i32) {
    ILK_EXPLICIT_INCLUDED = 0,
    ILK_EXPLICIT_EXCLUDED = 1,
    ILK_NEGATIVE_INFINITY = 2,
    ILK_POSITIVE_INFINITY = 3,
};
pub const ILK_EXPLICIT_INCLUDED = INTERVAL_LIMIT_KIND.ILK_EXPLICIT_INCLUDED;
pub const ILK_EXPLICIT_EXCLUDED = INTERVAL_LIMIT_KIND.ILK_EXPLICIT_EXCLUDED;
pub const ILK_NEGATIVE_INFINITY = INTERVAL_LIMIT_KIND.ILK_NEGATIVE_INFINITY;
pub const ILK_POSITIVE_INFINITY = INTERVAL_LIMIT_KIND.ILK_POSITIVE_INFINITY;

pub const QUERY_PARSER_MANAGER_OPTION = extern enum(i32) {
    QPMO_SCHEMA_BINARY_NAME = 0,
    QPMO_PRELOCALIZED_SCHEMA_BINARY_PATH = 1,
    QPMO_UNLOCALIZED_SCHEMA_BINARY_PATH = 2,
    QPMO_LOCALIZED_SCHEMA_BINARY_PATH = 3,
    QPMO_APPEND_LCID_TO_LOCALIZED_PATH = 4,
    QPMO_LOCALIZER_SUPPORT = 5,
};
pub const QPMO_SCHEMA_BINARY_NAME = QUERY_PARSER_MANAGER_OPTION.QPMO_SCHEMA_BINARY_NAME;
pub const QPMO_PRELOCALIZED_SCHEMA_BINARY_PATH = QUERY_PARSER_MANAGER_OPTION.QPMO_PRELOCALIZED_SCHEMA_BINARY_PATH;
pub const QPMO_UNLOCALIZED_SCHEMA_BINARY_PATH = QUERY_PARSER_MANAGER_OPTION.QPMO_UNLOCALIZED_SCHEMA_BINARY_PATH;
pub const QPMO_LOCALIZED_SCHEMA_BINARY_PATH = QUERY_PARSER_MANAGER_OPTION.QPMO_LOCALIZED_SCHEMA_BINARY_PATH;
pub const QPMO_APPEND_LCID_TO_LOCALIZED_PATH = QUERY_PARSER_MANAGER_OPTION.QPMO_APPEND_LCID_TO_LOCALIZED_PATH;
pub const QPMO_LOCALIZER_SUPPORT = QUERY_PARSER_MANAGER_OPTION.QPMO_LOCALIZER_SUPPORT;

const IID_IQueryParser_Value = @import("../zig.zig").Guid.initString("2EBDEE67-3505-43F8-9946-EA44ABC8E5B0");
pub const IID_IQueryParser = &IID_IQueryParser_Value;
pub const IQueryParser = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Parse: fn(
            self: *const IQueryParser,
            pszInputString: [*:0]const u16,
            pCustomProperties: *IEnumUnknown,
            ppSolution: **IQuerySolution,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOption: fn(
            self: *const IQueryParser,
            option: STRUCTURED_QUERY_SINGLE_OPTION,
            pOptionValue: *const PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOption: fn(
            self: *const IQueryParser,
            option: STRUCTURED_QUERY_SINGLE_OPTION,
            pOptionValue: *PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMultiOption: fn(
            self: *const IQueryParser,
            option: STRUCTURED_QUERY_MULTIOPTION,
            pszOptionKey: [*:0]const u16,
            pOptionValue: *const PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSchemaProvider: fn(
            self: *const IQueryParser,
            ppSchemaProvider: **ISchemaProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RestateToString: fn(
            self: *const IQueryParser,
            pCondition: *ICondition,
            fUseEnglish: BOOL,
            ppszQueryString: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ParsePropertyValue: fn(
            self: *const IQueryParser,
            pszPropertyName: [*:0]const u16,
            pszInputString: [*:0]const u16,
            ppSolution: **IQuerySolution,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RestatePropertyValueToString: fn(
            self: *const IQueryParser,
            pCondition: *ICondition,
            fUseEnglish: BOOL,
            ppszPropertyName: *PWSTR,
            ppszQueryString: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQueryParser_Parse(self: *const T, pszInputString: [*:0]const u16, pCustomProperties: *IEnumUnknown, ppSolution: **IQuerySolution) callconv(.Inline) HRESULT {
            return @ptrCast(*const IQueryParser.VTable, self.vtable).Parse(@ptrCast(*const IQueryParser, self), pszInputString, pCustomProperties, ppSolution);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQueryParser_SetOption(self: *const T, option: STRUCTURED_QUERY_SINGLE_OPTION, pOptionValue: *const PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IQueryParser.VTable, self.vtable).SetOption(@ptrCast(*const IQueryParser, self), option, pOptionValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQueryParser_GetOption(self: *const T, option: STRUCTURED_QUERY_SINGLE_OPTION, pOptionValue: *PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IQueryParser.VTable, self.vtable).GetOption(@ptrCast(*const IQueryParser, self), option, pOptionValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQueryParser_SetMultiOption(self: *const T, option: STRUCTURED_QUERY_MULTIOPTION, pszOptionKey: [*:0]const u16, pOptionValue: *const PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IQueryParser.VTable, self.vtable).SetMultiOption(@ptrCast(*const IQueryParser, self), option, pszOptionKey, pOptionValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQueryParser_GetSchemaProvider(self: *const T, ppSchemaProvider: **ISchemaProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const IQueryParser.VTable, self.vtable).GetSchemaProvider(@ptrCast(*const IQueryParser, self), ppSchemaProvider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQueryParser_RestateToString(self: *const T, pCondition: *ICondition, fUseEnglish: BOOL, ppszQueryString: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IQueryParser.VTable, self.vtable).RestateToString(@ptrCast(*const IQueryParser, self), pCondition, fUseEnglish, ppszQueryString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQueryParser_ParsePropertyValue(self: *const T, pszPropertyName: [*:0]const u16, pszInputString: [*:0]const u16, ppSolution: **IQuerySolution) callconv(.Inline) HRESULT {
            return @ptrCast(*const IQueryParser.VTable, self.vtable).ParsePropertyValue(@ptrCast(*const IQueryParser, self), pszPropertyName, pszInputString, ppSolution);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQueryParser_RestatePropertyValueToString(self: *const T, pCondition: *ICondition, fUseEnglish: BOOL, ppszPropertyName: *PWSTR, ppszQueryString: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IQueryParser.VTable, self.vtable).RestatePropertyValueToString(@ptrCast(*const IQueryParser, self), pCondition, fUseEnglish, ppszPropertyName, ppszQueryString);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IConditionFactory_Value = @import("../zig.zig").Guid.initString("A5EFE073-B16F-474F-9F3E-9F8B497A3E08");
pub const IID_IConditionFactory = &IID_IConditionFactory_Value;
pub const IConditionFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        MakeNot: fn(
            self: *const IConditionFactory,
            pcSub: *ICondition,
            fSimplify: BOOL,
            ppcResult: **ICondition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MakeAndOr: fn(
            self: *const IConditionFactory,
            ct: CONDITION_TYPE,
            peuSubs: *IEnumUnknown,
            fSimplify: BOOL,
            ppcResult: **ICondition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MakeLeaf: fn(
            self: *const IConditionFactory,
            pszPropertyName: [*:0]const u16,
            cop: CONDITION_OPERATION,
            pszValueType: [*:0]const u16,
            ppropvar: *const PROPVARIANT,
            pPropertyNameTerm: *IRichChunk,
            pOperationTerm: *IRichChunk,
            pValueTerm: *IRichChunk,
            fExpand: BOOL,
            ppcResult: **ICondition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Resolve: fn(
            self: *const IConditionFactory,
            pc: *ICondition,
            sqro: STRUCTURED_QUERY_RESOLVE_OPTION,
            pstReferenceTime: ?*const SYSTEMTIME,
            ppcResolved: **ICondition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConditionFactory_MakeNot(self: *const T, pcSub: *ICondition, fSimplify: BOOL, ppcResult: **ICondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConditionFactory.VTable, self.vtable).MakeNot(@ptrCast(*const IConditionFactory, self), pcSub, fSimplify, ppcResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConditionFactory_MakeAndOr(self: *const T, ct: CONDITION_TYPE, peuSubs: *IEnumUnknown, fSimplify: BOOL, ppcResult: **ICondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConditionFactory.VTable, self.vtable).MakeAndOr(@ptrCast(*const IConditionFactory, self), ct, peuSubs, fSimplify, ppcResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConditionFactory_MakeLeaf(self: *const T, pszPropertyName: [*:0]const u16, cop: CONDITION_OPERATION, pszValueType: [*:0]const u16, ppropvar: *const PROPVARIANT, pPropertyNameTerm: *IRichChunk, pOperationTerm: *IRichChunk, pValueTerm: *IRichChunk, fExpand: BOOL, ppcResult: **ICondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConditionFactory.VTable, self.vtable).MakeLeaf(@ptrCast(*const IConditionFactory, self), pszPropertyName, cop, pszValueType, ppropvar, pPropertyNameTerm, pOperationTerm, pValueTerm, fExpand, ppcResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConditionFactory_Resolve(self: *const T, pc: *ICondition, sqro: STRUCTURED_QUERY_RESOLVE_OPTION, pstReferenceTime: ?*const SYSTEMTIME, ppcResolved: **ICondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConditionFactory.VTable, self.vtable).Resolve(@ptrCast(*const IConditionFactory, self), pc, sqro, pstReferenceTime, ppcResolved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IQuerySolution_Value = @import("../zig.zig").Guid.initString("D6EBC66B-8921-4193-AFDD-A1789FB7FF57");
pub const IID_IQuerySolution = &IID_IQuerySolution_Value;
pub const IQuerySolution = extern struct {
    pub const VTable = extern struct {
        base: IConditionFactory.VTable,
        GetQuery: fn(
            self: *const IQuerySolution,
            ppQueryNode: ?*?*ICondition,
            ppMainType: ?*?*IEntity,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetErrors: fn(
            self: *const IQuerySolution,
            riid: *const Guid,
            ppParseErrors: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLexicalData: fn(
            self: *const IQuerySolution,
            ppszInputString: ?*?PWSTR,
            ppTokens: ?*?*ITokenCollection,
            plcid: ?*u32,
            ppWordBreaker: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IConditionFactory.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQuerySolution_GetQuery(self: *const T, ppQueryNode: ?*?*ICondition, ppMainType: ?*?*IEntity) callconv(.Inline) HRESULT {
            return @ptrCast(*const IQuerySolution.VTable, self.vtable).GetQuery(@ptrCast(*const IQuerySolution, self), ppQueryNode, ppMainType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQuerySolution_GetErrors(self: *const T, riid: *const Guid, ppParseErrors: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IQuerySolution.VTable, self.vtable).GetErrors(@ptrCast(*const IQuerySolution, self), riid, ppParseErrors);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQuerySolution_GetLexicalData(self: *const T, ppszInputString: ?*?PWSTR, ppTokens: ?*?*ITokenCollection, plcid: ?*u32, ppWordBreaker: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IQuerySolution.VTable, self.vtable).GetLexicalData(@ptrCast(*const IQuerySolution, self), ppszInputString, ppTokens, plcid, ppWordBreaker);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CONDITION_CREATION_OPTIONS = extern enum(i32) {
    CONDITION_CREATION_DEFAULT = 0,
    CONDITION_CREATION_NONE = 0,
    CONDITION_CREATION_SIMPLIFY = 1,
    CONDITION_CREATION_VECTOR_AND = 2,
    CONDITION_CREATION_VECTOR_OR = 4,
    CONDITION_CREATION_VECTOR_LEAF = 8,
    CONDITION_CREATION_USE_CONTENT_LOCALE = 16,
};
pub const CONDITION_CREATION_DEFAULT = CONDITION_CREATION_OPTIONS.CONDITION_CREATION_DEFAULT;
pub const CONDITION_CREATION_NONE = CONDITION_CREATION_OPTIONS.CONDITION_CREATION_NONE;
pub const CONDITION_CREATION_SIMPLIFY = CONDITION_CREATION_OPTIONS.CONDITION_CREATION_SIMPLIFY;
pub const CONDITION_CREATION_VECTOR_AND = CONDITION_CREATION_OPTIONS.CONDITION_CREATION_VECTOR_AND;
pub const CONDITION_CREATION_VECTOR_OR = CONDITION_CREATION_OPTIONS.CONDITION_CREATION_VECTOR_OR;
pub const CONDITION_CREATION_VECTOR_LEAF = CONDITION_CREATION_OPTIONS.CONDITION_CREATION_VECTOR_LEAF;
pub const CONDITION_CREATION_USE_CONTENT_LOCALE = CONDITION_CREATION_OPTIONS.CONDITION_CREATION_USE_CONTENT_LOCALE;

const IID_IConditionFactory2_Value = @import("../zig.zig").Guid.initString("71D222E1-432F-429E-8C13-B6DAFDE5077A");
pub const IID_IConditionFactory2 = &IID_IConditionFactory2_Value;
pub const IConditionFactory2 = extern struct {
    pub const VTable = extern struct {
        base: IConditionFactory.VTable,
        CreateTrueFalse: fn(
            self: *const IConditionFactory2,
            fVal: BOOL,
            cco: CONDITION_CREATION_OPTIONS,
            riid: *const Guid,
            ppv: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateNegation: fn(
            self: *const IConditionFactory2,
            pcSub: *ICondition,
            cco: CONDITION_CREATION_OPTIONS,
            riid: *const Guid,
            ppv: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateCompoundFromObjectArray: fn(
            self: *const IConditionFactory2,
            ct: CONDITION_TYPE,
            poaSubs: ?*IObjectArray,
            cco: CONDITION_CREATION_OPTIONS,
            riid: *const Guid,
            ppv: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateCompoundFromArray: fn(
            self: *const IConditionFactory2,
            ct: CONDITION_TYPE,
            ppcondSubs: [*]*ICondition,
            cSubs: u32,
            cco: CONDITION_CREATION_OPTIONS,
            riid: *const Guid,
            ppv: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateStringLeaf: fn(
            self: *const IConditionFactory2,
            propkey: *const PROPERTYKEY,
            cop: CONDITION_OPERATION,
            pszValue: [*:0]const u16,
            pszLocaleName: ?[*:0]const u16,
            cco: CONDITION_CREATION_OPTIONS,
            riid: *const Guid,
            ppv: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateIntegerLeaf: fn(
            self: *const IConditionFactory2,
            propkey: *const PROPERTYKEY,
            cop: CONDITION_OPERATION,
            lValue: i32,
            cco: CONDITION_CREATION_OPTIONS,
            riid: *const Guid,
            ppv: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateBooleanLeaf: fn(
            self: *const IConditionFactory2,
            propkey: *const PROPERTYKEY,
            cop: CONDITION_OPERATION,
            fValue: BOOL,
            cco: CONDITION_CREATION_OPTIONS,
            riid: *const Guid,
            ppv: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateLeaf: fn(
            self: *const IConditionFactory2,
            propkey: *const PROPERTYKEY,
            cop: CONDITION_OPERATION,
            propvar: *const PROPVARIANT,
            pszSemanticType: ?[*:0]const u16,
            pszLocaleName: ?[*:0]const u16,
            pPropertyNameTerm: ?*IRichChunk,
            pOperationTerm: ?*IRichChunk,
            pValueTerm: ?*IRichChunk,
            cco: CONDITION_CREATION_OPTIONS,
            riid: *const Guid,
            ppv: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResolveCondition: fn(
            self: *const IConditionFactory2,
            pc: *ICondition,
            sqro: STRUCTURED_QUERY_RESOLVE_OPTION,
            pstReferenceTime: ?*const SYSTEMTIME,
            riid: *const Guid,
            ppv: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IConditionFactory.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConditionFactory2_CreateTrueFalse(self: *const T, fVal: BOOL, cco: CONDITION_CREATION_OPTIONS, riid: *const Guid, ppv: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConditionFactory2.VTable, self.vtable).CreateTrueFalse(@ptrCast(*const IConditionFactory2, self), fVal, cco, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConditionFactory2_CreateNegation(self: *const T, pcSub: *ICondition, cco: CONDITION_CREATION_OPTIONS, riid: *const Guid, ppv: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConditionFactory2.VTable, self.vtable).CreateNegation(@ptrCast(*const IConditionFactory2, self), pcSub, cco, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConditionFactory2_CreateCompoundFromObjectArray(self: *const T, ct: CONDITION_TYPE, poaSubs: ?*IObjectArray, cco: CONDITION_CREATION_OPTIONS, riid: *const Guid, ppv: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConditionFactory2.VTable, self.vtable).CreateCompoundFromObjectArray(@ptrCast(*const IConditionFactory2, self), ct, poaSubs, cco, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConditionFactory2_CreateCompoundFromArray(self: *const T, ct: CONDITION_TYPE, ppcondSubs: [*]*ICondition, cSubs: u32, cco: CONDITION_CREATION_OPTIONS, riid: *const Guid, ppv: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConditionFactory2.VTable, self.vtable).CreateCompoundFromArray(@ptrCast(*const IConditionFactory2, self), ct, ppcondSubs, cSubs, cco, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConditionFactory2_CreateStringLeaf(self: *const T, propkey: *const PROPERTYKEY, cop: CONDITION_OPERATION, pszValue: [*:0]const u16, pszLocaleName: ?[*:0]const u16, cco: CONDITION_CREATION_OPTIONS, riid: *const Guid, ppv: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConditionFactory2.VTable, self.vtable).CreateStringLeaf(@ptrCast(*const IConditionFactory2, self), propkey, cop, pszValue, pszLocaleName, cco, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConditionFactory2_CreateIntegerLeaf(self: *const T, propkey: *const PROPERTYKEY, cop: CONDITION_OPERATION, lValue: i32, cco: CONDITION_CREATION_OPTIONS, riid: *const Guid, ppv: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConditionFactory2.VTable, self.vtable).CreateIntegerLeaf(@ptrCast(*const IConditionFactory2, self), propkey, cop, lValue, cco, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConditionFactory2_CreateBooleanLeaf(self: *const T, propkey: *const PROPERTYKEY, cop: CONDITION_OPERATION, fValue: BOOL, cco: CONDITION_CREATION_OPTIONS, riid: *const Guid, ppv: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConditionFactory2.VTable, self.vtable).CreateBooleanLeaf(@ptrCast(*const IConditionFactory2, self), propkey, cop, fValue, cco, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConditionFactory2_CreateLeaf(self: *const T, propkey: *const PROPERTYKEY, cop: CONDITION_OPERATION, propvar: *const PROPVARIANT, pszSemanticType: ?[*:0]const u16, pszLocaleName: ?[*:0]const u16, pPropertyNameTerm: ?*IRichChunk, pOperationTerm: ?*IRichChunk, pValueTerm: ?*IRichChunk, cco: CONDITION_CREATION_OPTIONS, riid: *const Guid, ppv: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConditionFactory2.VTable, self.vtable).CreateLeaf(@ptrCast(*const IConditionFactory2, self), propkey, cop, propvar, pszSemanticType, pszLocaleName, pPropertyNameTerm, pOperationTerm, pValueTerm, cco, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConditionFactory2_ResolveCondition(self: *const T, pc: *ICondition, sqro: STRUCTURED_QUERY_RESOLVE_OPTION, pstReferenceTime: ?*const SYSTEMTIME, riid: *const Guid, ppv: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConditionFactory2.VTable, self.vtable).ResolveCondition(@ptrCast(*const IConditionFactory2, self), pc, sqro, pstReferenceTime, riid, ppv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IConditionGenerator_Value = @import("../zig.zig").Guid.initString("92D2CC58-4386-45A3-B98C-7E0CE64A4117");
pub const IID_IConditionGenerator = &IID_IConditionGenerator_Value;
pub const IConditionGenerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IConditionGenerator,
            pSchemaProvider: *ISchemaProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RecognizeNamedEntities: fn(
            self: *const IConditionGenerator,
            pszInputString: [*:0]const u16,
            lcidUserLocale: u32,
            pTokenCollection: *ITokenCollection,
            pNamedEntities: *INamedEntityCollector,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GenerateForLeaf: fn(
            self: *const IConditionGenerator,
            pConditionFactory: *IConditionFactory,
            pszPropertyName: [*:0]const u16,
            cop: CONDITION_OPERATION,
            pszValueType: [*:0]const u16,
            pszValue: [*:0]const u16,
            pszValue2: [*:0]const u16,
            pPropertyNameTerm: *IRichChunk,
            pOperationTerm: *IRichChunk,
            pValueTerm: *IRichChunk,
            automaticWildcard: BOOL,
            pNoStringQuery: *BOOL,
            ppQueryExpression: **ICondition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DefaultPhrase: fn(
            self: *const IConditionGenerator,
            pszValueType: [*:0]const u16,
            ppropvar: *const PROPVARIANT,
            fUseEnglish: BOOL,
            ppszPhrase: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConditionGenerator_Initialize(self: *const T, pSchemaProvider: *ISchemaProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConditionGenerator.VTable, self.vtable).Initialize(@ptrCast(*const IConditionGenerator, self), pSchemaProvider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConditionGenerator_RecognizeNamedEntities(self: *const T, pszInputString: [*:0]const u16, lcidUserLocale: u32, pTokenCollection: *ITokenCollection, pNamedEntities: *INamedEntityCollector) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConditionGenerator.VTable, self.vtable).RecognizeNamedEntities(@ptrCast(*const IConditionGenerator, self), pszInputString, lcidUserLocale, pTokenCollection, pNamedEntities);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConditionGenerator_GenerateForLeaf(self: *const T, pConditionFactory: *IConditionFactory, pszPropertyName: [*:0]const u16, cop: CONDITION_OPERATION, pszValueType: [*:0]const u16, pszValue: [*:0]const u16, pszValue2: [*:0]const u16, pPropertyNameTerm: *IRichChunk, pOperationTerm: *IRichChunk, pValueTerm: *IRichChunk, automaticWildcard: BOOL, pNoStringQuery: *BOOL, ppQueryExpression: **ICondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConditionGenerator.VTable, self.vtable).GenerateForLeaf(@ptrCast(*const IConditionGenerator, self), pConditionFactory, pszPropertyName, cop, pszValueType, pszValue, pszValue2, pPropertyNameTerm, pOperationTerm, pValueTerm, automaticWildcard, pNoStringQuery, ppQueryExpression);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IConditionGenerator_DefaultPhrase(self: *const T, pszValueType: [*:0]const u16, ppropvar: *const PROPVARIANT, fUseEnglish: BOOL, ppszPhrase: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IConditionGenerator.VTable, self.vtable).DefaultPhrase(@ptrCast(*const IConditionGenerator, self), pszValueType, ppropvar, fUseEnglish, ppszPhrase);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IInterval_Value = @import("../zig.zig").Guid.initString("6BF0A714-3C18-430B-8B5D-83B1C234D3DB");
pub const IID_IInterval = &IID_IInterval_Value;
pub const IInterval = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLimits: fn(
            self: *const IInterval,
            pilkLower: *INTERVAL_LIMIT_KIND,
            ppropvarLower: *PROPVARIANT,
            pilkUpper: *INTERVAL_LIMIT_KIND,
            ppropvarUpper: *PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInterval_GetLimits(self: *const T, pilkLower: *INTERVAL_LIMIT_KIND, ppropvarLower: *PROPVARIANT, pilkUpper: *INTERVAL_LIMIT_KIND, ppropvarUpper: *PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInterval.VTable, self.vtable).GetLimits(@ptrCast(*const IInterval, self), pilkLower, ppropvarLower, pilkUpper, ppropvarUpper);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMetaData_Value = @import("../zig.zig").Guid.initString("780102B0-C43B-4876-BC7B-5E9BA5C88794");
pub const IID_IMetaData = &IID_IMetaData_Value;
pub const IMetaData = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetData: fn(
            self: *const IMetaData,
            ppszKey: ?*?PWSTR,
            ppszValue: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMetaData_GetData(self: *const T, ppszKey: ?*?PWSTR, ppszValue: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMetaData.VTable, self.vtable).GetData(@ptrCast(*const IMetaData, self), ppszKey, ppszValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEntity_Value = @import("../zig.zig").Guid.initString("24264891-E80B-4FD3-B7CE-4FF2FAE8931F");
pub const IID_IEntity = &IID_IEntity_Value;
pub const IEntity = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Name: fn(
            self: *const IEntity,
            ppszName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Base: fn(
            self: *const IEntity,
            pBaseEntity: **IEntity,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Relationships: fn(
            self: *const IEntity,
            riid: *const Guid,
            pRelationships: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRelationship: fn(
            self: *const IEntity,
            pszRelationName: [*:0]const u16,
            pRelationship: **IRelationship,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MetaData: fn(
            self: *const IEntity,
            riid: *const Guid,
            pMetaData: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NamedEntities: fn(
            self: *const IEntity,
            riid: *const Guid,
            pNamedEntities: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNamedEntity: fn(
            self: *const IEntity,
            pszValue: [*:0]const u16,
            ppNamedEntity: **INamedEntity,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DefaultPhrase: fn(
            self: *const IEntity,
            ppszPhrase: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEntity_Name(self: *const T, ppszName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEntity.VTable, self.vtable).Name(@ptrCast(*const IEntity, self), ppszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEntity_Base(self: *const T, pBaseEntity: **IEntity) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEntity.VTable, self.vtable).Base(@ptrCast(*const IEntity, self), pBaseEntity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEntity_Relationships(self: *const T, riid: *const Guid, pRelationships: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEntity.VTable, self.vtable).Relationships(@ptrCast(*const IEntity, self), riid, pRelationships);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEntity_GetRelationship(self: *const T, pszRelationName: [*:0]const u16, pRelationship: **IRelationship) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEntity.VTable, self.vtable).GetRelationship(@ptrCast(*const IEntity, self), pszRelationName, pRelationship);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEntity_MetaData(self: *const T, riid: *const Guid, pMetaData: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEntity.VTable, self.vtable).MetaData(@ptrCast(*const IEntity, self), riid, pMetaData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEntity_NamedEntities(self: *const T, riid: *const Guid, pNamedEntities: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEntity.VTable, self.vtable).NamedEntities(@ptrCast(*const IEntity, self), riid, pNamedEntities);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEntity_GetNamedEntity(self: *const T, pszValue: [*:0]const u16, ppNamedEntity: **INamedEntity) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEntity.VTable, self.vtable).GetNamedEntity(@ptrCast(*const IEntity, self), pszValue, ppNamedEntity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEntity_DefaultPhrase(self: *const T, ppszPhrase: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEntity.VTable, self.vtable).DefaultPhrase(@ptrCast(*const IEntity, self), ppszPhrase);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRelationship_Value = @import("../zig.zig").Guid.initString("2769280B-5108-498C-9C7F-A51239B63147");
pub const IID_IRelationship = &IID_IRelationship_Value;
pub const IRelationship = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Name: fn(
            self: *const IRelationship,
            ppszName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsReal: fn(
            self: *const IRelationship,
            pIsReal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Destination: fn(
            self: *const IRelationship,
            pDestinationEntity: **IEntity,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MetaData: fn(
            self: *const IRelationship,
            riid: *const Guid,
            pMetaData: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DefaultPhrase: fn(
            self: *const IRelationship,
            ppszPhrase: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRelationship_Name(self: *const T, ppszName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRelationship.VTable, self.vtable).Name(@ptrCast(*const IRelationship, self), ppszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRelationship_IsReal(self: *const T, pIsReal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRelationship.VTable, self.vtable).IsReal(@ptrCast(*const IRelationship, self), pIsReal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRelationship_Destination(self: *const T, pDestinationEntity: **IEntity) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRelationship.VTable, self.vtable).Destination(@ptrCast(*const IRelationship, self), pDestinationEntity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRelationship_MetaData(self: *const T, riid: *const Guid, pMetaData: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRelationship.VTable, self.vtable).MetaData(@ptrCast(*const IRelationship, self), riid, pMetaData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRelationship_DefaultPhrase(self: *const T, ppszPhrase: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRelationship.VTable, self.vtable).DefaultPhrase(@ptrCast(*const IRelationship, self), ppszPhrase);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_INamedEntity_Value = @import("../zig.zig").Guid.initString("ABDBD0B1-7D54-49FB-AB5C-BFF4130004CD");
pub const IID_INamedEntity = &IID_INamedEntity_Value;
pub const INamedEntity = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetValue: fn(
            self: *const INamedEntity,
            ppszValue: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DefaultPhrase: fn(
            self: *const INamedEntity,
            ppszPhrase: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INamedEntity_GetValue(self: *const T, ppszValue: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INamedEntity.VTable, self.vtable).GetValue(@ptrCast(*const INamedEntity, self), ppszValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INamedEntity_DefaultPhrase(self: *const T, ppszPhrase: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INamedEntity.VTable, self.vtable).DefaultPhrase(@ptrCast(*const INamedEntity, self), ppszPhrase);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISchemaProvider_Value = @import("../zig.zig").Guid.initString("8CF89BCB-394C-49B2-AE28-A59DD4ED7F68");
pub const IID_ISchemaProvider = &IID_ISchemaProvider_Value;
pub const ISchemaProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Entities: fn(
            self: *const ISchemaProvider,
            riid: *const Guid,
            pEntities: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RootEntity: fn(
            self: *const ISchemaProvider,
            pRootEntity: **IEntity,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEntity: fn(
            self: *const ISchemaProvider,
            pszEntityName: [*:0]const u16,
            pEntity: **IEntity,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MetaData: fn(
            self: *const ISchemaProvider,
            riid: *const Guid,
            pMetaData: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Localize: fn(
            self: *const ISchemaProvider,
            lcid: u32,
            pSchemaLocalizerSupport: *ISchemaLocalizerSupport,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveBinary: fn(
            self: *const ISchemaProvider,
            pszSchemaBinaryPath: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LookupAuthoredNamedEntity: fn(
            self: *const ISchemaProvider,
            pEntity: *IEntity,
            pszInputString: [*:0]const u16,
            pTokenCollection: *ITokenCollection,
            cTokensBegin: u32,
            pcTokensLength: *u32,
            ppszValue: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaProvider_Entities(self: *const T, riid: *const Guid, pEntities: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaProvider.VTable, self.vtable).Entities(@ptrCast(*const ISchemaProvider, self), riid, pEntities);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaProvider_RootEntity(self: *const T, pRootEntity: **IEntity) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaProvider.VTable, self.vtable).RootEntity(@ptrCast(*const ISchemaProvider, self), pRootEntity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaProvider_GetEntity(self: *const T, pszEntityName: [*:0]const u16, pEntity: **IEntity) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaProvider.VTable, self.vtable).GetEntity(@ptrCast(*const ISchemaProvider, self), pszEntityName, pEntity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaProvider_MetaData(self: *const T, riid: *const Guid, pMetaData: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaProvider.VTable, self.vtable).MetaData(@ptrCast(*const ISchemaProvider, self), riid, pMetaData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaProvider_Localize(self: *const T, lcid: u32, pSchemaLocalizerSupport: *ISchemaLocalizerSupport) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaProvider.VTable, self.vtable).Localize(@ptrCast(*const ISchemaProvider, self), lcid, pSchemaLocalizerSupport);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaProvider_SaveBinary(self: *const T, pszSchemaBinaryPath: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaProvider.VTable, self.vtable).SaveBinary(@ptrCast(*const ISchemaProvider, self), pszSchemaBinaryPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaProvider_LookupAuthoredNamedEntity(self: *const T, pEntity: *IEntity, pszInputString: [*:0]const u16, pTokenCollection: *ITokenCollection, cTokensBegin: u32, pcTokensLength: *u32, ppszValue: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaProvider.VTable, self.vtable).LookupAuthoredNamedEntity(@ptrCast(*const ISchemaProvider, self), pEntity, pszInputString, pTokenCollection, cTokensBegin, pcTokensLength, ppszValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITokenCollection_Value = @import("../zig.zig").Guid.initString("22D8B4F2-F577-4ADB-A335-C2AE88416FAB");
pub const IID_ITokenCollection = &IID_ITokenCollection_Value;
pub const ITokenCollection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NumberOfTokens: fn(
            self: *const ITokenCollection,
            pCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetToken: fn(
            self: *const ITokenCollection,
            i: u32,
            pBegin: ?*u32,
            pLength: ?*u32,
            ppsz: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITokenCollection_NumberOfTokens(self: *const T, pCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITokenCollection.VTable, self.vtable).NumberOfTokens(@ptrCast(*const ITokenCollection, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITokenCollection_GetToken(self: *const T, i: u32, pBegin: ?*u32, pLength: ?*u32, ppsz: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITokenCollection.VTable, self.vtable).GetToken(@ptrCast(*const ITokenCollection, self), i, pBegin, pLength, ppsz);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const NAMED_ENTITY_CERTAINTY = extern enum(i32) {
    NEC_LOW = 0,
    NEC_MEDIUM = 1,
    NEC_HIGH = 2,
};
pub const NEC_LOW = NAMED_ENTITY_CERTAINTY.NEC_LOW;
pub const NEC_MEDIUM = NAMED_ENTITY_CERTAINTY.NEC_MEDIUM;
pub const NEC_HIGH = NAMED_ENTITY_CERTAINTY.NEC_HIGH;

const IID_INamedEntityCollector_Value = @import("../zig.zig").Guid.initString("AF2440F6-8AFC-47D0-9A7F-396A0ACFB43D");
pub const IID_INamedEntityCollector = &IID_INamedEntityCollector_Value;
pub const INamedEntityCollector = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Add: fn(
            self: *const INamedEntityCollector,
            beginSpan: u32,
            endSpan: u32,
            beginActual: u32,
            endActual: u32,
            pType: *IEntity,
            pszValue: [*:0]const u16,
            certainty: NAMED_ENTITY_CERTAINTY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INamedEntityCollector_Add(self: *const T, beginSpan: u32, endSpan: u32, beginActual: u32, endActual: u32, pType: *IEntity, pszValue: [*:0]const u16, certainty: NAMED_ENTITY_CERTAINTY) callconv(.Inline) HRESULT {
            return @ptrCast(*const INamedEntityCollector.VTable, self.vtable).Add(@ptrCast(*const INamedEntityCollector, self), beginSpan, endSpan, beginActual, endActual, pType, pszValue, certainty);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISchemaLocalizerSupport_Value = @import("../zig.zig").Guid.initString("CA3FDCA2-BFBE-4EED-90D7-0CAEF0A1BDA1");
pub const IID_ISchemaLocalizerSupport = &IID_ISchemaLocalizerSupport_Value;
pub const ISchemaLocalizerSupport = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Localize: fn(
            self: *const ISchemaLocalizerSupport,
            pszGlobalString: [*:0]const u16,
            ppszLocalString: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISchemaLocalizerSupport_Localize(self: *const T, pszGlobalString: [*:0]const u16, ppszLocalString: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISchemaLocalizerSupport.VTable, self.vtable).Localize(@ptrCast(*const ISchemaLocalizerSupport, self), pszGlobalString, ppszLocalString);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IQueryParserManager_Value = @import("../zig.zig").Guid.initString("A879E3C4-AF77-44FB-8F37-EBD1487CF920");
pub const IID_IQueryParserManager = &IID_IQueryParserManager_Value;
pub const IQueryParserManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateLoadedParser: fn(
            self: *const IQueryParserManager,
            pszCatalog: [*:0]const u16,
            langidForKeywords: u16,
            riid: *const Guid,
            ppQueryParser: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeOptions: fn(
            self: *const IQueryParserManager,
            fUnderstandNQS: BOOL,
            fAutoWildCard: BOOL,
            pQueryParser: *IQueryParser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOption: fn(
            self: *const IQueryParserManager,
            option: QUERY_PARSER_MANAGER_OPTION,
            pOptionValue: *const PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQueryParserManager_CreateLoadedParser(self: *const T, pszCatalog: [*:0]const u16, langidForKeywords: u16, riid: *const Guid, ppQueryParser: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IQueryParserManager.VTable, self.vtable).CreateLoadedParser(@ptrCast(*const IQueryParserManager, self), pszCatalog, langidForKeywords, riid, ppQueryParser);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQueryParserManager_InitializeOptions(self: *const T, fUnderstandNQS: BOOL, fAutoWildCard: BOOL, pQueryParser: *IQueryParser) callconv(.Inline) HRESULT {
            return @ptrCast(*const IQueryParserManager.VTable, self.vtable).InitializeOptions(@ptrCast(*const IQueryParserManager, self), fUnderstandNQS, fAutoWildCard, pQueryParser);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IQueryParserManager_SetOption(self: *const T, option: QUERY_PARSER_MANAGER_OPTION, pOptionValue: *const PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IQueryParserManager.VTable, self.vtable).SetOption(@ptrCast(*const IQueryParserManager, self), option, pOptionValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const HITRANGE = extern struct {
    iPosition: u32,
    cLength: u32,
};

const IID_IUrlAccessor_Value = @import("../zig.zig").Guid.initString("0B63E318-9CCC-11D0-BCDB-00805FCCCE04");
pub const IID_IUrlAccessor = &IID_IUrlAccessor_Value;
pub const IUrlAccessor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddRequestParameter: fn(
            self: *const IUrlAccessor,
            pSpec: *PROPSPEC,
            pVar: *PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocFormat: fn(
            self: *const IUrlAccessor,
            wszDocFormat: [*:0]u16,
            dwSize: u32,
            pdwLength: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCLSID: fn(
            self: *const IUrlAccessor,
            pClsid: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHost: fn(
            self: *const IUrlAccessor,
            wszHost: [*:0]u16,
            dwSize: u32,
            pdwLength: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsDirectory: fn(
            self: *const IUrlAccessor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSize: fn(
            self: *const IUrlAccessor,
            pllSize: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastModified: fn(
            self: *const IUrlAccessor,
            pftLastModified: *FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFileName: fn(
            self: *const IUrlAccessor,
            wszFileName: [*:0]u16,
            dwSize: u32,
            pdwLength: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSecurityDescriptor: fn(
            self: *const IUrlAccessor,
            pSD: [*:0]u8,
            dwSize: u32,
            pdwLength: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRedirectedURL: fn(
            self: *const IUrlAccessor,
            wszRedirectedURL: [*:0]u16,
            dwSize: u32,
            pdwLength: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSecurityProvider: fn(
            self: *const IUrlAccessor,
            pSPClsid: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BindToStream: fn(
            self: *const IUrlAccessor,
            ppStream: **IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BindToFilter: fn(
            self: *const IUrlAccessor,
            ppFilter: **IFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUrlAccessor_AddRequestParameter(self: *const T, pSpec: *PROPSPEC, pVar: *PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUrlAccessor.VTable, self.vtable).AddRequestParameter(@ptrCast(*const IUrlAccessor, self), pSpec, pVar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUrlAccessor_GetDocFormat(self: *const T, wszDocFormat: [*:0]u16, dwSize: u32, pdwLength: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUrlAccessor.VTable, self.vtable).GetDocFormat(@ptrCast(*const IUrlAccessor, self), wszDocFormat, dwSize, pdwLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUrlAccessor_GetCLSID(self: *const T, pClsid: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUrlAccessor.VTable, self.vtable).GetCLSID(@ptrCast(*const IUrlAccessor, self), pClsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUrlAccessor_GetHost(self: *const T, wszHost: [*:0]u16, dwSize: u32, pdwLength: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUrlAccessor.VTable, self.vtable).GetHost(@ptrCast(*const IUrlAccessor, self), wszHost, dwSize, pdwLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUrlAccessor_IsDirectory(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUrlAccessor.VTable, self.vtable).IsDirectory(@ptrCast(*const IUrlAccessor, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUrlAccessor_GetSize(self: *const T, pllSize: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUrlAccessor.VTable, self.vtable).GetSize(@ptrCast(*const IUrlAccessor, self), pllSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUrlAccessor_GetLastModified(self: *const T, pftLastModified: *FILETIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUrlAccessor.VTable, self.vtable).GetLastModified(@ptrCast(*const IUrlAccessor, self), pftLastModified);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUrlAccessor_GetFileName(self: *const T, wszFileName: [*:0]u16, dwSize: u32, pdwLength: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUrlAccessor.VTable, self.vtable).GetFileName(@ptrCast(*const IUrlAccessor, self), wszFileName, dwSize, pdwLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUrlAccessor_GetSecurityDescriptor(self: *const T, pSD: [*:0]u8, dwSize: u32, pdwLength: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUrlAccessor.VTable, self.vtable).GetSecurityDescriptor(@ptrCast(*const IUrlAccessor, self), pSD, dwSize, pdwLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUrlAccessor_GetRedirectedURL(self: *const T, wszRedirectedURL: [*:0]u16, dwSize: u32, pdwLength: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUrlAccessor.VTable, self.vtable).GetRedirectedURL(@ptrCast(*const IUrlAccessor, self), wszRedirectedURL, dwSize, pdwLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUrlAccessor_GetSecurityProvider(self: *const T, pSPClsid: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUrlAccessor.VTable, self.vtable).GetSecurityProvider(@ptrCast(*const IUrlAccessor, self), pSPClsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUrlAccessor_BindToStream(self: *const T, ppStream: **IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUrlAccessor.VTable, self.vtable).BindToStream(@ptrCast(*const IUrlAccessor, self), ppStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUrlAccessor_BindToFilter(self: *const T, ppFilter: **IFilter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUrlAccessor.VTable, self.vtable).BindToFilter(@ptrCast(*const IUrlAccessor, self), ppFilter);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUrlAccessor2_Value = @import("../zig.zig").Guid.initString("C7310734-AC80-11D1-8DF3-00C04FB6EF4F");
pub const IID_IUrlAccessor2 = &IID_IUrlAccessor2_Value;
pub const IUrlAccessor2 = extern struct {
    pub const VTable = extern struct {
        base: IUrlAccessor.VTable,
        GetDisplayUrl: fn(
            self: *const IUrlAccessor2,
            wszDocUrl: [*:0]u16,
            dwSize: u32,
            pdwLength: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsDocument: fn(
            self: *const IUrlAccessor2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCodePage: fn(
            self: *const IUrlAccessor2,
            wszCodePage: [*:0]u16,
            dwSize: u32,
            pdwLength: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUrlAccessor.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUrlAccessor2_GetDisplayUrl(self: *const T, wszDocUrl: [*:0]u16, dwSize: u32, pdwLength: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUrlAccessor2.VTable, self.vtable).GetDisplayUrl(@ptrCast(*const IUrlAccessor2, self), wszDocUrl, dwSize, pdwLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUrlAccessor2_IsDocument(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUrlAccessor2.VTable, self.vtable).IsDocument(@ptrCast(*const IUrlAccessor2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUrlAccessor2_GetCodePage(self: *const T, wszCodePage: [*:0]u16, dwSize: u32, pdwLength: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUrlAccessor2.VTable, self.vtable).GetCodePage(@ptrCast(*const IUrlAccessor2, self), wszCodePage, dwSize, pdwLength);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUrlAccessor3_Value = @import("../zig.zig").Guid.initString("6FBC7005-0455-4874-B8FF-7439450241A3");
pub const IID_IUrlAccessor3 = &IID_IUrlAccessor3_Value;
pub const IUrlAccessor3 = extern struct {
    pub const VTable = extern struct {
        base: IUrlAccessor2.VTable,
        GetImpersonationSidBlobs: fn(
            self: *const IUrlAccessor3,
            pcwszURL: [*:0]const u16,
            pcSidCount: *u32,
            ppSidBlobs: **BLOB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUrlAccessor2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUrlAccessor3_GetImpersonationSidBlobs(self: *const T, pcwszURL: [*:0]const u16, pcSidCount: *u32, ppSidBlobs: **BLOB) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUrlAccessor3.VTable, self.vtable).GetImpersonationSidBlobs(@ptrCast(*const IUrlAccessor3, self), pcwszURL, pcSidCount, ppSidBlobs);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUrlAccessor4_Value = @import("../zig.zig").Guid.initString("5CC51041-C8D2-41D7-BCA3-9E9E286297DC");
pub const IID_IUrlAccessor4 = &IID_IUrlAccessor4_Value;
pub const IUrlAccessor4 = extern struct {
    pub const VTable = extern struct {
        base: IUrlAccessor3.VTable,
        ShouldIndexItemContent: fn(
            self: *const IUrlAccessor4,
            pfIndexContent: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShouldIndexProperty: fn(
            self: *const IUrlAccessor4,
            key: *const PROPERTYKEY,
            pfIndexProperty: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUrlAccessor3.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUrlAccessor4_ShouldIndexItemContent(self: *const T, pfIndexContent: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUrlAccessor4.VTable, self.vtable).ShouldIndexItemContent(@ptrCast(*const IUrlAccessor4, self), pfIndexContent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUrlAccessor4_ShouldIndexProperty(self: *const T, key: *const PROPERTYKEY, pfIndexProperty: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUrlAccessor4.VTable, self.vtable).ShouldIndexProperty(@ptrCast(*const IUrlAccessor4, self), key, pfIndexProperty);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IOpLockStatus_Value = @import("../zig.zig").Guid.initString("C731065D-AC80-11D1-8DF3-00C04FB6EF4F");
pub const IID_IOpLockStatus = &IID_IOpLockStatus_Value;
pub const IOpLockStatus = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsOplockValid: fn(
            self: *const IOpLockStatus,
            pfIsOplockValid: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsOplockBroken: fn(
            self: *const IOpLockStatus,
            pfIsOplockBroken: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOplockEventHandle: fn(
            self: *const IOpLockStatus,
            phOplockEv: *HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpLockStatus_IsOplockValid(self: *const T, pfIsOplockValid: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpLockStatus.VTable, self.vtable).IsOplockValid(@ptrCast(*const IOpLockStatus, self), pfIsOplockValid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpLockStatus_IsOplockBroken(self: *const T, pfIsOplockBroken: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpLockStatus.VTable, self.vtable).IsOplockBroken(@ptrCast(*const IOpLockStatus, self), pfIsOplockBroken);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOpLockStatus_GetOplockEventHandle(self: *const T, phOplockEv: *HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOpLockStatus.VTable, self.vtable).GetOplockEventHandle(@ptrCast(*const IOpLockStatus, self), phOplockEv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISearchProtocolThreadContext_Value = @import("../zig.zig").Guid.initString("C73106E1-AC80-11D1-8DF3-00C04FB6EF4F");
pub const IID_ISearchProtocolThreadContext = &IID_ISearchProtocolThreadContext_Value;
pub const ISearchProtocolThreadContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ThreadInit: fn(
            self: *const ISearchProtocolThreadContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ThreadShutdown: fn(
            self: *const ISearchProtocolThreadContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ThreadIdle: fn(
            self: *const ISearchProtocolThreadContext,
            dwTimeElaspedSinceLastCallInMS: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchProtocolThreadContext_ThreadInit(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchProtocolThreadContext.VTable, self.vtable).ThreadInit(@ptrCast(*const ISearchProtocolThreadContext, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchProtocolThreadContext_ThreadShutdown(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchProtocolThreadContext.VTable, self.vtable).ThreadShutdown(@ptrCast(*const ISearchProtocolThreadContext, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchProtocolThreadContext_ThreadIdle(self: *const T, dwTimeElaspedSinceLastCallInMS: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchProtocolThreadContext.VTable, self.vtable).ThreadIdle(@ptrCast(*const ISearchProtocolThreadContext, self), dwTimeElaspedSinceLastCallInMS);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const TIMEOUT_INFO = extern struct {
    dwSize: u32,
    dwConnectTimeout: u32,
    dwDataTimeout: u32,
};

pub const PROXY_ACCESS = extern enum(i32) {
    PRECONFIG = 0,
    DIRECT = 1,
    PROXY = 2,
};
pub const PROXY_ACCESS_PRECONFIG = PROXY_ACCESS.PRECONFIG;
pub const PROXY_ACCESS_DIRECT = PROXY_ACCESS.DIRECT;
pub const PROXY_ACCESS_PROXY = PROXY_ACCESS.PROXY;

pub const PROXY_INFO = extern struct {
    dwSize: u32,
    pcwszUserAgent: [*:0]const u16,
    paUseProxy: PROXY_ACCESS,
    fLocalBypass: BOOL,
    dwPortNumber: u32,
    pcwszProxyName: [*:0]const u16,
    pcwszBypassList: [*:0]const u16,
};

pub const AUTH_TYPE = extern enum(i32) {
    eAUTH_TYPE_ANONYMOUS = 0,
    eAUTH_TYPE_NTLM = 1,
    eAUTH_TYPE_BASIC = 2,
};
pub const eAUTH_TYPE_ANONYMOUS = AUTH_TYPE.eAUTH_TYPE_ANONYMOUS;
pub const eAUTH_TYPE_NTLM = AUTH_TYPE.eAUTH_TYPE_NTLM;
pub const eAUTH_TYPE_BASIC = AUTH_TYPE.eAUTH_TYPE_BASIC;

pub const AUTHENTICATION_INFO = extern struct {
    dwSize: u32,
    atAuthenticationType: AUTH_TYPE,
    pcwszUser: [*:0]const u16,
    pcwszPassword: [*:0]const u16,
};

pub const INCREMENTAL_ACCESS_INFO = extern struct {
    dwSize: u32,
    ftLastModifiedTime: FILETIME,
};

pub const ITEM_INFO = extern struct {
    dwSize: u32,
    pcwszFromEMail: [*:0]const u16,
    pcwszApplicationName: [*:0]const u16,
    pcwszCatalogName: [*:0]const u16,
    pcwszContentClass: [*:0]const u16,
};

const IID_ISearchProtocol_Value = @import("../zig.zig").Guid.initString("C73106BA-AC80-11D1-8DF3-00C04FB6EF4F");
pub const IID_ISearchProtocol = &IID_ISearchProtocol_Value;
pub const ISearchProtocol = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: fn(
            self: *const ISearchProtocol,
            pTimeoutInfo: *TIMEOUT_INFO,
            pProtocolHandlerSite: *IProtocolHandlerSite,
            pProxyInfo: *PROXY_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateAccessor: fn(
            self: *const ISearchProtocol,
            pcwszURL: [*:0]const u16,
            pAuthenticationInfo: *AUTHENTICATION_INFO,
            pIncrementalAccessInfo: *INCREMENTAL_ACCESS_INFO,
            pItemInfo: *ITEM_INFO,
            ppAccessor: **IUrlAccessor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseAccessor: fn(
            self: *const ISearchProtocol,
            pAccessor: *IUrlAccessor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShutDown: fn(
            self: *const ISearchProtocol,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchProtocol_Init(self: *const T, pTimeoutInfo: *TIMEOUT_INFO, pProtocolHandlerSite: *IProtocolHandlerSite, pProxyInfo: *PROXY_INFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchProtocol.VTable, self.vtable).Init(@ptrCast(*const ISearchProtocol, self), pTimeoutInfo, pProtocolHandlerSite, pProxyInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchProtocol_CreateAccessor(self: *const T, pcwszURL: [*:0]const u16, pAuthenticationInfo: *AUTHENTICATION_INFO, pIncrementalAccessInfo: *INCREMENTAL_ACCESS_INFO, pItemInfo: *ITEM_INFO, ppAccessor: **IUrlAccessor) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchProtocol.VTable, self.vtable).CreateAccessor(@ptrCast(*const ISearchProtocol, self), pcwszURL, pAuthenticationInfo, pIncrementalAccessInfo, pItemInfo, ppAccessor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchProtocol_CloseAccessor(self: *const T, pAccessor: *IUrlAccessor) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchProtocol.VTable, self.vtable).CloseAccessor(@ptrCast(*const ISearchProtocol, self), pAccessor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchProtocol_ShutDown(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchProtocol.VTable, self.vtable).ShutDown(@ptrCast(*const ISearchProtocol, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISearchProtocol2_Value = @import("../zig.zig").Guid.initString("7789F0B2-B5B2-4722-8B65-5DBD150697A9");
pub const IID_ISearchProtocol2 = &IID_ISearchProtocol2_Value;
pub const ISearchProtocol2 = extern struct {
    pub const VTable = extern struct {
        base: ISearchProtocol.VTable,
        CreateAccessorEx: fn(
            self: *const ISearchProtocol2,
            pcwszURL: [*:0]const u16,
            pAuthenticationInfo: *AUTHENTICATION_INFO,
            pIncrementalAccessInfo: *INCREMENTAL_ACCESS_INFO,
            pItemInfo: *ITEM_INFO,
            pUserData: *const BLOB,
            ppAccessor: **IUrlAccessor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISearchProtocol.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchProtocol2_CreateAccessorEx(self: *const T, pcwszURL: [*:0]const u16, pAuthenticationInfo: *AUTHENTICATION_INFO, pIncrementalAccessInfo: *INCREMENTAL_ACCESS_INFO, pItemInfo: *ITEM_INFO, pUserData: *const BLOB, ppAccessor: **IUrlAccessor) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchProtocol2.VTable, self.vtable).CreateAccessorEx(@ptrCast(*const ISearchProtocol2, self), pcwszURL, pAuthenticationInfo, pIncrementalAccessInfo, pItemInfo, pUserData, ppAccessor);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IProtocolHandlerSite_Value = @import("../zig.zig").Guid.initString("0B63E385-9CCC-11D0-BCDB-00805FCCCE04");
pub const IID_IProtocolHandlerSite = &IID_IProtocolHandlerSite_Value;
pub const IProtocolHandlerSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFilter: fn(
            self: *const IProtocolHandlerSite,
            pclsidObj: *Guid,
            pcwszContentType: [*:0]const u16,
            pcwszExtension: [*:0]const u16,
            ppFilter: **IFilter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProtocolHandlerSite_GetFilter(self: *const T, pclsidObj: *Guid, pcwszContentType: [*:0]const u16, pcwszExtension: [*:0]const u16, ppFilter: **IFilter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProtocolHandlerSite.VTable, self.vtable).GetFilter(@ptrCast(*const IProtocolHandlerSite, self), pclsidObj, pcwszContentType, pcwszExtension, ppFilter);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISearchRoot_Value = @import("../zig.zig").Guid.initString("04C18CCF-1F57-4CBD-88CC-3900F5195CE3");
pub const IID_ISearchRoot = &IID_ISearchRoot_Value;
pub const ISearchRoot = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        put_Schedule: fn(
            self: *const ISearchRoot,
            pszTaskArg: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Schedule: fn(
            self: *const ISearchRoot,
            ppszTaskArg: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_RootURL: fn(
            self: *const ISearchRoot,
            pszURL: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_RootURL: fn(
            self: *const ISearchRoot,
            ppszURL: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_IsHierarchical: fn(
            self: *const ISearchRoot,
            fIsHierarchical: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_IsHierarchical: fn(
            self: *const ISearchRoot,
            pfIsHierarchical: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ProvidesNotifications: fn(
            self: *const ISearchRoot,
            fProvidesNotifications: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ProvidesNotifications: fn(
            self: *const ISearchRoot,
            pfProvidesNotifications: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_UseNotificationsOnly: fn(
            self: *const ISearchRoot,
            fUseNotificationsOnly: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_UseNotificationsOnly: fn(
            self: *const ISearchRoot,
            pfUseNotificationsOnly: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_EnumerationDepth: fn(
            self: *const ISearchRoot,
            dwDepth: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_EnumerationDepth: fn(
            self: *const ISearchRoot,
            pdwDepth: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_HostDepth: fn(
            self: *const ISearchRoot,
            dwDepth: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HostDepth: fn(
            self: *const ISearchRoot,
            pdwDepth: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_FollowDirectories: fn(
            self: *const ISearchRoot,
            fFollowDirectories: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_FollowDirectories: fn(
            self: *const ISearchRoot,
            pfFollowDirectories: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_AuthenticationType: fn(
            self: *const ISearchRoot,
            authType: AUTH_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_AuthenticationType: fn(
            self: *const ISearchRoot,
            pAuthType: *AUTH_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_User: fn(
            self: *const ISearchRoot,
            pszUser: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_User: fn(
            self: *const ISearchRoot,
            ppszUser: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_Password: fn(
            self: *const ISearchRoot,
            pszPassword: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Password: fn(
            self: *const ISearchRoot,
            ppszPassword: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchRoot_put_Schedule(self: *const T, pszTaskArg: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchRoot.VTable, self.vtable).put_Schedule(@ptrCast(*const ISearchRoot, self), pszTaskArg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchRoot_get_Schedule(self: *const T, ppszTaskArg: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchRoot.VTable, self.vtable).get_Schedule(@ptrCast(*const ISearchRoot, self), ppszTaskArg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchRoot_put_RootURL(self: *const T, pszURL: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchRoot.VTable, self.vtable).put_RootURL(@ptrCast(*const ISearchRoot, self), pszURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchRoot_get_RootURL(self: *const T, ppszURL: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchRoot.VTable, self.vtable).get_RootURL(@ptrCast(*const ISearchRoot, self), ppszURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchRoot_put_IsHierarchical(self: *const T, fIsHierarchical: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchRoot.VTable, self.vtable).put_IsHierarchical(@ptrCast(*const ISearchRoot, self), fIsHierarchical);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchRoot_get_IsHierarchical(self: *const T, pfIsHierarchical: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchRoot.VTable, self.vtable).get_IsHierarchical(@ptrCast(*const ISearchRoot, self), pfIsHierarchical);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchRoot_put_ProvidesNotifications(self: *const T, fProvidesNotifications: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchRoot.VTable, self.vtable).put_ProvidesNotifications(@ptrCast(*const ISearchRoot, self), fProvidesNotifications);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchRoot_get_ProvidesNotifications(self: *const T, pfProvidesNotifications: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchRoot.VTable, self.vtable).get_ProvidesNotifications(@ptrCast(*const ISearchRoot, self), pfProvidesNotifications);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchRoot_put_UseNotificationsOnly(self: *const T, fUseNotificationsOnly: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchRoot.VTable, self.vtable).put_UseNotificationsOnly(@ptrCast(*const ISearchRoot, self), fUseNotificationsOnly);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchRoot_get_UseNotificationsOnly(self: *const T, pfUseNotificationsOnly: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchRoot.VTable, self.vtable).get_UseNotificationsOnly(@ptrCast(*const ISearchRoot, self), pfUseNotificationsOnly);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchRoot_put_EnumerationDepth(self: *const T, dwDepth: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchRoot.VTable, self.vtable).put_EnumerationDepth(@ptrCast(*const ISearchRoot, self), dwDepth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchRoot_get_EnumerationDepth(self: *const T, pdwDepth: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchRoot.VTable, self.vtable).get_EnumerationDepth(@ptrCast(*const ISearchRoot, self), pdwDepth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchRoot_put_HostDepth(self: *const T, dwDepth: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchRoot.VTable, self.vtable).put_HostDepth(@ptrCast(*const ISearchRoot, self), dwDepth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchRoot_get_HostDepth(self: *const T, pdwDepth: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchRoot.VTable, self.vtable).get_HostDepth(@ptrCast(*const ISearchRoot, self), pdwDepth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchRoot_put_FollowDirectories(self: *const T, fFollowDirectories: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchRoot.VTable, self.vtable).put_FollowDirectories(@ptrCast(*const ISearchRoot, self), fFollowDirectories);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchRoot_get_FollowDirectories(self: *const T, pfFollowDirectories: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchRoot.VTable, self.vtable).get_FollowDirectories(@ptrCast(*const ISearchRoot, self), pfFollowDirectories);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchRoot_put_AuthenticationType(self: *const T, authType: AUTH_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchRoot.VTable, self.vtable).put_AuthenticationType(@ptrCast(*const ISearchRoot, self), authType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchRoot_get_AuthenticationType(self: *const T, pAuthType: *AUTH_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchRoot.VTable, self.vtable).get_AuthenticationType(@ptrCast(*const ISearchRoot, self), pAuthType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchRoot_put_User(self: *const T, pszUser: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchRoot.VTable, self.vtable).put_User(@ptrCast(*const ISearchRoot, self), pszUser);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchRoot_get_User(self: *const T, ppszUser: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchRoot.VTable, self.vtable).get_User(@ptrCast(*const ISearchRoot, self), ppszUser);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchRoot_put_Password(self: *const T, pszPassword: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchRoot.VTable, self.vtable).put_Password(@ptrCast(*const ISearchRoot, self), pszPassword);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchRoot_get_Password(self: *const T, ppszPassword: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchRoot.VTable, self.vtable).get_Password(@ptrCast(*const ISearchRoot, self), ppszPassword);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumSearchRoots_Value = @import("../zig.zig").Guid.initString("AB310581-AC80-11D1-8DF3-00C04FB6EF52");
pub const IID_IEnumSearchRoots = &IID_IEnumSearchRoots_Value;
pub const IEnumSearchRoots = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumSearchRoots,
            celt: u32,
            rgelt: [*]*ISearchRoot,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumSearchRoots,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumSearchRoots,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumSearchRoots,
            ppenum: **IEnumSearchRoots,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSearchRoots_Next(self: *const T, celt: u32, rgelt: [*]*ISearchRoot, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSearchRoots.VTable, self.vtable).Next(@ptrCast(*const IEnumSearchRoots, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSearchRoots_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSearchRoots.VTable, self.vtable).Skip(@ptrCast(*const IEnumSearchRoots, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSearchRoots_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSearchRoots.VTable, self.vtable).Reset(@ptrCast(*const IEnumSearchRoots, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSearchRoots_Clone(self: *const T, ppenum: **IEnumSearchRoots) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSearchRoots.VTable, self.vtable).Clone(@ptrCast(*const IEnumSearchRoots, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const FOLLOW_FLAGS = extern enum(i32) {
    FF_INDEXCOMPLEXURLS = 1,
    FF_SUPPRESSINDEXING = 2,
};
pub const FF_INDEXCOMPLEXURLS = FOLLOW_FLAGS.FF_INDEXCOMPLEXURLS;
pub const FF_SUPPRESSINDEXING = FOLLOW_FLAGS.FF_SUPPRESSINDEXING;

const IID_ISearchScopeRule_Value = @import("../zig.zig").Guid.initString("AB310581-AC80-11D1-8DF3-00C04FB6EF53");
pub const IID_ISearchScopeRule = &IID_ISearchScopeRule_Value;
pub const ISearchScopeRule = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        get_PatternOrURL: fn(
            self: *const ISearchScopeRule,
            ppszPatternOrURL: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_IsIncluded: fn(
            self: *const ISearchScopeRule,
            pfIsIncluded: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_IsDefault: fn(
            self: *const ISearchScopeRule,
            pfIsDefault: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_FollowFlags: fn(
            self: *const ISearchScopeRule,
            pFollowFlags: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchScopeRule_get_PatternOrURL(self: *const T, ppszPatternOrURL: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchScopeRule.VTable, self.vtable).get_PatternOrURL(@ptrCast(*const ISearchScopeRule, self), ppszPatternOrURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchScopeRule_get_IsIncluded(self: *const T, pfIsIncluded: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchScopeRule.VTable, self.vtable).get_IsIncluded(@ptrCast(*const ISearchScopeRule, self), pfIsIncluded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchScopeRule_get_IsDefault(self: *const T, pfIsDefault: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchScopeRule.VTable, self.vtable).get_IsDefault(@ptrCast(*const ISearchScopeRule, self), pfIsDefault);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchScopeRule_get_FollowFlags(self: *const T, pFollowFlags: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchScopeRule.VTable, self.vtable).get_FollowFlags(@ptrCast(*const ISearchScopeRule, self), pFollowFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumSearchScopeRules_Value = @import("../zig.zig").Guid.initString("AB310581-AC80-11D1-8DF3-00C04FB6EF54");
pub const IID_IEnumSearchScopeRules = &IID_IEnumSearchScopeRules_Value;
pub const IEnumSearchScopeRules = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumSearchScopeRules,
            celt: u32,
            pprgelt: [*]*ISearchScopeRule,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumSearchScopeRules,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumSearchScopeRules,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumSearchScopeRules,
            ppenum: **IEnumSearchScopeRules,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSearchScopeRules_Next(self: *const T, celt: u32, pprgelt: [*]*ISearchScopeRule, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSearchScopeRules.VTable, self.vtable).Next(@ptrCast(*const IEnumSearchScopeRules, self), celt, pprgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSearchScopeRules_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSearchScopeRules.VTable, self.vtable).Skip(@ptrCast(*const IEnumSearchScopeRules, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSearchScopeRules_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSearchScopeRules.VTable, self.vtable).Reset(@ptrCast(*const IEnumSearchScopeRules, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSearchScopeRules_Clone(self: *const T, ppenum: **IEnumSearchScopeRules) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSearchScopeRules.VTable, self.vtable).Clone(@ptrCast(*const IEnumSearchScopeRules, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CLUSION_REASON = extern enum(i32) {
    CLUSIONREASON_UNKNOWNSCOPE = 0,
    CLUSIONREASON_DEFAULT = 1,
    CLUSIONREASON_USER = 2,
    CLUSIONREASON_GROUPPOLICY = 3,
};
pub const CLUSIONREASON_UNKNOWNSCOPE = CLUSION_REASON.CLUSIONREASON_UNKNOWNSCOPE;
pub const CLUSIONREASON_DEFAULT = CLUSION_REASON.CLUSIONREASON_DEFAULT;
pub const CLUSIONREASON_USER = CLUSION_REASON.CLUSIONREASON_USER;
pub const CLUSIONREASON_GROUPPOLICY = CLUSION_REASON.CLUSIONREASON_GROUPPOLICY;

const IID_ISearchCrawlScopeManager_Value = @import("../zig.zig").Guid.initString("AB310581-AC80-11D1-8DF3-00C04FB6EF55");
pub const IID_ISearchCrawlScopeManager = &IID_ISearchCrawlScopeManager_Value;
pub const ISearchCrawlScopeManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddDefaultScopeRule: fn(
            self: *const ISearchCrawlScopeManager,
            pszURL: [*:0]const u16,
            fInclude: BOOL,
            fFollowFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddRoot: fn(
            self: *const ISearchCrawlScopeManager,
            pSearchRoot: ?*ISearchRoot,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveRoot: fn(
            self: *const ISearchCrawlScopeManager,
            pszURL: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerateRoots: fn(
            self: *const ISearchCrawlScopeManager,
            ppSearchRoots: **IEnumSearchRoots,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddHierarchicalScope: fn(
            self: *const ISearchCrawlScopeManager,
            pszURL: [*:0]const u16,
            fInclude: BOOL,
            fDefault: BOOL,
            fOverrideChildren: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddUserScopeRule: fn(
            self: *const ISearchCrawlScopeManager,
            pszURL: [*:0]const u16,
            fInclude: BOOL,
            fOverrideChildren: BOOL,
            fFollowFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveScopeRule: fn(
            self: *const ISearchCrawlScopeManager,
            pszRule: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerateScopeRules: fn(
            self: *const ISearchCrawlScopeManager,
            ppSearchScopeRules: **IEnumSearchScopeRules,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HasParentScopeRule: fn(
            self: *const ISearchCrawlScopeManager,
            pszURL: [*:0]const u16,
            pfHasParentRule: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HasChildScopeRule: fn(
            self: *const ISearchCrawlScopeManager,
            pszURL: [*:0]const u16,
            pfHasChildRule: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IncludedInCrawlScope: fn(
            self: *const ISearchCrawlScopeManager,
            pszURL: [*:0]const u16,
            pfIsIncluded: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IncludedInCrawlScopeEx: fn(
            self: *const ISearchCrawlScopeManager,
            pszURL: [*:0]const u16,
            pfIsIncluded: *BOOL,
            pReason: *CLUSION_REASON,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RevertToDefaultScopes: fn(
            self: *const ISearchCrawlScopeManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveAll: fn(
            self: *const ISearchCrawlScopeManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParentScopeVersionId: fn(
            self: *const ISearchCrawlScopeManager,
            pszURL: [*:0]const u16,
            plScopeId: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveDefaultScopeRule: fn(
            self: *const ISearchCrawlScopeManager,
            pszURL: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCrawlScopeManager_AddDefaultScopeRule(self: *const T, pszURL: [*:0]const u16, fInclude: BOOL, fFollowFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCrawlScopeManager.VTable, self.vtable).AddDefaultScopeRule(@ptrCast(*const ISearchCrawlScopeManager, self), pszURL, fInclude, fFollowFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCrawlScopeManager_AddRoot(self: *const T, pSearchRoot: ?*ISearchRoot) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCrawlScopeManager.VTable, self.vtable).AddRoot(@ptrCast(*const ISearchCrawlScopeManager, self), pSearchRoot);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCrawlScopeManager_RemoveRoot(self: *const T, pszURL: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCrawlScopeManager.VTable, self.vtable).RemoveRoot(@ptrCast(*const ISearchCrawlScopeManager, self), pszURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCrawlScopeManager_EnumerateRoots(self: *const T, ppSearchRoots: **IEnumSearchRoots) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCrawlScopeManager.VTable, self.vtable).EnumerateRoots(@ptrCast(*const ISearchCrawlScopeManager, self), ppSearchRoots);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCrawlScopeManager_AddHierarchicalScope(self: *const T, pszURL: [*:0]const u16, fInclude: BOOL, fDefault: BOOL, fOverrideChildren: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCrawlScopeManager.VTable, self.vtable).AddHierarchicalScope(@ptrCast(*const ISearchCrawlScopeManager, self), pszURL, fInclude, fDefault, fOverrideChildren);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCrawlScopeManager_AddUserScopeRule(self: *const T, pszURL: [*:0]const u16, fInclude: BOOL, fOverrideChildren: BOOL, fFollowFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCrawlScopeManager.VTable, self.vtable).AddUserScopeRule(@ptrCast(*const ISearchCrawlScopeManager, self), pszURL, fInclude, fOverrideChildren, fFollowFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCrawlScopeManager_RemoveScopeRule(self: *const T, pszRule: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCrawlScopeManager.VTable, self.vtable).RemoveScopeRule(@ptrCast(*const ISearchCrawlScopeManager, self), pszRule);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCrawlScopeManager_EnumerateScopeRules(self: *const T, ppSearchScopeRules: **IEnumSearchScopeRules) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCrawlScopeManager.VTable, self.vtable).EnumerateScopeRules(@ptrCast(*const ISearchCrawlScopeManager, self), ppSearchScopeRules);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCrawlScopeManager_HasParentScopeRule(self: *const T, pszURL: [*:0]const u16, pfHasParentRule: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCrawlScopeManager.VTable, self.vtable).HasParentScopeRule(@ptrCast(*const ISearchCrawlScopeManager, self), pszURL, pfHasParentRule);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCrawlScopeManager_HasChildScopeRule(self: *const T, pszURL: [*:0]const u16, pfHasChildRule: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCrawlScopeManager.VTable, self.vtable).HasChildScopeRule(@ptrCast(*const ISearchCrawlScopeManager, self), pszURL, pfHasChildRule);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCrawlScopeManager_IncludedInCrawlScope(self: *const T, pszURL: [*:0]const u16, pfIsIncluded: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCrawlScopeManager.VTable, self.vtable).IncludedInCrawlScope(@ptrCast(*const ISearchCrawlScopeManager, self), pszURL, pfIsIncluded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCrawlScopeManager_IncludedInCrawlScopeEx(self: *const T, pszURL: [*:0]const u16, pfIsIncluded: *BOOL, pReason: *CLUSION_REASON) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCrawlScopeManager.VTable, self.vtable).IncludedInCrawlScopeEx(@ptrCast(*const ISearchCrawlScopeManager, self), pszURL, pfIsIncluded, pReason);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCrawlScopeManager_RevertToDefaultScopes(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCrawlScopeManager.VTable, self.vtable).RevertToDefaultScopes(@ptrCast(*const ISearchCrawlScopeManager, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCrawlScopeManager_SaveAll(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCrawlScopeManager.VTable, self.vtable).SaveAll(@ptrCast(*const ISearchCrawlScopeManager, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCrawlScopeManager_GetParentScopeVersionId(self: *const T, pszURL: [*:0]const u16, plScopeId: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCrawlScopeManager.VTable, self.vtable).GetParentScopeVersionId(@ptrCast(*const ISearchCrawlScopeManager, self), pszURL, plScopeId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCrawlScopeManager_RemoveDefaultScopeRule(self: *const T, pszURL: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCrawlScopeManager.VTable, self.vtable).RemoveDefaultScopeRule(@ptrCast(*const ISearchCrawlScopeManager, self), pszURL);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISearchCrawlScopeManager2_Value = @import("../zig.zig").Guid.initString("6292F7AD-4E19-4717-A534-8FC22BCD5CCD");
pub const IID_ISearchCrawlScopeManager2 = &IID_ISearchCrawlScopeManager2_Value;
pub const ISearchCrawlScopeManager2 = extern struct {
    pub const VTable = extern struct {
        base: ISearchCrawlScopeManager.VTable,
        GetVersion: fn(
            self: *const ISearchCrawlScopeManager2,
            plVersion: **i32,
            phFileMapping: *HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISearchCrawlScopeManager.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCrawlScopeManager2_GetVersion(self: *const T, plVersion: **i32, phFileMapping: *HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCrawlScopeManager2.VTable, self.vtable).GetVersion(@ptrCast(*const ISearchCrawlScopeManager2, self), plVersion, phFileMapping);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SEARCH_KIND_OF_CHANGE = extern enum(i32) {
    SEARCH_CHANGE_ADD = 0,
    SEARCH_CHANGE_DELETE = 1,
    SEARCH_CHANGE_MODIFY = 2,
    SEARCH_CHANGE_MOVE_RENAME = 3,
    SEARCH_CHANGE_SEMANTICS_DIRECTORY = 262144,
    SEARCH_CHANGE_SEMANTICS_SHALLOW = 524288,
    SEARCH_CHANGE_SEMANTICS_UPDATE_SECURITY = 4194304,
};
pub const SEARCH_CHANGE_ADD = SEARCH_KIND_OF_CHANGE.SEARCH_CHANGE_ADD;
pub const SEARCH_CHANGE_DELETE = SEARCH_KIND_OF_CHANGE.SEARCH_CHANGE_DELETE;
pub const SEARCH_CHANGE_MODIFY = SEARCH_KIND_OF_CHANGE.SEARCH_CHANGE_MODIFY;
pub const SEARCH_CHANGE_MOVE_RENAME = SEARCH_KIND_OF_CHANGE.SEARCH_CHANGE_MOVE_RENAME;
pub const SEARCH_CHANGE_SEMANTICS_DIRECTORY = SEARCH_KIND_OF_CHANGE.SEARCH_CHANGE_SEMANTICS_DIRECTORY;
pub const SEARCH_CHANGE_SEMANTICS_SHALLOW = SEARCH_KIND_OF_CHANGE.SEARCH_CHANGE_SEMANTICS_SHALLOW;
pub const SEARCH_CHANGE_SEMANTICS_UPDATE_SECURITY = SEARCH_KIND_OF_CHANGE.SEARCH_CHANGE_SEMANTICS_UPDATE_SECURITY;

pub const SEARCH_NOTIFICATION_PRIORITY = extern enum(i32) {
    SEARCH_NORMAL_PRIORITY = 0,
    SEARCH_HIGH_PRIORITY = 1,
};
pub const SEARCH_NORMAL_PRIORITY = SEARCH_NOTIFICATION_PRIORITY.SEARCH_NORMAL_PRIORITY;
pub const SEARCH_HIGH_PRIORITY = SEARCH_NOTIFICATION_PRIORITY.SEARCH_HIGH_PRIORITY;

pub const SEARCH_ITEM_CHANGE = extern struct {
    Change: SEARCH_KIND_OF_CHANGE,
    Priority: SEARCH_NOTIFICATION_PRIORITY,
    pUserData: *BLOB,
    lpwszURL: PWSTR,
    lpwszOldURL: PWSTR,
};

const IID_ISearchItemsChangedSink_Value = @import("../zig.zig").Guid.initString("AB310581-AC80-11D1-8DF3-00C04FB6EF58");
pub const IID_ISearchItemsChangedSink = &IID_ISearchItemsChangedSink_Value;
pub const ISearchItemsChangedSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartedMonitoringScope: fn(
            self: *const ISearchItemsChangedSink,
            pszURL: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StoppedMonitoringScope: fn(
            self: *const ISearchItemsChangedSink,
            pszURL: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnItemsChanged: fn(
            self: *const ISearchItemsChangedSink,
            dwNumberOfChanges: u32,
            rgDataChangeEntries: [*]SEARCH_ITEM_CHANGE,
            rgdwDocIds: [*]u32,
            rghrCompletionCodes: [*]*HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchItemsChangedSink_StartedMonitoringScope(self: *const T, pszURL: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchItemsChangedSink.VTable, self.vtable).StartedMonitoringScope(@ptrCast(*const ISearchItemsChangedSink, self), pszURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchItemsChangedSink_StoppedMonitoringScope(self: *const T, pszURL: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchItemsChangedSink.VTable, self.vtable).StoppedMonitoringScope(@ptrCast(*const ISearchItemsChangedSink, self), pszURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchItemsChangedSink_OnItemsChanged(self: *const T, dwNumberOfChanges: u32, rgDataChangeEntries: [*]SEARCH_ITEM_CHANGE, rgdwDocIds: [*]u32, rghrCompletionCodes: [*]*HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchItemsChangedSink.VTable, self.vtable).OnItemsChanged(@ptrCast(*const ISearchItemsChangedSink, self), dwNumberOfChanges, rgDataChangeEntries, rgdwDocIds, rghrCompletionCodes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SEARCH_ITEM_PERSISTENT_CHANGE = extern struct {
    Change: SEARCH_KIND_OF_CHANGE,
    URL: PWSTR,
    OldURL: PWSTR,
    Priority: SEARCH_NOTIFICATION_PRIORITY,
};

const IID_ISearchPersistentItemsChangedSink_Value = @import("../zig.zig").Guid.initString("A2FFDF9B-4758-4F84-B729-DF81A1A0612F");
pub const IID_ISearchPersistentItemsChangedSink = &IID_ISearchPersistentItemsChangedSink_Value;
pub const ISearchPersistentItemsChangedSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartedMonitoringScope: fn(
            self: *const ISearchPersistentItemsChangedSink,
            pszURL: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StoppedMonitoringScope: fn(
            self: *const ISearchPersistentItemsChangedSink,
            pszURL: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnItemsChanged: fn(
            self: *const ISearchPersistentItemsChangedSink,
            dwNumberOfChanges: u32,
            DataChangeEntries: [*]SEARCH_ITEM_PERSISTENT_CHANGE,
            hrCompletionCodes: [*]*HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchPersistentItemsChangedSink_StartedMonitoringScope(self: *const T, pszURL: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchPersistentItemsChangedSink.VTable, self.vtable).StartedMonitoringScope(@ptrCast(*const ISearchPersistentItemsChangedSink, self), pszURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchPersistentItemsChangedSink_StoppedMonitoringScope(self: *const T, pszURL: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchPersistentItemsChangedSink.VTable, self.vtable).StoppedMonitoringScope(@ptrCast(*const ISearchPersistentItemsChangedSink, self), pszURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchPersistentItemsChangedSink_OnItemsChanged(self: *const T, dwNumberOfChanges: u32, DataChangeEntries: [*]SEARCH_ITEM_PERSISTENT_CHANGE, hrCompletionCodes: [*]*HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchPersistentItemsChangedSink.VTable, self.vtable).OnItemsChanged(@ptrCast(*const ISearchPersistentItemsChangedSink, self), dwNumberOfChanges, DataChangeEntries, hrCompletionCodes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISearchViewChangedSink_Value = @import("../zig.zig").Guid.initString("AB310581-AC80-11D1-8DF3-00C04FB6EF65");
pub const IID_ISearchViewChangedSink = &IID_ISearchViewChangedSink_Value;
pub const ISearchViewChangedSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnChange: fn(
            self: *const ISearchViewChangedSink,
            pdwDocID: *i32,
            pChange: *SEARCH_ITEM_CHANGE,
            pfInView: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchViewChangedSink_OnChange(self: *const T, pdwDocID: *i32, pChange: *SEARCH_ITEM_CHANGE, pfInView: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchViewChangedSink.VTable, self.vtable).OnChange(@ptrCast(*const ISearchViewChangedSink, self), pdwDocID, pChange, pfInView);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SEARCH_INDEXING_PHASE = extern enum(i32) {
    GATHERER = 0,
    QUERYABLE = 1,
    PERSISTED = 2,
};
pub const SEARCH_INDEXING_PHASE_GATHERER = SEARCH_INDEXING_PHASE.GATHERER;
pub const SEARCH_INDEXING_PHASE_QUERYABLE = SEARCH_INDEXING_PHASE.QUERYABLE;
pub const SEARCH_INDEXING_PHASE_PERSISTED = SEARCH_INDEXING_PHASE.PERSISTED;

pub const SEARCH_ITEM_INDEXING_STATUS = extern struct {
    dwDocID: u32,
    hrIndexingStatus: HRESULT,
};

const IID_ISearchNotifyInlineSite_Value = @import("../zig.zig").Guid.initString("B5702E61-E75C-4B64-82A1-6CB4F832FCCF");
pub const IID_ISearchNotifyInlineSite = &IID_ISearchNotifyInlineSite_Value;
pub const ISearchNotifyInlineSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnItemIndexedStatusChange: fn(
            self: *const ISearchNotifyInlineSite,
            sipStatus: SEARCH_INDEXING_PHASE,
            dwNumEntries: u32,
            rgItemStatusEntries: [*]SEARCH_ITEM_INDEXING_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnCatalogStatusChange: fn(
            self: *const ISearchNotifyInlineSite,
            guidCatalogResetSignature: *const Guid,
            guidCheckPointSignature: *const Guid,
            dwLastCheckPointNumber: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchNotifyInlineSite_OnItemIndexedStatusChange(self: *const T, sipStatus: SEARCH_INDEXING_PHASE, dwNumEntries: u32, rgItemStatusEntries: [*]SEARCH_ITEM_INDEXING_STATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchNotifyInlineSite.VTable, self.vtable).OnItemIndexedStatusChange(@ptrCast(*const ISearchNotifyInlineSite, self), sipStatus, dwNumEntries, rgItemStatusEntries);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchNotifyInlineSite_OnCatalogStatusChange(self: *const T, guidCatalogResetSignature: *const Guid, guidCheckPointSignature: *const Guid, dwLastCheckPointNumber: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchNotifyInlineSite.VTable, self.vtable).OnCatalogStatusChange(@ptrCast(*const ISearchNotifyInlineSite, self), guidCatalogResetSignature, guidCheckPointSignature, dwLastCheckPointNumber);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CatalogStatus = extern enum(i32) {
    CATALOG_STATUS_IDLE = 0,
    CATALOG_STATUS_PAUSED = 1,
    CATALOG_STATUS_RECOVERING = 2,
    CATALOG_STATUS_FULL_CRAWL = 3,
    CATALOG_STATUS_INCREMENTAL_CRAWL = 4,
    CATALOG_STATUS_PROCESSING_NOTIFICATIONS = 5,
    CATALOG_STATUS_SHUTTING_DOWN = 6,
};
pub const CATALOG_STATUS_IDLE = CatalogStatus.CATALOG_STATUS_IDLE;
pub const CATALOG_STATUS_PAUSED = CatalogStatus.CATALOG_STATUS_PAUSED;
pub const CATALOG_STATUS_RECOVERING = CatalogStatus.CATALOG_STATUS_RECOVERING;
pub const CATALOG_STATUS_FULL_CRAWL = CatalogStatus.CATALOG_STATUS_FULL_CRAWL;
pub const CATALOG_STATUS_INCREMENTAL_CRAWL = CatalogStatus.CATALOG_STATUS_INCREMENTAL_CRAWL;
pub const CATALOG_STATUS_PROCESSING_NOTIFICATIONS = CatalogStatus.CATALOG_STATUS_PROCESSING_NOTIFICATIONS;
pub const CATALOG_STATUS_SHUTTING_DOWN = CatalogStatus.CATALOG_STATUS_SHUTTING_DOWN;

pub const CatalogPausedReason = extern enum(i32) {
    CATALOG_PAUSED_REASON_NONE = 0,
    CATALOG_PAUSED_REASON_HIGH_IO = 1,
    CATALOG_PAUSED_REASON_HIGH_CPU = 2,
    CATALOG_PAUSED_REASON_HIGH_NTF_RATE = 3,
    CATALOG_PAUSED_REASON_LOW_BATTERY = 4,
    CATALOG_PAUSED_REASON_LOW_MEMORY = 5,
    CATALOG_PAUSED_REASON_LOW_DISK = 6,
    CATALOG_PAUSED_REASON_DELAYED_RECOVERY = 7,
    CATALOG_PAUSED_REASON_USER_ACTIVE = 8,
    CATALOG_PAUSED_REASON_EXTERNAL = 9,
    CATALOG_PAUSED_REASON_UPGRADING = 10,
};
pub const CATALOG_PAUSED_REASON_NONE = CatalogPausedReason.CATALOG_PAUSED_REASON_NONE;
pub const CATALOG_PAUSED_REASON_HIGH_IO = CatalogPausedReason.CATALOG_PAUSED_REASON_HIGH_IO;
pub const CATALOG_PAUSED_REASON_HIGH_CPU = CatalogPausedReason.CATALOG_PAUSED_REASON_HIGH_CPU;
pub const CATALOG_PAUSED_REASON_HIGH_NTF_RATE = CatalogPausedReason.CATALOG_PAUSED_REASON_HIGH_NTF_RATE;
pub const CATALOG_PAUSED_REASON_LOW_BATTERY = CatalogPausedReason.CATALOG_PAUSED_REASON_LOW_BATTERY;
pub const CATALOG_PAUSED_REASON_LOW_MEMORY = CatalogPausedReason.CATALOG_PAUSED_REASON_LOW_MEMORY;
pub const CATALOG_PAUSED_REASON_LOW_DISK = CatalogPausedReason.CATALOG_PAUSED_REASON_LOW_DISK;
pub const CATALOG_PAUSED_REASON_DELAYED_RECOVERY = CatalogPausedReason.CATALOG_PAUSED_REASON_DELAYED_RECOVERY;
pub const CATALOG_PAUSED_REASON_USER_ACTIVE = CatalogPausedReason.CATALOG_PAUSED_REASON_USER_ACTIVE;
pub const CATALOG_PAUSED_REASON_EXTERNAL = CatalogPausedReason.CATALOG_PAUSED_REASON_EXTERNAL;
pub const CATALOG_PAUSED_REASON_UPGRADING = CatalogPausedReason.CATALOG_PAUSED_REASON_UPGRADING;

const IID_ISearchCatalogManager_Value = @import("../zig.zig").Guid.initString("AB310581-AC80-11D1-8DF3-00C04FB6EF50");
pub const IID_ISearchCatalogManager = &IID_ISearchCatalogManager_Value;
pub const ISearchCatalogManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        get_Name: fn(
            self: *const ISearchCatalogManager,
            pszName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParameter: fn(
            self: *const ISearchCatalogManager,
            pszName: [*:0]const u16,
            ppValue: **PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetParameter: fn(
            self: *const ISearchCatalogManager,
            pszName: [*:0]const u16,
            pValue: *PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCatalogStatus: fn(
            self: *const ISearchCatalogManager,
            pStatus: *CatalogStatus,
            pPausedReason: *CatalogPausedReason,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const ISearchCatalogManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reindex: fn(
            self: *const ISearchCatalogManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReindexMatchingURLs: fn(
            self: *const ISearchCatalogManager,
            pszPattern: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReindexSearchRoot: fn(
            self: *const ISearchCatalogManager,
            pszRootURL: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ConnectTimeout: fn(
            self: *const ISearchCatalogManager,
            dwConnectTimeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ConnectTimeout: fn(
            self: *const ISearchCatalogManager,
            pdwConnectTimeout: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_DataTimeout: fn(
            self: *const ISearchCatalogManager,
            dwDataTimeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_DataTimeout: fn(
            self: *const ISearchCatalogManager,
            pdwDataTimeout: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NumberOfItems: fn(
            self: *const ISearchCatalogManager,
            plCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NumberOfItemsToIndex: fn(
            self: *const ISearchCatalogManager,
            plIncrementalCount: *i32,
            plNotificationQueue: *i32,
            plHighPriorityQueue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        URLBeingIndexed: fn(
            self: *const ISearchCatalogManager,
            pszUrl: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetURLIndexingState: fn(
            self: *const ISearchCatalogManager,
            pszURL: [*:0]const u16,
            pdwState: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPersistentItemsChangedSink: fn(
            self: *const ISearchCatalogManager,
            ppISearchPersistentItemsChangedSink: **ISearchPersistentItemsChangedSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterViewForNotification: fn(
            self: *const ISearchCatalogManager,
            pszView: [*:0]const u16,
            pViewChangedSink: ?*ISearchViewChangedSink,
            pdwCookie: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItemsChangedSink: fn(
            self: *const ISearchCatalogManager,
            pISearchNotifyInlineSite: ?*ISearchNotifyInlineSite,
            riid: *const Guid,
            ppv: **c_void,
            pGUIDCatalogResetSignature: *Guid,
            pGUIDCheckPointSignature: *Guid,
            pdwLastCheckPointNumber: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterViewForNotification: fn(
            self: *const ISearchCatalogManager,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExtensionClusion: fn(
            self: *const ISearchCatalogManager,
            pszExtension: [*:0]const u16,
            fExclude: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerateExcludedExtensions: fn(
            self: *const ISearchCatalogManager,
            ppExtensions: **IEnumString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetQueryHelper: fn(
            self: *const ISearchCatalogManager,
            ppSearchQueryHelper: **ISearchQueryHelper,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_DiacriticSensitivity: fn(
            self: *const ISearchCatalogManager,
            fDiacriticSensitive: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_DiacriticSensitivity: fn(
            self: *const ISearchCatalogManager,
            pfDiacriticSensitive: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCrawlScopeManager: fn(
            self: *const ISearchCatalogManager,
            ppCrawlScopeManager: **ISearchCrawlScopeManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCatalogManager_get_Name(self: *const T, pszName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCatalogManager.VTable, self.vtable).get_Name(@ptrCast(*const ISearchCatalogManager, self), pszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCatalogManager_GetParameter(self: *const T, pszName: [*:0]const u16, ppValue: **PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCatalogManager.VTable, self.vtable).GetParameter(@ptrCast(*const ISearchCatalogManager, self), pszName, ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCatalogManager_SetParameter(self: *const T, pszName: [*:0]const u16, pValue: *PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCatalogManager.VTable, self.vtable).SetParameter(@ptrCast(*const ISearchCatalogManager, self), pszName, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCatalogManager_GetCatalogStatus(self: *const T, pStatus: *CatalogStatus, pPausedReason: *CatalogPausedReason) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCatalogManager.VTable, self.vtable).GetCatalogStatus(@ptrCast(*const ISearchCatalogManager, self), pStatus, pPausedReason);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCatalogManager_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCatalogManager.VTable, self.vtable).Reset(@ptrCast(*const ISearchCatalogManager, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCatalogManager_Reindex(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCatalogManager.VTable, self.vtable).Reindex(@ptrCast(*const ISearchCatalogManager, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCatalogManager_ReindexMatchingURLs(self: *const T, pszPattern: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCatalogManager.VTable, self.vtable).ReindexMatchingURLs(@ptrCast(*const ISearchCatalogManager, self), pszPattern);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCatalogManager_ReindexSearchRoot(self: *const T, pszRootURL: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCatalogManager.VTable, self.vtable).ReindexSearchRoot(@ptrCast(*const ISearchCatalogManager, self), pszRootURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCatalogManager_put_ConnectTimeout(self: *const T, dwConnectTimeout: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCatalogManager.VTable, self.vtable).put_ConnectTimeout(@ptrCast(*const ISearchCatalogManager, self), dwConnectTimeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCatalogManager_get_ConnectTimeout(self: *const T, pdwConnectTimeout: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCatalogManager.VTable, self.vtable).get_ConnectTimeout(@ptrCast(*const ISearchCatalogManager, self), pdwConnectTimeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCatalogManager_put_DataTimeout(self: *const T, dwDataTimeout: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCatalogManager.VTable, self.vtable).put_DataTimeout(@ptrCast(*const ISearchCatalogManager, self), dwDataTimeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCatalogManager_get_DataTimeout(self: *const T, pdwDataTimeout: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCatalogManager.VTable, self.vtable).get_DataTimeout(@ptrCast(*const ISearchCatalogManager, self), pdwDataTimeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCatalogManager_NumberOfItems(self: *const T, plCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCatalogManager.VTable, self.vtable).NumberOfItems(@ptrCast(*const ISearchCatalogManager, self), plCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCatalogManager_NumberOfItemsToIndex(self: *const T, plIncrementalCount: *i32, plNotificationQueue: *i32, plHighPriorityQueue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCatalogManager.VTable, self.vtable).NumberOfItemsToIndex(@ptrCast(*const ISearchCatalogManager, self), plIncrementalCount, plNotificationQueue, plHighPriorityQueue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCatalogManager_URLBeingIndexed(self: *const T, pszUrl: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCatalogManager.VTable, self.vtable).URLBeingIndexed(@ptrCast(*const ISearchCatalogManager, self), pszUrl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCatalogManager_GetURLIndexingState(self: *const T, pszURL: [*:0]const u16, pdwState: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCatalogManager.VTable, self.vtable).GetURLIndexingState(@ptrCast(*const ISearchCatalogManager, self), pszURL, pdwState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCatalogManager_GetPersistentItemsChangedSink(self: *const T, ppISearchPersistentItemsChangedSink: **ISearchPersistentItemsChangedSink) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCatalogManager.VTable, self.vtable).GetPersistentItemsChangedSink(@ptrCast(*const ISearchCatalogManager, self), ppISearchPersistentItemsChangedSink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCatalogManager_RegisterViewForNotification(self: *const T, pszView: [*:0]const u16, pViewChangedSink: ?*ISearchViewChangedSink, pdwCookie: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCatalogManager.VTable, self.vtable).RegisterViewForNotification(@ptrCast(*const ISearchCatalogManager, self), pszView, pViewChangedSink, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCatalogManager_GetItemsChangedSink(self: *const T, pISearchNotifyInlineSite: ?*ISearchNotifyInlineSite, riid: *const Guid, ppv: **c_void, pGUIDCatalogResetSignature: *Guid, pGUIDCheckPointSignature: *Guid, pdwLastCheckPointNumber: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCatalogManager.VTable, self.vtable).GetItemsChangedSink(@ptrCast(*const ISearchCatalogManager, self), pISearchNotifyInlineSite, riid, ppv, pGUIDCatalogResetSignature, pGUIDCheckPointSignature, pdwLastCheckPointNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCatalogManager_UnregisterViewForNotification(self: *const T, dwCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCatalogManager.VTable, self.vtable).UnregisterViewForNotification(@ptrCast(*const ISearchCatalogManager, self), dwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCatalogManager_SetExtensionClusion(self: *const T, pszExtension: [*:0]const u16, fExclude: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCatalogManager.VTable, self.vtable).SetExtensionClusion(@ptrCast(*const ISearchCatalogManager, self), pszExtension, fExclude);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCatalogManager_EnumerateExcludedExtensions(self: *const T, ppExtensions: **IEnumString) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCatalogManager.VTable, self.vtable).EnumerateExcludedExtensions(@ptrCast(*const ISearchCatalogManager, self), ppExtensions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCatalogManager_GetQueryHelper(self: *const T, ppSearchQueryHelper: **ISearchQueryHelper) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCatalogManager.VTable, self.vtable).GetQueryHelper(@ptrCast(*const ISearchCatalogManager, self), ppSearchQueryHelper);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCatalogManager_put_DiacriticSensitivity(self: *const T, fDiacriticSensitive: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCatalogManager.VTable, self.vtable).put_DiacriticSensitivity(@ptrCast(*const ISearchCatalogManager, self), fDiacriticSensitive);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCatalogManager_get_DiacriticSensitivity(self: *const T, pfDiacriticSensitive: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCatalogManager.VTable, self.vtable).get_DiacriticSensitivity(@ptrCast(*const ISearchCatalogManager, self), pfDiacriticSensitive);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCatalogManager_GetCrawlScopeManager(self: *const T, ppCrawlScopeManager: **ISearchCrawlScopeManager) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCatalogManager.VTable, self.vtable).GetCrawlScopeManager(@ptrCast(*const ISearchCatalogManager, self), ppCrawlScopeManager);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const tagPRIORITIZE_FLAGS = extern enum(i32) {
    PRIORITIZE_FLAG_RETRYFAILEDITEMS = 1,
    PRIORITIZE_FLAG_IGNOREFAILURECOUNT = 2,
};
pub const PRIORITIZE_FLAG_RETRYFAILEDITEMS = tagPRIORITIZE_FLAGS.PRIORITIZE_FLAG_RETRYFAILEDITEMS;
pub const PRIORITIZE_FLAG_IGNOREFAILURECOUNT = tagPRIORITIZE_FLAGS.PRIORITIZE_FLAG_IGNOREFAILURECOUNT;

const IID_ISearchCatalogManager2_Value = @import("../zig.zig").Guid.initString("7AC3286D-4D1D-4817-84FC-C1C85E3AF0D9");
pub const IID_ISearchCatalogManager2 = &IID_ISearchCatalogManager2_Value;
pub const ISearchCatalogManager2 = extern struct {
    pub const VTable = extern struct {
        base: ISearchCatalogManager.VTable,
        PrioritizeMatchingURLs: fn(
            self: *const ISearchCatalogManager2,
            pszPattern: [*:0]const u16,
            dwPrioritizeFlags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISearchCatalogManager.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchCatalogManager2_PrioritizeMatchingURLs(self: *const T, pszPattern: [*:0]const u16, dwPrioritizeFlags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchCatalogManager2.VTable, self.vtable).PrioritizeMatchingURLs(@ptrCast(*const ISearchCatalogManager2, self), pszPattern, dwPrioritizeFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SEARCH_TERM_EXPANSION = extern enum(i32) {
    SEARCH_TERM_NO_EXPANSION = 0,
    SEARCH_TERM_PREFIX_ALL = 1,
    SEARCH_TERM_STEM_ALL = 2,
};
pub const SEARCH_TERM_NO_EXPANSION = SEARCH_TERM_EXPANSION.SEARCH_TERM_NO_EXPANSION;
pub const SEARCH_TERM_PREFIX_ALL = SEARCH_TERM_EXPANSION.SEARCH_TERM_PREFIX_ALL;
pub const SEARCH_TERM_STEM_ALL = SEARCH_TERM_EXPANSION.SEARCH_TERM_STEM_ALL;

pub const SEARCH_QUERY_SYNTAX = extern enum(i32) {
    SEARCH_NO_QUERY_SYNTAX = 0,
    SEARCH_ADVANCED_QUERY_SYNTAX = 1,
    SEARCH_NATURAL_QUERY_SYNTAX = 2,
};
pub const SEARCH_NO_QUERY_SYNTAX = SEARCH_QUERY_SYNTAX.SEARCH_NO_QUERY_SYNTAX;
pub const SEARCH_ADVANCED_QUERY_SYNTAX = SEARCH_QUERY_SYNTAX.SEARCH_ADVANCED_QUERY_SYNTAX;
pub const SEARCH_NATURAL_QUERY_SYNTAX = SEARCH_QUERY_SYNTAX.SEARCH_NATURAL_QUERY_SYNTAX;

pub const SEARCH_COLUMN_PROPERTIES = extern struct {
    Value: PROPVARIANT,
    lcid: u32,
};

const IID_ISearchQueryHelper_Value = @import("../zig.zig").Guid.initString("AB310581-AC80-11D1-8DF3-00C04FB6EF63");
pub const IID_ISearchQueryHelper = &IID_ISearchQueryHelper_Value;
pub const ISearchQueryHelper = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        get_ConnectionString: fn(
            self: *const ISearchQueryHelper,
            pszConnectionString: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_QueryContentLocale: fn(
            self: *const ISearchQueryHelper,
            lcid: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_QueryContentLocale: fn(
            self: *const ISearchQueryHelper,
            plcid: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_QueryKeywordLocale: fn(
            self: *const ISearchQueryHelper,
            lcid: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_QueryKeywordLocale: fn(
            self: *const ISearchQueryHelper,
            plcid: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_QueryTermExpansion: fn(
            self: *const ISearchQueryHelper,
            expandTerms: SEARCH_TERM_EXPANSION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_QueryTermExpansion: fn(
            self: *const ISearchQueryHelper,
            pExpandTerms: *SEARCH_TERM_EXPANSION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_QuerySyntax: fn(
            self: *const ISearchQueryHelper,
            querySyntax: SEARCH_QUERY_SYNTAX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_QuerySyntax: fn(
            self: *const ISearchQueryHelper,
            pQuerySyntax: *SEARCH_QUERY_SYNTAX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_QueryContentProperties: fn(
            self: *const ISearchQueryHelper,
            pszContentProperties: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_QueryContentProperties: fn(
            self: *const ISearchQueryHelper,
            ppszContentProperties: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_QuerySelectColumns: fn(
            self: *const ISearchQueryHelper,
            pszSelectColumns: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_QuerySelectColumns: fn(
            self: *const ISearchQueryHelper,
            ppszSelectColumns: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_QueryWhereRestrictions: fn(
            self: *const ISearchQueryHelper,
            pszRestrictions: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_QueryWhereRestrictions: fn(
            self: *const ISearchQueryHelper,
            ppszRestrictions: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_QuerySorting: fn(
            self: *const ISearchQueryHelper,
            pszSorting: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_QuerySorting: fn(
            self: *const ISearchQueryHelper,
            ppszSorting: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GenerateSQLFromUserQuery: fn(
            self: *const ISearchQueryHelper,
            pszQuery: [*:0]const u16,
            ppszSQL: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteProperties: fn(
            self: *const ISearchQueryHelper,
            itemID: i32,
            dwNumberOfColumns: u32,
            pColumns: [*]PROPERTYKEY,
            pValues: [*]SEARCH_COLUMN_PROPERTIES,
            pftGatherModifiedTime: ?*FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_QueryMaxResults: fn(
            self: *const ISearchQueryHelper,
            cMaxResults: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_QueryMaxResults: fn(
            self: *const ISearchQueryHelper,
            pcMaxResults: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchQueryHelper_get_ConnectionString(self: *const T, pszConnectionString: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchQueryHelper.VTable, self.vtable).get_ConnectionString(@ptrCast(*const ISearchQueryHelper, self), pszConnectionString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchQueryHelper_put_QueryContentLocale(self: *const T, lcid: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchQueryHelper.VTable, self.vtable).put_QueryContentLocale(@ptrCast(*const ISearchQueryHelper, self), lcid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchQueryHelper_get_QueryContentLocale(self: *const T, plcid: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchQueryHelper.VTable, self.vtable).get_QueryContentLocale(@ptrCast(*const ISearchQueryHelper, self), plcid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchQueryHelper_put_QueryKeywordLocale(self: *const T, lcid: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchQueryHelper.VTable, self.vtable).put_QueryKeywordLocale(@ptrCast(*const ISearchQueryHelper, self), lcid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchQueryHelper_get_QueryKeywordLocale(self: *const T, plcid: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchQueryHelper.VTable, self.vtable).get_QueryKeywordLocale(@ptrCast(*const ISearchQueryHelper, self), plcid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchQueryHelper_put_QueryTermExpansion(self: *const T, expandTerms: SEARCH_TERM_EXPANSION) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchQueryHelper.VTable, self.vtable).put_QueryTermExpansion(@ptrCast(*const ISearchQueryHelper, self), expandTerms);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchQueryHelper_get_QueryTermExpansion(self: *const T, pExpandTerms: *SEARCH_TERM_EXPANSION) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchQueryHelper.VTable, self.vtable).get_QueryTermExpansion(@ptrCast(*const ISearchQueryHelper, self), pExpandTerms);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchQueryHelper_put_QuerySyntax(self: *const T, querySyntax: SEARCH_QUERY_SYNTAX) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchQueryHelper.VTable, self.vtable).put_QuerySyntax(@ptrCast(*const ISearchQueryHelper, self), querySyntax);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchQueryHelper_get_QuerySyntax(self: *const T, pQuerySyntax: *SEARCH_QUERY_SYNTAX) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchQueryHelper.VTable, self.vtable).get_QuerySyntax(@ptrCast(*const ISearchQueryHelper, self), pQuerySyntax);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchQueryHelper_put_QueryContentProperties(self: *const T, pszContentProperties: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchQueryHelper.VTable, self.vtable).put_QueryContentProperties(@ptrCast(*const ISearchQueryHelper, self), pszContentProperties);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchQueryHelper_get_QueryContentProperties(self: *const T, ppszContentProperties: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchQueryHelper.VTable, self.vtable).get_QueryContentProperties(@ptrCast(*const ISearchQueryHelper, self), ppszContentProperties);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchQueryHelper_put_QuerySelectColumns(self: *const T, pszSelectColumns: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchQueryHelper.VTable, self.vtable).put_QuerySelectColumns(@ptrCast(*const ISearchQueryHelper, self), pszSelectColumns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchQueryHelper_get_QuerySelectColumns(self: *const T, ppszSelectColumns: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchQueryHelper.VTable, self.vtable).get_QuerySelectColumns(@ptrCast(*const ISearchQueryHelper, self), ppszSelectColumns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchQueryHelper_put_QueryWhereRestrictions(self: *const T, pszRestrictions: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchQueryHelper.VTable, self.vtable).put_QueryWhereRestrictions(@ptrCast(*const ISearchQueryHelper, self), pszRestrictions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchQueryHelper_get_QueryWhereRestrictions(self: *const T, ppszRestrictions: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchQueryHelper.VTable, self.vtable).get_QueryWhereRestrictions(@ptrCast(*const ISearchQueryHelper, self), ppszRestrictions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchQueryHelper_put_QuerySorting(self: *const T, pszSorting: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchQueryHelper.VTable, self.vtable).put_QuerySorting(@ptrCast(*const ISearchQueryHelper, self), pszSorting);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchQueryHelper_get_QuerySorting(self: *const T, ppszSorting: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchQueryHelper.VTable, self.vtable).get_QuerySorting(@ptrCast(*const ISearchQueryHelper, self), ppszSorting);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchQueryHelper_GenerateSQLFromUserQuery(self: *const T, pszQuery: [*:0]const u16, ppszSQL: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchQueryHelper.VTable, self.vtable).GenerateSQLFromUserQuery(@ptrCast(*const ISearchQueryHelper, self), pszQuery, ppszSQL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchQueryHelper_WriteProperties(self: *const T, itemID: i32, dwNumberOfColumns: u32, pColumns: [*]PROPERTYKEY, pValues: [*]SEARCH_COLUMN_PROPERTIES, pftGatherModifiedTime: ?*FILETIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchQueryHelper.VTable, self.vtable).WriteProperties(@ptrCast(*const ISearchQueryHelper, self), itemID, dwNumberOfColumns, pColumns, pValues, pftGatherModifiedTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchQueryHelper_put_QueryMaxResults(self: *const T, cMaxResults: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchQueryHelper.VTable, self.vtable).put_QueryMaxResults(@ptrCast(*const ISearchQueryHelper, self), cMaxResults);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchQueryHelper_get_QueryMaxResults(self: *const T, pcMaxResults: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchQueryHelper.VTable, self.vtable).get_QueryMaxResults(@ptrCast(*const ISearchQueryHelper, self), pcMaxResults);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PRIORITY_LEVEL = extern enum(i32) {
    FOREGROUND = 0,
    HIGH = 1,
    LOW = 2,
    DEFAULT = 3,
};
pub const PRIORITY_LEVEL_FOREGROUND = PRIORITY_LEVEL.FOREGROUND;
pub const PRIORITY_LEVEL_HIGH = PRIORITY_LEVEL.HIGH;
pub const PRIORITY_LEVEL_LOW = PRIORITY_LEVEL.LOW;
pub const PRIORITY_LEVEL_DEFAULT = PRIORITY_LEVEL.DEFAULT;

const IID_IRowsetPrioritization_Value = @import("../zig.zig").Guid.initString("42811652-079D-481B-87A2-09A69ECC5F44");
pub const IID_IRowsetPrioritization = &IID_IRowsetPrioritization_Value;
pub const IRowsetPrioritization = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetScopePriority: fn(
            self: *const IRowsetPrioritization,
            priority: PRIORITY_LEVEL,
            scopeStatisticsEventFrequency: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScopePriority: fn(
            self: *const IRowsetPrioritization,
            priority: *PRIORITY_LEVEL,
            scopeStatisticsEventFrequency: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScopeStatistics: fn(
            self: *const IRowsetPrioritization,
            indexedDocumentCount: *u32,
            oustandingAddCount: *u32,
            oustandingModifyCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowsetPrioritization_SetScopePriority(self: *const T, priority: PRIORITY_LEVEL, scopeStatisticsEventFrequency: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowsetPrioritization.VTable, self.vtable).SetScopePriority(@ptrCast(*const IRowsetPrioritization, self), priority, scopeStatisticsEventFrequency);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowsetPrioritization_GetScopePriority(self: *const T, priority: *PRIORITY_LEVEL, scopeStatisticsEventFrequency: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowsetPrioritization.VTable, self.vtable).GetScopePriority(@ptrCast(*const IRowsetPrioritization, self), priority, scopeStatisticsEventFrequency);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowsetPrioritization_GetScopeStatistics(self: *const T, indexedDocumentCount: *u32, oustandingAddCount: *u32, oustandingModifyCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowsetPrioritization.VTable, self.vtable).GetScopeStatistics(@ptrCast(*const IRowsetPrioritization, self), indexedDocumentCount, oustandingAddCount, oustandingModifyCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ROWSETEVENT_ITEMSTATE = extern enum(i32) {
    NOTINROWSET = 0,
    INROWSET = 1,
    UNKNOWN = 2,
};
pub const ROWSETEVENT_ITEMSTATE_NOTINROWSET = ROWSETEVENT_ITEMSTATE.NOTINROWSET;
pub const ROWSETEVENT_ITEMSTATE_INROWSET = ROWSETEVENT_ITEMSTATE.INROWSET;
pub const ROWSETEVENT_ITEMSTATE_UNKNOWN = ROWSETEVENT_ITEMSTATE.UNKNOWN;

pub const ROWSETEVENT_TYPE = extern enum(i32) {
    DATAEXPIRED = 0,
    FOREGROUNDLOST = 1,
    SCOPESTATISTICS = 2,
};
pub const ROWSETEVENT_TYPE_DATAEXPIRED = ROWSETEVENT_TYPE.DATAEXPIRED;
pub const ROWSETEVENT_TYPE_FOREGROUNDLOST = ROWSETEVENT_TYPE.FOREGROUNDLOST;
pub const ROWSETEVENT_TYPE_SCOPESTATISTICS = ROWSETEVENT_TYPE.SCOPESTATISTICS;

const IID_IRowsetEvents_Value = @import("../zig.zig").Guid.initString("1551AEA5-5D66-4B11-86F5-D5634CB211B9");
pub const IID_IRowsetEvents = &IID_IRowsetEvents_Value;
pub const IRowsetEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnNewItem: fn(
            self: *const IRowsetEvents,
            itemID: *const PROPVARIANT,
            newItemState: ROWSETEVENT_ITEMSTATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnChangedItem: fn(
            self: *const IRowsetEvents,
            itemID: *const PROPVARIANT,
            rowsetItemState: ROWSETEVENT_ITEMSTATE,
            changedItemState: ROWSETEVENT_ITEMSTATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDeletedItem: fn(
            self: *const IRowsetEvents,
            itemID: *const PROPVARIANT,
            deletedItemState: ROWSETEVENT_ITEMSTATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnRowsetEvent: fn(
            self: *const IRowsetEvents,
            eventType: ROWSETEVENT_TYPE,
            eventData: *const PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowsetEvents_OnNewItem(self: *const T, itemID: *const PROPVARIANT, newItemState: ROWSETEVENT_ITEMSTATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowsetEvents.VTable, self.vtable).OnNewItem(@ptrCast(*const IRowsetEvents, self), itemID, newItemState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowsetEvents_OnChangedItem(self: *const T, itemID: *const PROPVARIANT, rowsetItemState: ROWSETEVENT_ITEMSTATE, changedItemState: ROWSETEVENT_ITEMSTATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowsetEvents.VTable, self.vtable).OnChangedItem(@ptrCast(*const IRowsetEvents, self), itemID, rowsetItemState, changedItemState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowsetEvents_OnDeletedItem(self: *const T, itemID: *const PROPVARIANT, deletedItemState: ROWSETEVENT_ITEMSTATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowsetEvents.VTable, self.vtable).OnDeletedItem(@ptrCast(*const IRowsetEvents, self), itemID, deletedItemState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRowsetEvents_OnRowsetEvent(self: *const T, eventType: ROWSETEVENT_TYPE, eventData: *const PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRowsetEvents.VTable, self.vtable).OnRowsetEvent(@ptrCast(*const IRowsetEvents, self), eventType, eventData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISearchManager_Value = @import("../zig.zig").Guid.initString("AB310581-AC80-11D1-8DF3-00C04FB6EF69");
pub const IID_ISearchManager = &IID_ISearchManager_Value;
pub const ISearchManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIndexerVersionStr: fn(
            self: *const ISearchManager,
            ppszVersionString: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIndexerVersion: fn(
            self: *const ISearchManager,
            pdwMajor: *u32,
            pdwMinor: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParameter: fn(
            self: *const ISearchManager,
            pszName: [*:0]const u16,
            ppValue: **PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetParameter: fn(
            self: *const ISearchManager,
            pszName: [*:0]const u16,
            pValue: *const PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ProxyName: fn(
            self: *const ISearchManager,
            ppszProxyName: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_BypassList: fn(
            self: *const ISearchManager,
            ppszBypassList: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProxy: fn(
            self: *const ISearchManager,
            sUseProxy: PROXY_ACCESS,
            fLocalByPassProxy: BOOL,
            dwPortNumber: u32,
            pszProxyName: [*:0]const u16,
            pszByPassList: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCatalog: fn(
            self: *const ISearchManager,
            pszCatalog: [*:0]const u16,
            ppCatalogManager: **ISearchCatalogManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_UserAgent: fn(
            self: *const ISearchManager,
            ppszUserAgent: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_UserAgent: fn(
            self: *const ISearchManager,
            pszUserAgent: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_UseProxy: fn(
            self: *const ISearchManager,
            pUseProxy: *PROXY_ACCESS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_LocalBypass: fn(
            self: *const ISearchManager,
            pfLocalBypass: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_PortNumber: fn(
            self: *const ISearchManager,
            pdwPortNumber: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchManager_GetIndexerVersionStr(self: *const T, ppszVersionString: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchManager.VTable, self.vtable).GetIndexerVersionStr(@ptrCast(*const ISearchManager, self), ppszVersionString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchManager_GetIndexerVersion(self: *const T, pdwMajor: *u32, pdwMinor: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchManager.VTable, self.vtable).GetIndexerVersion(@ptrCast(*const ISearchManager, self), pdwMajor, pdwMinor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchManager_GetParameter(self: *const T, pszName: [*:0]const u16, ppValue: **PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchManager.VTable, self.vtable).GetParameter(@ptrCast(*const ISearchManager, self), pszName, ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchManager_SetParameter(self: *const T, pszName: [*:0]const u16, pValue: *const PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchManager.VTable, self.vtable).SetParameter(@ptrCast(*const ISearchManager, self), pszName, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchManager_get_ProxyName(self: *const T, ppszProxyName: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchManager.VTable, self.vtable).get_ProxyName(@ptrCast(*const ISearchManager, self), ppszProxyName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchManager_get_BypassList(self: *const T, ppszBypassList: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchManager.VTable, self.vtable).get_BypassList(@ptrCast(*const ISearchManager, self), ppszBypassList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchManager_SetProxy(self: *const T, sUseProxy: PROXY_ACCESS, fLocalByPassProxy: BOOL, dwPortNumber: u32, pszProxyName: [*:0]const u16, pszByPassList: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchManager.VTable, self.vtable).SetProxy(@ptrCast(*const ISearchManager, self), sUseProxy, fLocalByPassProxy, dwPortNumber, pszProxyName, pszByPassList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchManager_GetCatalog(self: *const T, pszCatalog: [*:0]const u16, ppCatalogManager: **ISearchCatalogManager) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchManager.VTable, self.vtable).GetCatalog(@ptrCast(*const ISearchManager, self), pszCatalog, ppCatalogManager);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchManager_get_UserAgent(self: *const T, ppszUserAgent: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchManager.VTable, self.vtable).get_UserAgent(@ptrCast(*const ISearchManager, self), ppszUserAgent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchManager_put_UserAgent(self: *const T, pszUserAgent: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchManager.VTable, self.vtable).put_UserAgent(@ptrCast(*const ISearchManager, self), pszUserAgent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchManager_get_UseProxy(self: *const T, pUseProxy: *PROXY_ACCESS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchManager.VTable, self.vtable).get_UseProxy(@ptrCast(*const ISearchManager, self), pUseProxy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchManager_get_LocalBypass(self: *const T, pfLocalBypass: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchManager.VTable, self.vtable).get_LocalBypass(@ptrCast(*const ISearchManager, self), pfLocalBypass);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchManager_get_PortNumber(self: *const T, pdwPortNumber: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchManager.VTable, self.vtable).get_PortNumber(@ptrCast(*const ISearchManager, self), pdwPortNumber);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISearchManager2_Value = @import("../zig.zig").Guid.initString("DBAB3F73-DB19-4A79-BFC0-A61A93886DDF");
pub const IID_ISearchManager2 = &IID_ISearchManager2_Value;
pub const ISearchManager2 = extern struct {
    pub const VTable = extern struct {
        base: ISearchManager.VTable,
        CreateCatalog: fn(
            self: *const ISearchManager2,
            pszCatalog: [*:0]const u16,
            ppCatalogManager: **ISearchCatalogManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteCatalog: fn(
            self: *const ISearchManager2,
            pszCatalog: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISearchManager.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchManager2_CreateCatalog(self: *const T, pszCatalog: [*:0]const u16, ppCatalogManager: **ISearchCatalogManager) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchManager2.VTable, self.vtable).CreateCatalog(@ptrCast(*const ISearchManager2, self), pszCatalog, ppCatalogManager);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchManager2_DeleteCatalog(self: *const T, pszCatalog: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchManager2.VTable, self.vtable).DeleteCatalog(@ptrCast(*const ISearchManager2, self), pszCatalog);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_CSearchLanguageSupport_Value = @import("../zig.zig").Guid.initString("6A68CC80-4337-4DBC-BD27-FBFB1053820B");
pub const CLSID_CSearchLanguageSupport = &CLSID_CSearchLanguageSupport_Value;

const IID_ISearchLanguageSupport_Value = @import("../zig.zig").Guid.initString("24C3CBAA-EBC1-491A-9EF1-9F6D8DEB1B8F");
pub const IID_ISearchLanguageSupport = &IID_ISearchLanguageSupport_Value;
pub const ISearchLanguageSupport = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDiacriticSensitivity: fn(
            self: *const ISearchLanguageSupport,
            fDiacriticSensitive: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDiacriticSensitivity: fn(
            self: *const ISearchLanguageSupport,
            pfDiacriticSensitive: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadWordBreaker: fn(
            self: *const ISearchLanguageSupport,
            lcid: u32,
            riid: *const Guid,
            ppWordBreaker: **c_void,
            pLcidUsed: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadStemmer: fn(
            self: *const ISearchLanguageSupport,
            lcid: u32,
            riid: *const Guid,
            ppStemmer: **c_void,
            pLcidUsed: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsPrefixNormalized: fn(
            self: *const ISearchLanguageSupport,
            pwcsQueryToken: [*:0]const u16,
            cwcQueryToken: u32,
            pwcsDocumentToken: [*:0]const u16,
            cwcDocumentToken: u32,
            pulPrefixLength: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchLanguageSupport_SetDiacriticSensitivity(self: *const T, fDiacriticSensitive: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchLanguageSupport.VTable, self.vtable).SetDiacriticSensitivity(@ptrCast(*const ISearchLanguageSupport, self), fDiacriticSensitive);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchLanguageSupport_GetDiacriticSensitivity(self: *const T, pfDiacriticSensitive: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchLanguageSupport.VTable, self.vtable).GetDiacriticSensitivity(@ptrCast(*const ISearchLanguageSupport, self), pfDiacriticSensitive);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchLanguageSupport_LoadWordBreaker(self: *const T, lcid: u32, riid: *const Guid, ppWordBreaker: **c_void, pLcidUsed: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchLanguageSupport.VTable, self.vtable).LoadWordBreaker(@ptrCast(*const ISearchLanguageSupport, self), lcid, riid, ppWordBreaker, pLcidUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchLanguageSupport_LoadStemmer(self: *const T, lcid: u32, riid: *const Guid, ppStemmer: **c_void, pLcidUsed: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchLanguageSupport.VTable, self.vtable).LoadStemmer(@ptrCast(*const ISearchLanguageSupport, self), lcid, riid, ppStemmer, pLcidUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISearchLanguageSupport_IsPrefixNormalized(self: *const T, pwcsQueryToken: [*:0]const u16, cwcQueryToken: u32, pwcsDocumentToken: [*:0]const u16, cwcDocumentToken: u32, pulPrefixLength: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISearchLanguageSupport.VTable, self.vtable).IsPrefixNormalized(@ptrCast(*const ISearchLanguageSupport, self), pwcsQueryToken, cwcQueryToken, pwcsDocumentToken, cwcDocumentToken, pulPrefixLength);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_SubscriptionMgr_Value = @import("../zig.zig").Guid.initString("ABBE31D0-6DAE-11D0-BECA-00C04FD940BE");
pub const CLSID_SubscriptionMgr = &CLSID_SubscriptionMgr_Value;

pub const ITEMPROP = extern struct {
    variantValue: VARIANT,
    pwszName: PWSTR,
};

const IID_IEnumItemProperties_Value = @import("../zig.zig").Guid.initString("F72C8D96-6DBD-11D1-A1E8-00C04FC2FBE1");
pub const IID_IEnumItemProperties = &IID_IEnumItemProperties_Value;
pub const IEnumItemProperties = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumItemProperties,
            celt: u32,
            rgelt: [*]ITEMPROP,
            pceltFetched: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumItemProperties,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumItemProperties,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumItemProperties,
            ppenum: **IEnumItemProperties,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCount: fn(
            self: *const IEnumItemProperties,
            pnCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumItemProperties_Next(self: *const T, celt: u32, rgelt: [*]ITEMPROP, pceltFetched: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumItemProperties.VTable, self.vtable).Next(@ptrCast(*const IEnumItemProperties, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumItemProperties_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumItemProperties.VTable, self.vtable).Skip(@ptrCast(*const IEnumItemProperties, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumItemProperties_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumItemProperties.VTable, self.vtable).Reset(@ptrCast(*const IEnumItemProperties, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumItemProperties_Clone(self: *const T, ppenum: **IEnumItemProperties) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumItemProperties.VTable, self.vtable).Clone(@ptrCast(*const IEnumItemProperties, self), ppenum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumItemProperties_GetCount(self: *const T, pnCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumItemProperties.VTable, self.vtable).GetCount(@ptrCast(*const IEnumItemProperties, self), pnCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SUBSCRIPTIONITEMINFO = extern struct {
    cbSize: u32,
    dwFlags: u32,
    dwPriority: u32,
    ScheduleGroup: Guid,
    clsidAgent: Guid,
};

const IID_ISubscriptionItem_Value = @import("../zig.zig").Guid.initString("A97559F8-6C4A-11D1-A1E8-00C04FC2FBE1");
pub const IID_ISubscriptionItem = &IID_ISubscriptionItem_Value;
pub const ISubscriptionItem = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCookie: fn(
            self: *const ISubscriptionItem,
            pCookie: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubscriptionItemInfo: fn(
            self: *const ISubscriptionItem,
            pSubscriptionItemInfo: *SUBSCRIPTIONITEMINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSubscriptionItemInfo: fn(
            self: *const ISubscriptionItem,
            pSubscriptionItemInfo: *const SUBSCRIPTIONITEMINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadProperties: fn(
            self: *const ISubscriptionItem,
            nCount: u32,
            rgwszName: [*]const *const [*:0]const u16,
            rgValue: [*]VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteProperties: fn(
            self: *const ISubscriptionItem,
            nCount: u32,
            rgwszName: [*]const *const [*:0]const u16,
            rgValue: [*]const VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumProperties: fn(
            self: *const ISubscriptionItem,
            ppEnumItemProperties: **IEnumItemProperties,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyChanged: fn(
            self: *const ISubscriptionItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISubscriptionItem_GetCookie(self: *const T, pCookie: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISubscriptionItem.VTable, self.vtable).GetCookie(@ptrCast(*const ISubscriptionItem, self), pCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISubscriptionItem_GetSubscriptionItemInfo(self: *const T, pSubscriptionItemInfo: *SUBSCRIPTIONITEMINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISubscriptionItem.VTable, self.vtable).GetSubscriptionItemInfo(@ptrCast(*const ISubscriptionItem, self), pSubscriptionItemInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISubscriptionItem_SetSubscriptionItemInfo(self: *const T, pSubscriptionItemInfo: *const SUBSCRIPTIONITEMINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISubscriptionItem.VTable, self.vtable).SetSubscriptionItemInfo(@ptrCast(*const ISubscriptionItem, self), pSubscriptionItemInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISubscriptionItem_ReadProperties(self: *const T, nCount: u32, rgwszName: [*]const *const [*:0]const u16, rgValue: [*]VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISubscriptionItem.VTable, self.vtable).ReadProperties(@ptrCast(*const ISubscriptionItem, self), nCount, rgwszName, rgValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISubscriptionItem_WriteProperties(self: *const T, nCount: u32, rgwszName: [*]const *const [*:0]const u16, rgValue: [*]const VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISubscriptionItem.VTable, self.vtable).WriteProperties(@ptrCast(*const ISubscriptionItem, self), nCount, rgwszName, rgValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISubscriptionItem_EnumProperties(self: *const T, ppEnumItemProperties: **IEnumItemProperties) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISubscriptionItem.VTable, self.vtable).EnumProperties(@ptrCast(*const ISubscriptionItem, self), ppEnumItemProperties);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISubscriptionItem_NotifyChanged(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISubscriptionItem.VTable, self.vtable).NotifyChanged(@ptrCast(*const ISubscriptionItem, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumSubscription_Value = @import("../zig.zig").Guid.initString("F72C8D97-6DBD-11D1-A1E8-00C04FC2FBE1");
pub const IID_IEnumSubscription = &IID_IEnumSubscription_Value;
pub const IEnumSubscription = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumSubscription,
            celt: u32,
            rgelt: [*]Guid,
            pceltFetched: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumSubscription,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumSubscription,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumSubscription,
            ppenum: **IEnumSubscription,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCount: fn(
            self: *const IEnumSubscription,
            pnCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSubscription_Next(self: *const T, celt: u32, rgelt: [*]Guid, pceltFetched: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSubscription.VTable, self.vtable).Next(@ptrCast(*const IEnumSubscription, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSubscription_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSubscription.VTable, self.vtable).Skip(@ptrCast(*const IEnumSubscription, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSubscription_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSubscription.VTable, self.vtable).Reset(@ptrCast(*const IEnumSubscription, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSubscription_Clone(self: *const T, ppenum: **IEnumSubscription) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSubscription.VTable, self.vtable).Clone(@ptrCast(*const IEnumSubscription, self), ppenum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSubscription_GetCount(self: *const T, pnCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSubscription.VTable, self.vtable).GetCount(@ptrCast(*const IEnumSubscription, self), pnCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SUBSCRIPTIONTYPE = extern enum(i32) {
    SUBSTYPE_URL = 0,
    SUBSTYPE_CHANNEL = 1,
    SUBSTYPE_DESKTOPURL = 2,
    SUBSTYPE_EXTERNAL = 3,
    SUBSTYPE_DESKTOPCHANNEL = 4,
};
pub const SUBSTYPE_URL = SUBSCRIPTIONTYPE.SUBSTYPE_URL;
pub const SUBSTYPE_CHANNEL = SUBSCRIPTIONTYPE.SUBSTYPE_CHANNEL;
pub const SUBSTYPE_DESKTOPURL = SUBSCRIPTIONTYPE.SUBSTYPE_DESKTOPURL;
pub const SUBSTYPE_EXTERNAL = SUBSCRIPTIONTYPE.SUBSTYPE_EXTERNAL;
pub const SUBSTYPE_DESKTOPCHANNEL = SUBSCRIPTIONTYPE.SUBSTYPE_DESKTOPCHANNEL;

pub const SUBSCRIPTIONINFOFLAGS = extern enum(i32) {
    SUBSINFO_SCHEDULE = 1,
    SUBSINFO_RECURSE = 2,
    SUBSINFO_WEBCRAWL = 4,
    SUBSINFO_MAILNOT = 8,
    SUBSINFO_MAXSIZEKB = 16,
    SUBSINFO_USER = 32,
    SUBSINFO_PASSWORD = 64,
    SUBSINFO_TASKFLAGS = 256,
    SUBSINFO_GLEAM = 512,
    SUBSINFO_CHANGESONLY = 1024,
    SUBSINFO_CHANNELFLAGS = 2048,
    SUBSINFO_FRIENDLYNAME = 8192,
    SUBSINFO_NEEDPASSWORD = 16384,
    SUBSINFO_TYPE = 32768,
};
pub const SUBSINFO_SCHEDULE = SUBSCRIPTIONINFOFLAGS.SUBSINFO_SCHEDULE;
pub const SUBSINFO_RECURSE = SUBSCRIPTIONINFOFLAGS.SUBSINFO_RECURSE;
pub const SUBSINFO_WEBCRAWL = SUBSCRIPTIONINFOFLAGS.SUBSINFO_WEBCRAWL;
pub const SUBSINFO_MAILNOT = SUBSCRIPTIONINFOFLAGS.SUBSINFO_MAILNOT;
pub const SUBSINFO_MAXSIZEKB = SUBSCRIPTIONINFOFLAGS.SUBSINFO_MAXSIZEKB;
pub const SUBSINFO_USER = SUBSCRIPTIONINFOFLAGS.SUBSINFO_USER;
pub const SUBSINFO_PASSWORD = SUBSCRIPTIONINFOFLAGS.SUBSINFO_PASSWORD;
pub const SUBSINFO_TASKFLAGS = SUBSCRIPTIONINFOFLAGS.SUBSINFO_TASKFLAGS;
pub const SUBSINFO_GLEAM = SUBSCRIPTIONINFOFLAGS.SUBSINFO_GLEAM;
pub const SUBSINFO_CHANGESONLY = SUBSCRIPTIONINFOFLAGS.SUBSINFO_CHANGESONLY;
pub const SUBSINFO_CHANNELFLAGS = SUBSCRIPTIONINFOFLAGS.SUBSINFO_CHANNELFLAGS;
pub const SUBSINFO_FRIENDLYNAME = SUBSCRIPTIONINFOFLAGS.SUBSINFO_FRIENDLYNAME;
pub const SUBSINFO_NEEDPASSWORD = SUBSCRIPTIONINFOFLAGS.SUBSINFO_NEEDPASSWORD;
pub const SUBSINFO_TYPE = SUBSCRIPTIONINFOFLAGS.SUBSINFO_TYPE;

pub const CREATESUBSCRIPTIONFLAGS = extern enum(i32) {
    CREATESUBS_ADDTOFAVORITES = 1,
    CREATESUBS_FROMFAVORITES = 2,
    CREATESUBS_NOUI = 4,
    CREATESUBS_NOSAVE = 8,
    CREATESUBS_SOFTWAREUPDATE = 16,
};
pub const CREATESUBS_ADDTOFAVORITES = CREATESUBSCRIPTIONFLAGS.CREATESUBS_ADDTOFAVORITES;
pub const CREATESUBS_FROMFAVORITES = CREATESUBSCRIPTIONFLAGS.CREATESUBS_FROMFAVORITES;
pub const CREATESUBS_NOUI = CREATESUBSCRIPTIONFLAGS.CREATESUBS_NOUI;
pub const CREATESUBS_NOSAVE = CREATESUBSCRIPTIONFLAGS.CREATESUBS_NOSAVE;
pub const CREATESUBS_SOFTWAREUPDATE = CREATESUBSCRIPTIONFLAGS.CREATESUBS_SOFTWAREUPDATE;

pub const SUBSCRIPTIONSCHEDULE = extern enum(i32) {
    SUBSSCHED_AUTO = 0,
    SUBSSCHED_DAILY = 1,
    SUBSSCHED_WEEKLY = 2,
    SUBSSCHED_CUSTOM = 3,
    SUBSSCHED_MANUAL = 4,
};
pub const SUBSSCHED_AUTO = SUBSCRIPTIONSCHEDULE.SUBSSCHED_AUTO;
pub const SUBSSCHED_DAILY = SUBSCRIPTIONSCHEDULE.SUBSSCHED_DAILY;
pub const SUBSSCHED_WEEKLY = SUBSCRIPTIONSCHEDULE.SUBSSCHED_WEEKLY;
pub const SUBSSCHED_CUSTOM = SUBSCRIPTIONSCHEDULE.SUBSSCHED_CUSTOM;
pub const SUBSSCHED_MANUAL = SUBSCRIPTIONSCHEDULE.SUBSSCHED_MANUAL;

pub const _tagSubscriptionInfo = extern struct {
    cbSize: u32,
    fUpdateFlags: u32,
    schedule: SUBSCRIPTIONSCHEDULE,
    customGroupCookie: Guid,
    pTrigger: *c_void,
    dwRecurseLevels: u32,
    fWebcrawlerFlags: u32,
    bMailNotification: BOOL,
    bGleam: BOOL,
    bChangesOnly: BOOL,
    bNeedPassword: BOOL,
    fChannelFlags: u32,
    bstrUserName: BSTR,
    bstrPassword: BSTR,
    bstrFriendlyName: BSTR,
    dwMaxSizeKB: u32,
    subType: SUBSCRIPTIONTYPE,
    fTaskFlags: u32,
    dwReserved: u32,
};

const IID_ISubscriptionMgr_Value = @import("../zig.zig").Guid.initString("085FB2C0-0DF8-11D1-8F4B-00A0C905413F");
pub const IID_ISubscriptionMgr = &IID_ISubscriptionMgr_Value;
pub const ISubscriptionMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DeleteSubscription: fn(
            self: *const ISubscriptionMgr,
            pwszURL: [*:0]const u16,
            hwnd: HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateSubscription: fn(
            self: *const ISubscriptionMgr,
            pwszURL: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateAll: fn(
            self: *const ISubscriptionMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSubscribed: fn(
            self: *const ISubscriptionMgr,
            pwszURL: [*:0]const u16,
            pfSubscribed: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubscriptionInfo: fn(
            self: *const ISubscriptionMgr,
            pwszURL: [*:0]const u16,
            pInfo: *_tagSubscriptionInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultInfo: fn(
            self: *const ISubscriptionMgr,
            subType: SUBSCRIPTIONTYPE,
            pInfo: *_tagSubscriptionInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowSubscriptionProperties: fn(
            self: *const ISubscriptionMgr,
            pwszURL: [*:0]const u16,
            hwnd: HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSubscription: fn(
            self: *const ISubscriptionMgr,
            hwnd: HWND,
            pwszURL: [*:0]const u16,
            pwszFriendlyName: [*:0]const u16,
            dwFlags: u32,
            subsType: SUBSCRIPTIONTYPE,
            pInfo: *_tagSubscriptionInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISubscriptionMgr_DeleteSubscription(self: *const T, pwszURL: [*:0]const u16, hwnd: HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISubscriptionMgr.VTable, self.vtable).DeleteSubscription(@ptrCast(*const ISubscriptionMgr, self), pwszURL, hwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISubscriptionMgr_UpdateSubscription(self: *const T, pwszURL: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISubscriptionMgr.VTable, self.vtable).UpdateSubscription(@ptrCast(*const ISubscriptionMgr, self), pwszURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISubscriptionMgr_UpdateAll(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISubscriptionMgr.VTable, self.vtable).UpdateAll(@ptrCast(*const ISubscriptionMgr, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISubscriptionMgr_IsSubscribed(self: *const T, pwszURL: [*:0]const u16, pfSubscribed: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISubscriptionMgr.VTable, self.vtable).IsSubscribed(@ptrCast(*const ISubscriptionMgr, self), pwszURL, pfSubscribed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISubscriptionMgr_GetSubscriptionInfo(self: *const T, pwszURL: [*:0]const u16, pInfo: *_tagSubscriptionInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISubscriptionMgr.VTable, self.vtable).GetSubscriptionInfo(@ptrCast(*const ISubscriptionMgr, self), pwszURL, pInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISubscriptionMgr_GetDefaultInfo(self: *const T, subType: SUBSCRIPTIONTYPE, pInfo: *_tagSubscriptionInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISubscriptionMgr.VTable, self.vtable).GetDefaultInfo(@ptrCast(*const ISubscriptionMgr, self), subType, pInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISubscriptionMgr_ShowSubscriptionProperties(self: *const T, pwszURL: [*:0]const u16, hwnd: HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISubscriptionMgr.VTable, self.vtable).ShowSubscriptionProperties(@ptrCast(*const ISubscriptionMgr, self), pwszURL, hwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISubscriptionMgr_CreateSubscription(self: *const T, hwnd: HWND, pwszURL: [*:0]const u16, pwszFriendlyName: [*:0]const u16, dwFlags: u32, subsType: SUBSCRIPTIONTYPE, pInfo: *_tagSubscriptionInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISubscriptionMgr.VTable, self.vtable).CreateSubscription(@ptrCast(*const ISubscriptionMgr, self), hwnd, pwszURL, pwszFriendlyName, dwFlags, subsType, pInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISubscriptionMgr2_Value = @import("../zig.zig").Guid.initString("614BC270-AEDF-11D1-A1F9-00C04FC2FBE1");
pub const IID_ISubscriptionMgr2 = &IID_ISubscriptionMgr2_Value;
pub const ISubscriptionMgr2 = extern struct {
    pub const VTable = extern struct {
        base: ISubscriptionMgr.VTable,
        GetItemFromURL: fn(
            self: *const ISubscriptionMgr2,
            pwszURL: [*:0]const u16,
            ppSubscriptionItem: **ISubscriptionItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItemFromCookie: fn(
            self: *const ISubscriptionMgr2,
            pSubscriptionCookie: *const Guid,
            ppSubscriptionItem: **ISubscriptionItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubscriptionRunState: fn(
            self: *const ISubscriptionMgr2,
            dwNumCookies: u32,
            pCookies: [*]const Guid,
            pdwRunState: [*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumSubscriptions: fn(
            self: *const ISubscriptionMgr2,
            dwFlags: u32,
            ppEnumSubscriptions: **IEnumSubscription,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateItems: fn(
            self: *const ISubscriptionMgr2,
            dwFlags: u32,
            dwNumCookies: u32,
            pCookies: [*]const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AbortItems: fn(
            self: *const ISubscriptionMgr2,
            dwNumCookies: u32,
            pCookies: [*]const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AbortAll: fn(
            self: *const ISubscriptionMgr2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISubscriptionMgr.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISubscriptionMgr2_GetItemFromURL(self: *const T, pwszURL: [*:0]const u16, ppSubscriptionItem: **ISubscriptionItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISubscriptionMgr2.VTable, self.vtable).GetItemFromURL(@ptrCast(*const ISubscriptionMgr2, self), pwszURL, ppSubscriptionItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISubscriptionMgr2_GetItemFromCookie(self: *const T, pSubscriptionCookie: *const Guid, ppSubscriptionItem: **ISubscriptionItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISubscriptionMgr2.VTable, self.vtable).GetItemFromCookie(@ptrCast(*const ISubscriptionMgr2, self), pSubscriptionCookie, ppSubscriptionItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISubscriptionMgr2_GetSubscriptionRunState(self: *const T, dwNumCookies: u32, pCookies: [*]const Guid, pdwRunState: [*]u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISubscriptionMgr2.VTable, self.vtable).GetSubscriptionRunState(@ptrCast(*const ISubscriptionMgr2, self), dwNumCookies, pCookies, pdwRunState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISubscriptionMgr2_EnumSubscriptions(self: *const T, dwFlags: u32, ppEnumSubscriptions: **IEnumSubscription) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISubscriptionMgr2.VTable, self.vtable).EnumSubscriptions(@ptrCast(*const ISubscriptionMgr2, self), dwFlags, ppEnumSubscriptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISubscriptionMgr2_UpdateItems(self: *const T, dwFlags: u32, dwNumCookies: u32, pCookies: [*]const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISubscriptionMgr2.VTable, self.vtable).UpdateItems(@ptrCast(*const ISubscriptionMgr2, self), dwFlags, dwNumCookies, pCookies);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISubscriptionMgr2_AbortItems(self: *const T, dwNumCookies: u32, pCookies: [*]const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISubscriptionMgr2.VTable, self.vtable).AbortItems(@ptrCast(*const ISubscriptionMgr2, self), dwNumCookies, pCookies);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISubscriptionMgr2_AbortAll(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISubscriptionMgr2.VTable, self.vtable).AbortAll(@ptrCast(*const ISubscriptionMgr2, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DELIVERY_AGENT_FLAGS = extern enum(i32) {
    DELIVERY_AGENT_FLAG_NO_BROADCAST = 4,
    DELIVERY_AGENT_FLAG_NO_RESTRICTIONS = 8,
    DELIVERY_AGENT_FLAG_SILENT_DIAL = 16,
};
pub const DELIVERY_AGENT_FLAG_NO_BROADCAST = DELIVERY_AGENT_FLAGS.DELIVERY_AGENT_FLAG_NO_BROADCAST;
pub const DELIVERY_AGENT_FLAG_NO_RESTRICTIONS = DELIVERY_AGENT_FLAGS.DELIVERY_AGENT_FLAG_NO_RESTRICTIONS;
pub const DELIVERY_AGENT_FLAG_SILENT_DIAL = DELIVERY_AGENT_FLAGS.DELIVERY_AGENT_FLAG_SILENT_DIAL;

pub const WEBCRAWL_RECURSEFLAGS = extern enum(i32) {
    WEBCRAWL_DONT_MAKE_STICKY = 1,
    WEBCRAWL_GET_IMAGES = 2,
    WEBCRAWL_GET_VIDEOS = 4,
    WEBCRAWL_GET_BGSOUNDS = 8,
    WEBCRAWL_GET_CONTROLS = 16,
    WEBCRAWL_LINKS_ELSEWHERE = 32,
    WEBCRAWL_IGNORE_ROBOTSTXT = 128,
    WEBCRAWL_ONLY_LINKS_TO_HTML = 256,
};
pub const WEBCRAWL_DONT_MAKE_STICKY = WEBCRAWL_RECURSEFLAGS.WEBCRAWL_DONT_MAKE_STICKY;
pub const WEBCRAWL_GET_IMAGES = WEBCRAWL_RECURSEFLAGS.WEBCRAWL_GET_IMAGES;
pub const WEBCRAWL_GET_VIDEOS = WEBCRAWL_RECURSEFLAGS.WEBCRAWL_GET_VIDEOS;
pub const WEBCRAWL_GET_BGSOUNDS = WEBCRAWL_RECURSEFLAGS.WEBCRAWL_GET_BGSOUNDS;
pub const WEBCRAWL_GET_CONTROLS = WEBCRAWL_RECURSEFLAGS.WEBCRAWL_GET_CONTROLS;
pub const WEBCRAWL_LINKS_ELSEWHERE = WEBCRAWL_RECURSEFLAGS.WEBCRAWL_LINKS_ELSEWHERE;
pub const WEBCRAWL_IGNORE_ROBOTSTXT = WEBCRAWL_RECURSEFLAGS.WEBCRAWL_IGNORE_ROBOTSTXT;
pub const WEBCRAWL_ONLY_LINKS_TO_HTML = WEBCRAWL_RECURSEFLAGS.WEBCRAWL_ONLY_LINKS_TO_HTML;

pub const CHANNEL_AGENT_FLAGS = extern enum(i32) {
    CHANNEL_AGENT_DYNAMIC_SCHEDULE = 1,
    CHANNEL_AGENT_PRECACHE_SOME = 2,
    CHANNEL_AGENT_PRECACHE_ALL = 4,
    CHANNEL_AGENT_PRECACHE_SCRNSAVER = 8,
};
pub const CHANNEL_AGENT_DYNAMIC_SCHEDULE = CHANNEL_AGENT_FLAGS.CHANNEL_AGENT_DYNAMIC_SCHEDULE;
pub const CHANNEL_AGENT_PRECACHE_SOME = CHANNEL_AGENT_FLAGS.CHANNEL_AGENT_PRECACHE_SOME;
pub const CHANNEL_AGENT_PRECACHE_ALL = CHANNEL_AGENT_FLAGS.CHANNEL_AGENT_PRECACHE_ALL;
pub const CHANNEL_AGENT_PRECACHE_SCRNSAVER = CHANNEL_AGENT_FLAGS.CHANNEL_AGENT_PRECACHE_SCRNSAVER;


//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (35)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const IDispatch = @import("automation.zig").IDispatch;
const BLOB = @import("win_sock.zig").BLOB;
const FILETIME = @import("windows_programming.zig").FILETIME;
const IPersistStream = @import("com.zig").IPersistStream;
const IEnumString = @import("com.zig").IEnumString;
const HRESULT = @import("com.zig").HRESULT;
const IEnumUnknown = @import("com.zig").IEnumUnknown;
const BOOL = @import("system_services.zig").BOOL;
const DISPPARAMS = @import("automation.zig").DISPPARAMS;
const PROPSPEC = @import("structured_storage.zig").PROPSPEC;
const EXPLICIT_ACCESS_W = @import("security.zig").EXPLICIT_ACCESS_W;
const IErrorInfo = @import("automation.zig").IErrorInfo;
const DBID = @import("index_server.zig").DBID;
const TRUSTEE_W = @import("security.zig").TRUSTEE_W;
const PROPERTYKEY = @import("windows_properties_system.zig").PROPERTYKEY;
const ITypeInfo = @import("automation.zig").ITypeInfo;
const IStream = @import("structured_storage.zig").IStream;
const PWSTR = @import("system_services.zig").PWSTR;
const IAuthenticate = @import("com.zig").IAuthenticate;
const IObjectArray = @import("shell.zig").IObjectArray;
const IUnknown = @import("com.zig").IUnknown;
const IFilter = @import("index_server.zig").IFilter;
const PROPVARIANT = @import("structured_storage.zig").PROPVARIANT;
const IPhraseSink = @import("index_server.zig").IPhraseSink;
const IStorage = @import("structured_storage.zig").IStorage;
const BSTR = @import("automation.zig").BSTR;
const ITransaction = @import("component_services.zig").ITransaction;
const HWND = @import("windows_and_messaging.zig").HWND;
const VARIANT = @import("automation.zig").VARIANT;
const SYSTEMTIME = @import("windows_programming.zig").SYSTEMTIME;
const ITransactionOptions = @import("component_services.zig").ITransactionOptions;
const HANDLE = @import("system_services.zig").HANDLE;
const ISequentialStream = @import("structured_storage.zig").ISequentialStream;
const WORDREP_BREAK_TYPE = @import("index_server.zig").WORDREP_BREAK_TYPE;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    _ = PFNFILLTEXTBUFFER;

    const constant_export_count = 0;
    const type_export_count = 295;
    const enum_value_export_count = 800;
    const com_iface_id_export_count = 139;
    const com_class_id_export_count = 13;
    const func_export_count = 0;
    const unicode_alias_count = 0;
    const import_count = 35;
    @setEvalBranchQuota(
        constant_export_count +
        type_export_count +
        enum_value_export_count +
        com_iface_id_export_count * 2 + // * 2 for value and ptr
        com_class_id_export_count * 2 + // * 2 for value and ptr
        func_export_count +
        unicode_alias_count +
        import_count +
        2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
