//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Types (4)
//--------------------------------------------------------------------------------
const IID_IEnumSpeechCommands_Value = @import("../zig.zig").Guid.initString("8C5DAC4F-083C-4B85-A4C9-71746048ADCA");
pub const IID_IEnumSpeechCommands = &IID_IEnumSpeechCommands_Value;
pub const IEnumSpeechCommands = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: fn(
            self: *const IEnumSpeechCommands,
            ppEnum: **IEnumSpeechCommands,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: fn(
            self: *const IEnumSpeechCommands,
            ulCount: u32,
            pSpCmds: [*]*u16,
            pcFetched: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumSpeechCommands,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumSpeechCommands,
            ulCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSpeechCommands_Clone(self: *const T, ppEnum: **IEnumSpeechCommands) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSpeechCommands.VTable, self.vtable).Clone(@ptrCast(*const IEnumSpeechCommands, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSpeechCommands_Next(self: *const T, ulCount: u32, pSpCmds: [*]*u16, pcFetched: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSpeechCommands.VTable, self.vtable).Next(@ptrCast(*const IEnumSpeechCommands, self), ulCount, pSpCmds, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSpeechCommands_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSpeechCommands.VTable, self.vtable).Reset(@ptrCast(*const IEnumSpeechCommands, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumSpeechCommands_Skip(self: *const T, ulCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumSpeechCommands.VTable, self.vtable).Skip(@ptrCast(*const IEnumSpeechCommands, self), ulCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpeechCommandProvider_Value = @import("../zig.zig").Guid.initString("38E09D4C-586D-435A-B592-C8A86691DEC6");
pub const IID_ISpeechCommandProvider = &IID_ISpeechCommandProvider_Value;
pub const ISpeechCommandProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumSpeechCommands: fn(
            self: *const ISpeechCommandProvider,
            langid: u16,
            ppEnum: **IEnumSpeechCommands,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessCommand: fn(
            self: *const ISpeechCommandProvider,
            pszCommand: [*:0]const u16,
            cch: u32,
            langid: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechCommandProvider_EnumSpeechCommands(self: *const T, langid: u16, ppEnum: **IEnumSpeechCommands) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechCommandProvider.VTable, self.vtable).EnumSpeechCommands(@ptrCast(*const ISpeechCommandProvider, self), langid, ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpeechCommandProvider_ProcessCommand(self: *const T, pszCommand: [*:0]const u16, cch: u32, langid: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpeechCommandProvider.VTable, self.vtable).ProcessCommand(@ptrCast(*const ISpeechCommandProvider, self), pszCommand, cch, langid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITfFnCustomSpeechCommand_Value = @import("../zig.zig").Guid.initString("FCA6C349-A12F-43A3-8DD6-5A5A4282577B");
pub const IID_ITfFnCustomSpeechCommand = &IID_ITfFnCustomSpeechCommand_Value;
pub const ITfFnCustomSpeechCommand = extern struct {
    pub const VTable = extern struct {
        base: ITfFunction.VTable,
        SetSpeechCommandProvider: fn(
            self: *const ITfFnCustomSpeechCommand,
            pspcmdProvider: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITfFunction.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITfFnCustomSpeechCommand_SetSpeechCommandProvider(self: *const T, pspcmdProvider: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITfFnCustomSpeechCommand.VTable, self.vtable).SetSpeechCommandProvider(@ptrCast(*const ITfFnCustomSpeechCommand, self), pspcmdProvider);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const UAL_DATA_BLOB = extern struct {
    Size: u32,
    RoleGuid: Guid,
    TenantId: Guid,
    Address: SOCKADDR_STORAGE_LH,
    UserName: [260]u16,
};


//--------------------------------------------------------------------------------
// Section: Functions (5)
//--------------------------------------------------------------------------------
pub extern "MsCtfMonitor" fn DoMsCtfMonitor(
    dwFlags: u32,
    hEventForServiceStop: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ualapi" fn UalStart(
    Data: *UAL_DATA_BLOB,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ualapi" fn UalStop(
    Data: *UAL_DATA_BLOB,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ualapi" fn UalInstrument(
    Data: *UAL_DATA_BLOB,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ualapi" fn UalRegisterProduct(
    wszProductName: [*:0]const u16,
    wszRoleName: [*:0]const u16,
    wszGuid: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (8)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const PWSTR = @import("system_services.zig").PWSTR;
const IUnknown = @import("com.zig").IUnknown;
const SOCKADDR_STORAGE_LH = @import("network_drivers.zig").SOCKADDR_STORAGE_LH;
const HRESULT = @import("com.zig").HRESULT;
const HANDLE = @import("system_services.zig").HANDLE;
const ITfFunction = @import("text_services.zig").ITfFunction;
const BOOL = @import("system_services.zig").BOOL;

test {
    const constant_export_count = 0;
    const type_export_count = 4;
    const enum_value_export_count = 0;
    const com_iface_id_export_count = 3;
    const com_class_id_export_count = 0;
    const func_export_count = 5;
    const unicode_alias_count = 0;
    const import_count = 8;
    @setEvalBranchQuota(
        constant_export_count +
        type_export_count +
        enum_value_export_count +
        com_iface_id_export_count * 2 + // * 2 for value and ptr
        com_class_id_export_count * 2 + // * 2 for value and ptr
        func_export_count +
        unicode_alias_count +
        import_count +
        2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
