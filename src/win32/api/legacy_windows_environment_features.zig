//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Types (10)
//--------------------------------------------------------------------------------
const IID_IEmptyVolumeCacheCallBack_Value = @import("../zig.zig").Guid.initString("6E793361-73C6-11D0-8469-00AA00442901");
pub const IID_IEmptyVolumeCacheCallBack = &IID_IEmptyVolumeCacheCallBack_Value;
pub const IEmptyVolumeCacheCallBack = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ScanProgress: fn(
            self: *const IEmptyVolumeCacheCallBack,
            dwlSpaceUsed: u64,
            dwFlags: u32,
            pcwszStatus: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PurgeProgress: fn(
            self: *const IEmptyVolumeCacheCallBack,
            dwlSpaceFreed: u64,
            dwlSpaceToFree: u64,
            dwFlags: u32,
            pcwszStatus: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEmptyVolumeCacheCallBack_ScanProgress(self: *const T, dwlSpaceUsed: u64, dwFlags: u32, pcwszStatus: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEmptyVolumeCacheCallBack.VTable, self.vtable).ScanProgress(@ptrCast(*const IEmptyVolumeCacheCallBack, self), dwlSpaceUsed, dwFlags, pcwszStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEmptyVolumeCacheCallBack_PurgeProgress(self: *const T, dwlSpaceFreed: u64, dwlSpaceToFree: u64, dwFlags: u32, pcwszStatus: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEmptyVolumeCacheCallBack.VTable, self.vtable).PurgeProgress(@ptrCast(*const IEmptyVolumeCacheCallBack, self), dwlSpaceFreed, dwlSpaceToFree, dwFlags, pcwszStatus);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEmptyVolumeCache_Value = @import("../zig.zig").Guid.initString("8FCE5227-04DA-11D1-A004-00805F8ABE06");
pub const IID_IEmptyVolumeCache = &IID_IEmptyVolumeCache_Value;
pub const IEmptyVolumeCache = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IEmptyVolumeCache,
            hkRegKey: HKEY,
            pcwszVolume: [*:0]const u16,
            ppwszDisplayName: *PWSTR,
            ppwszDescription: *PWSTR,
            pdwFlags: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpaceUsed: fn(
            self: *const IEmptyVolumeCache,
            pdwlSpaceUsed: *u64,
            picb: *IEmptyVolumeCacheCallBack,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Purge: fn(
            self: *const IEmptyVolumeCache,
            dwlSpaceToFree: u64,
            picb: *IEmptyVolumeCacheCallBack,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowProperties: fn(
            self: *const IEmptyVolumeCache,
            hwnd: HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Deactivate: fn(
            self: *const IEmptyVolumeCache,
            pdwFlags: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEmptyVolumeCache_Initialize(self: *const T, hkRegKey: HKEY, pcwszVolume: [*:0]const u16, ppwszDisplayName: *PWSTR, ppwszDescription: *PWSTR, pdwFlags: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEmptyVolumeCache.VTable, self.vtable).Initialize(@ptrCast(*const IEmptyVolumeCache, self), hkRegKey, pcwszVolume, ppwszDisplayName, ppwszDescription, pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEmptyVolumeCache_GetSpaceUsed(self: *const T, pdwlSpaceUsed: *u64, picb: *IEmptyVolumeCacheCallBack) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEmptyVolumeCache.VTable, self.vtable).GetSpaceUsed(@ptrCast(*const IEmptyVolumeCache, self), pdwlSpaceUsed, picb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEmptyVolumeCache_Purge(self: *const T, dwlSpaceToFree: u64, picb: *IEmptyVolumeCacheCallBack) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEmptyVolumeCache.VTable, self.vtable).Purge(@ptrCast(*const IEmptyVolumeCache, self), dwlSpaceToFree, picb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEmptyVolumeCache_ShowProperties(self: *const T, hwnd: HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEmptyVolumeCache.VTable, self.vtable).ShowProperties(@ptrCast(*const IEmptyVolumeCache, self), hwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEmptyVolumeCache_Deactivate(self: *const T, pdwFlags: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEmptyVolumeCache.VTable, self.vtable).Deactivate(@ptrCast(*const IEmptyVolumeCache, self), pdwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEmptyVolumeCache2_Value = @import("../zig.zig").Guid.initString("02B7E3BA-4DB3-11D2-B2D9-00C04F8EEC8C");
pub const IID_IEmptyVolumeCache2 = &IID_IEmptyVolumeCache2_Value;
pub const IEmptyVolumeCache2 = extern struct {
    pub const VTable = extern struct {
        base: IEmptyVolumeCache.VTable,
        InitializeEx: fn(
            self: *const IEmptyVolumeCache2,
            hkRegKey: HKEY,
            pcwszVolume: [*:0]const u16,
            pcwszKeyName: [*:0]const u16,
            ppwszDisplayName: *PWSTR,
            ppwszDescription: *PWSTR,
            ppwszBtnText: *PWSTR,
            pdwFlags: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IEmptyVolumeCache.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEmptyVolumeCache2_InitializeEx(self: *const T, hkRegKey: HKEY, pcwszVolume: [*:0]const u16, pcwszKeyName: [*:0]const u16, ppwszDisplayName: *PWSTR, ppwszDescription: *PWSTR, ppwszBtnText: *PWSTR, pdwFlags: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEmptyVolumeCache2.VTable, self.vtable).InitializeEx(@ptrCast(*const IEmptyVolumeCache2, self), hkRegKey, pcwszVolume, pcwszKeyName, ppwszDisplayName, ppwszDescription, ppwszBtnText, pdwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IReconcileInitiator_Value = @import("../zig.zig").Guid.initString("99180161-DA16-101A-935C-444553540000");
pub const IID_IReconcileInitiator = &IID_IReconcileInitiator_Value;
pub const IReconcileInitiator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAbortCallback: fn(
            self: *const IReconcileInitiator,
            punkForAbort: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProgressFeedback: fn(
            self: *const IReconcileInitiator,
            ulProgress: u32,
            ulProgressMax: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IReconcileInitiator_SetAbortCallback(self: *const T, punkForAbort: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IReconcileInitiator.VTable, self.vtable).SetAbortCallback(@ptrCast(*const IReconcileInitiator, self), punkForAbort);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IReconcileInitiator_SetProgressFeedback(self: *const T, ulProgress: u32, ulProgressMax: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IReconcileInitiator.VTable, self.vtable).SetProgressFeedback(@ptrCast(*const IReconcileInitiator, self), ulProgress, ulProgressMax);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _reconcilef = extern enum(i32) {
    RECONCILEF_MAYBOTHERUSER = 1,
    RECONCILEF_FEEDBACKWINDOWVALID = 2,
    RECONCILEF_NORESIDUESOK = 4,
    RECONCILEF_OMITSELFRESIDUE = 8,
    RECONCILEF_RESUMERECONCILIATION = 16,
    RECONCILEF_YOUMAYDOTHEUPDATES = 32,
    RECONCILEF_ONLYYOUWERECHANGED = 64,
    ALL_RECONCILE_FLAGS = 127,
};
pub const RECONCILEF_MAYBOTHERUSER = _reconcilef.RECONCILEF_MAYBOTHERUSER;
pub const RECONCILEF_FEEDBACKWINDOWVALID = _reconcilef.RECONCILEF_FEEDBACKWINDOWVALID;
pub const RECONCILEF_NORESIDUESOK = _reconcilef.RECONCILEF_NORESIDUESOK;
pub const RECONCILEF_OMITSELFRESIDUE = _reconcilef.RECONCILEF_OMITSELFRESIDUE;
pub const RECONCILEF_RESUMERECONCILIATION = _reconcilef.RECONCILEF_RESUMERECONCILIATION;
pub const RECONCILEF_YOUMAYDOTHEUPDATES = _reconcilef.RECONCILEF_YOUMAYDOTHEUPDATES;
pub const RECONCILEF_ONLYYOUWERECHANGED = _reconcilef.RECONCILEF_ONLYYOUWERECHANGED;
pub const ALL_RECONCILE_FLAGS = _reconcilef.ALL_RECONCILE_FLAGS;

const IID_IReconcilableObject_Value = @import("../zig.zig").Guid.initString("99180162-DA16-101A-935C-444553540000");
pub const IID_IReconcilableObject = &IID_IReconcilableObject_Value;
pub const IReconcilableObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Reconcile: fn(
            self: *const IReconcilableObject,
            pInitiator: *IReconcileInitiator,
            dwFlags: u32,
            hwndOwner: HWND,
            hwndProgressFeedback: HWND,
            ulcInput: u32,
            rgpmkOtherInput: [*]*IMoniker,
            plOutIndex: *i32,
            pstgNewResidues: *IStorage,
            pvReserved: *c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProgressFeedbackMaxEstimate: fn(
            self: *const IReconcilableObject,
            pulProgressMax: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IReconcilableObject_Reconcile(self: *const T, pInitiator: *IReconcileInitiator, dwFlags: u32, hwndOwner: HWND, hwndProgressFeedback: HWND, ulcInput: u32, rgpmkOtherInput: [*]*IMoniker, plOutIndex: *i32, pstgNewResidues: *IStorage, pvReserved: *c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IReconcilableObject.VTable, self.vtable).Reconcile(@ptrCast(*const IReconcilableObject, self), pInitiator, dwFlags, hwndOwner, hwndProgressFeedback, ulcInput, rgpmkOtherInput, plOutIndex, pstgNewResidues, pvReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IReconcilableObject_GetProgressFeedbackMaxEstimate(self: *const T, pulProgressMax: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IReconcilableObject.VTable, self.vtable).GetProgressFeedbackMaxEstimate(@ptrCast(*const IReconcilableObject, self), pulProgressMax);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBriefcaseInitiator_Value = @import("../zig.zig").Guid.initString("99180164-DA16-101A-935C-444553540000");
pub const IID_IBriefcaseInitiator = &IID_IBriefcaseInitiator_Value;
pub const IBriefcaseInitiator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsMonikerInBriefcase: fn(
            self: *const IBriefcaseInitiator,
            pmk: *IMoniker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBriefcaseInitiator_IsMonikerInBriefcase(self: *const T, pmk: *IMoniker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBriefcaseInitiator.VTable, self.vtable).IsMonikerInBriefcase(@ptrCast(*const IBriefcaseInitiator, self), pmk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _ColumnSortOrder = extern enum(i32) {
    SortOrder_Ascending = 0,
    SortOrder_Descending = 1,
};
pub const SortOrder_Ascending = _ColumnSortOrder.SortOrder_Ascending;
pub const SortOrder_Descending = _ColumnSortOrder.SortOrder_Descending;

const IID_IActiveDesktopP_Value = @import("../zig.zig").Guid.initString("52502EE0-EC80-11D0-89AB-00C04FC2972D");
pub const IID_IActiveDesktopP = &IID_IActiveDesktopP_Value;
pub const IActiveDesktopP = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetSafeMode: fn(
            self: *const IActiveDesktopP,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnsureUpdateHTML: fn(
            self: *const IActiveDesktopP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetScheme: fn(
            self: *const IActiveDesktopP,
            pwszSchemeName: [*:0]const u16,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScheme: fn(
            self: *const IActiveDesktopP,
            pwszSchemeName: [*:0]u16,
            pdwcchBuffer: *u32,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveDesktopP_SetSafeMode(self: *const T, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveDesktopP.VTable, self.vtable).SetSafeMode(@ptrCast(*const IActiveDesktopP, self), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveDesktopP_EnsureUpdateHTML(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveDesktopP.VTable, self.vtable).EnsureUpdateHTML(@ptrCast(*const IActiveDesktopP, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveDesktopP_SetScheme(self: *const T, pwszSchemeName: [*:0]const u16, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveDesktopP.VTable, self.vtable).SetScheme(@ptrCast(*const IActiveDesktopP, self), pwszSchemeName, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveDesktopP_GetScheme(self: *const T, pwszSchemeName: [*:0]u16, pdwcchBuffer: *u32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveDesktopP.VTable, self.vtable).GetScheme(@ptrCast(*const IActiveDesktopP, self), pwszSchemeName, pdwcchBuffer, dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IADesktopP2_Value = @import("../zig.zig").Guid.initString("B22754E2-4574-11D1-9888-006097DEACF9");
pub const IID_IADesktopP2 = &IID_IADesktopP2_Value;
pub const IADesktopP2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReReadWallpaper: fn(
            self: *const IADesktopP2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetADObjectFlags: fn(
            self: *const IADesktopP2,
            pdwFlags: *u32,
            dwMask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateAllDesktopSubscriptions: fn(
            self: *const IADesktopP2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MakeDynamicChanges: fn(
            self: *const IADesktopP2,
            pOleObj: *IOleObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IADesktopP2_ReReadWallpaper(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IADesktopP2.VTable, self.vtable).ReReadWallpaper(@ptrCast(*const IADesktopP2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IADesktopP2_GetADObjectFlags(self: *const T, pdwFlags: *u32, dwMask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IADesktopP2.VTable, self.vtable).GetADObjectFlags(@ptrCast(*const IADesktopP2, self), pdwFlags, dwMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IADesktopP2_UpdateAllDesktopSubscriptions(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IADesktopP2.VTable, self.vtable).UpdateAllDesktopSubscriptions(@ptrCast(*const IADesktopP2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IADesktopP2_MakeDynamicChanges(self: *const T, pOleObj: *IOleObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IADesktopP2.VTable, self.vtable).MakeDynamicChanges(@ptrCast(*const IADesktopP2, self), pOleObj);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (8)
//--------------------------------------------------------------------------------
const HKEY = @import("windows_programming.zig").HKEY;
const PWSTR = @import("system_services.zig").PWSTR;
const IUnknown = @import("com.zig").IUnknown;
const HRESULT = @import("com.zig").HRESULT;
const IMoniker = @import("com.zig").IMoniker;
const IStorage = @import("structured_storage.zig").IStorage;
const HWND = @import("windows_and_messaging.zig").HWND;
const IOleObject = @import("com.zig").IOleObject;

test {
    const constant_export_count = 0;
    const type_export_count = 10;
    const enum_value_export_count = 10;
    const com_iface_id_export_count = 8;
    const com_class_id_export_count = 0;
    const func_export_count = 0;
    const unicode_alias_count = 0;
    const import_count = 8;
    @setEvalBranchQuota(
        constant_export_count +
        type_export_count +
        enum_value_export_count +
        com_iface_id_export_count * 2 + // * 2 for value and ptr
        com_class_id_export_count * 2 + // * 2 for value and ptr
        func_export_count +
        unicode_alias_count +
        import_count +
        2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
